d.d:3:8: error: std/stdio.d: no such file
import std.stdio, std.algorithm, std.array;
       ^~~~~~~~~
d.d:3:19: error: std/algorithm.d: no such file
import std.stdio, std.algorithm, std.array;
                  ^~~~~~~~~~~~~
d.d:3:34: error: std/array.d: no such file
import std.stdio, std.algorithm, std.array;
                                 ^~~~~~~~~
lexer.d:3:8: error: std/string.d: no such file
import std.string, utf = std.utf, std.uni;
       ^~~~~~~~~~
lexer.d:3:20: error: std/utf.d: no such file
import std.string, utf = std.utf, std.uni;
                   ^~~~~~~~~~~~~
lexer.d:3:35: error: std/uni.d: no such file
import std.string, utf = std.utf, std.uni;
                                  ^~~~~~~
lexer.d:4:19: error: std/conv.d: no such file
import std.stdio, std.conv;
                  ^~~~~~~~
lexer.d:259:9: error: feature declaration.UnionDecl not implemented
	union{
        ^~~~~~
lexer.d:268:1: error: feature declaration.UnitTestDecl not implemented
unittest{
^~~~~~~~~
lexer.d:1195:1: error: feature declaration.UnitTestDecl not implemented
unittest{
^~~~~~~~~
parser.d:3:23: error: std/range.d: no such file
import std.algorithm, std.range, std.conv;
                      ^~~~~~~~~
vrange.d:4:23: error: std/math.d: no such file
import std.algorithm, std.math;
                      ^~~~~~~~
vrange.d:382:1: error: feature declaration.UnitTestDecl not implemented
unittest{
^~~~~~~~~
vrange.d:413:1: error: feature declaration.VersionDecl not implemented
version(unittest){void main(){}}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:7:8: error: std/typecons.d: no such file
import std.typecons : q=tuple, Q=Tuple;
       ^~~~~~~~~~~~
interpret.d:902:18: error: unimplemented feature ArrayInitAssocExp
		 I.hlt: 1, I.hltstr:1, I.call: 1,
                 ^~~~~~~~
interpret.d:902:28: error: unimplemented feature ArrayInitAssocExp
		 I.hlt: 1, I.hltstr:1, I.call: 1,
                           ^~~~~~~~~~
interpret.d:902:40: error: unimplemented feature ArrayInitAssocExp
		 I.hlt: 1, I.hltstr:1, I.call: 1,
                                       ^~~~~~~~~
interpret.d:904:18: error: unimplemented feature ArrayInitAssocExp
		 I.pushcn: 1, I.popcn: 1, I.popckvn: 1, I.popckrn: 1,
                 ^~~~~~~~~~~
interpret.d:904:31: error: unimplemented feature ArrayInitAssocExp
		 I.pushcn: 1, I.popcn: 1, I.popckvn: 1, I.popckrn: 1,
                              ^~~~~~~~~~
interpret.d:904:43: error: unimplemented feature ArrayInitAssocExp
		 I.pushcn: 1, I.popcn: 1, I.popckvn: 1, I.popckrn: 1,
                                          ^~~~~~~~~~~~
interpret.d:904:57: error: unimplemented feature ArrayInitAssocExp
		 I.pushcn: 1, I.popcn: 1, I.popckvn: 1, I.popckrn: 1,
                                                        ^~~~~~~~~~~~
interpret.d:905:18: error: unimplemented feature ArrayInitAssocExp
		 I.pushccn: 1, I.popccn: 1, I.popcckvn: 1, I.popcckrn: 1,
                 ^~~~~~~~~~~~
interpret.d:905:32: error: unimplemented feature ArrayInitAssocExp
		 I.pushccn: 1, I.popccn: 1, I.popcckvn: 1, I.popcckrn: 1,
                               ^~~~~~~~~~~
interpret.d:905:45: error: unimplemented feature ArrayInitAssocExp
		 I.pushccn: 1, I.popccn: 1, I.popcckvn: 1, I.popcckrn: 1,
                                            ^~~~~~~~~~~~~
interpret.d:905:60: error: unimplemented feature ArrayInitAssocExp
		 I.pushccn: 1, I.popccn: 1, I.popcckvn: 1, I.popcckrn: 1,
                                                           ^~~~~~~~~~~~~
interpret.d:906:18: error: unimplemented feature ArrayInitAssocExp
		 I.ptrfc: 1, I.ptrfcc: 1, I.pushcontext: 1,
                 ^~~~~~~~~~
interpret.d:906:30: error: unimplemented feature ArrayInitAssocExp
		 I.ptrfc: 1, I.ptrfcc: 1, I.pushcontext: 1,
                             ^~~~~~~~~~~
interpret.d:906:43: error: unimplemented feature ArrayInitAssocExp
		 I.ptrfc: 1, I.ptrfcc: 1, I.pushcontext: 1,
                                          ^~~~~~~~~~~~~~~~
interpret.d:908:18: error: unimplemented feature ArrayInitAssocExp
		 I.divi: 1, I.divsi: 1, I.modi: 1, I.modsi: 1,
                 ^~~~~~~~~
interpret.d:908:29: error: unimplemented feature ArrayInitAssocExp
		 I.divi: 1, I.divsi: 1, I.modi: 1, I.modsi: 1,
                            ^~~~~~~~~~
interpret.d:908:41: error: unimplemented feature ArrayInitAssocExp
		 I.divi: 1, I.divsi: 1, I.modi: 1, I.modsi: 1,
                                        ^~~~~~~~~
interpret.d:908:52: error: unimplemented feature ArrayInitAssocExp
		 I.divi: 1, I.divsi: 1, I.modi: 1, I.modsi: 1,
                                                   ^~~~~~~~~~
interpret.d:909:18: error: unimplemented feature ArrayInitAssocExp
		 I.shl32: 1, I.shr32: 1, I.sar32: 1, I.shl64: 1, I.shr64: 1, I.sar64: 1,
                 ^~~~~~~~~~
interpret.d:909:30: error: unimplemented feature ArrayInitAssocExp
		 I.shl32: 1, I.shr32: 1, I.sar32: 1, I.shl64: 1, I.shr64: 1, I.sar64: 1,
                             ^~~~~~~~~~
interpret.d:909:42: error: unimplemented feature ArrayInitAssocExp
		 I.shl32: 1, I.shr32: 1, I.sar32: 1, I.shl64: 1, I.shr64: 1, I.sar64: 1,
                                         ^~~~~~~~~~
interpret.d:909:54: error: unimplemented feature ArrayInitAssocExp
		 I.shl32: 1, I.shr32: 1, I.sar32: 1, I.shl64: 1, I.shr64: 1, I.sar64: 1,
                                                     ^~~~~~~~~~
interpret.d:909:66: error: unimplemented feature ArrayInitAssocExp
		 I.shl32: 1, I.shr32: 1, I.sar32: 1, I.shl64: 1, I.shr64: 1, I.sar64: 1,
                                                                 ^~~~~~~~~~
interpret.d:909:78: error: unimplemented feature ArrayInitAssocExp
		 I.shl32: 1, I.shr32: 1, I.sar32: 1, I.shl64: 1, I.shr64: 1, I.sar64: 1,
                                                                             ^~~~~~~~~~
interpret.d:911:18: error: unimplemented feature ArrayInitAssocExp
		 I.loada: 1, I.loadak: 1, I.storea: 1, I.storeakr: 1, I.storeakv: 1, I.slicea: 1,
                 ^~~~~~~~~~
interpret.d:911:30: error: unimplemented feature ArrayInitAssocExp
		 I.loada: 1, I.loadak: 1, I.storea: 1, I.storeakr: 1, I.storeakv: 1, I.slicea: 1,
                             ^~~~~~~~~~~
interpret.d:911:43: error: unimplemented feature ArrayInitAssocExp
		 I.loada: 1, I.loadak: 1, I.storea: 1, I.storeakr: 1, I.storeakv: 1, I.slicea: 1,
                                          ^~~~~~~~~~~
interpret.d:911:56: error: unimplemented feature ArrayInitAssocExp
		 I.loada: 1, I.loadak: 1, I.storea: 1, I.storeakr: 1, I.storeakv: 1, I.slicea: 1,
                                                       ^~~~~~~~~~~~~
interpret.d:911:71: error: unimplemented feature ArrayInitAssocExp
		 I.loada: 1, I.loadak: 1, I.storea: 1, I.storeakr: 1, I.storeakv: 1, I.slicea: 1,
                                                                      ^~~~~~~~~~~~~
interpret.d:911:86: error: unimplemented feature ArrayInitAssocExp
		 I.loada: 1, I.loadak: 1, I.storea: 1, I.storeakr: 1, I.storeakv: 1, I.slicea: 1,
                                                                                     ^~~~~~~~~~~
interpret.d:912:18: error: unimplemented feature ArrayInitAssocExp
		 I.loadaa: 1, I.loadaak: 1, I.storeaa: 1, I.storeaakr: 1, I.storeaakv: 1,
                 ^~~~~~~~~~~
interpret.d:912:31: error: unimplemented feature ArrayInitAssocExp
		 I.loadaa: 1, I.loadaak: 1, I.storeaa: 1, I.storeaakr: 1, I.storeaakv: 1,
                              ^~~~~~~~~~~~
interpret.d:912:45: error: unimplemented feature ArrayInitAssocExp
		 I.loadaa: 1, I.loadaak: 1, I.storeaa: 1, I.storeaakr: 1, I.storeaakv: 1,
                                            ^~~~~~~~~~~~
interpret.d:912:59: error: unimplemented feature ArrayInitAssocExp
		 I.loadaa: 1, I.loadaak: 1, I.storeaa: 1, I.storeaakr: 1, I.storeaakv: 1,
                                                          ^~~~~~~~~~~~~~
interpret.d:912:75: error: unimplemented feature ArrayInitAssocExp
		 I.loadaa: 1, I.loadaak: 1, I.storeaa: 1, I.storeaakr: 1, I.storeaakv: 1,
                                                                          ^~~~~~~~~~~~~~
interpret.d:914:18: error: unimplemented feature ArrayInitAssocExp
		 I.loadap: 1, I.ptrtoa: 1,
                 ^~~~~~~~~~~
interpret.d:914:31: error: unimplemented feature ArrayInitAssocExp
		 I.loadap: 1, I.ptrtoa: 1,
                              ^~~~~~~~~~~
interpret.d:916:18: error: unimplemented feature ArrayInitAssocExp
		 I.loadf: 1, I.loadfkr: 1, I.storef: 1, I.storefkr: 1, I.storefkv: 1, I.ptrf: 1,
                 ^~~~~~~~~~
interpret.d:916:30: error: unimplemented feature ArrayInitAssocExp
		 I.loadf: 1, I.loadfkr: 1, I.storef: 1, I.storefkr: 1, I.storefkv: 1, I.ptrf: 1,
                             ^~~~~~~~~~~~
interpret.d:916:44: error: unimplemented feature ArrayInitAssocExp
		 I.loadf: 1, I.loadfkr: 1, I.storef: 1, I.storefkr: 1, I.storefkv: 1, I.ptrf: 1,
                                           ^~~~~~~~~~~
interpret.d:916:57: error: unimplemented feature ArrayInitAssocExp
		 I.loadf: 1, I.loadfkr: 1, I.storef: 1, I.storefkr: 1, I.storefkv: 1, I.ptrf: 1,
                                                        ^~~~~~~~~~~~~
interpret.d:916:72: error: unimplemented feature ArrayInitAssocExp
		 I.loadf: 1, I.loadfkr: 1, I.storef: 1, I.storefkr: 1, I.storefkv: 1, I.ptrf: 1,
                                                                       ^~~~~~~~~~~~~
interpret.d:916:87: error: unimplemented feature ArrayInitAssocExp
		 I.loadf: 1, I.loadfkr: 1, I.storef: 1, I.storefkr: 1, I.storefkv: 1, I.ptrf: 1,
                                                                                      ^~~~~~~~~
interpret.d:918:18: error: unimplemented feature ArrayInitAssocExp
		 I.castfromvarr: 1, I.castfromvptr: 1,
                 ^~~~~~~~~~~~~~~~~
interpret.d:918:37: error: unimplemented feature ArrayInitAssocExp
		 I.castfromvarr: 1, I.castfromvptr: 1,
                                    ^~~~~~~~~~~~~~~~~
interpret.d:919:18: error: unimplemented feature ArrayInitAssocExp
		 I.max: 0
                 ^~~~~~~~
type.d:13:8: error: std/traits.d: no such file
import std.traits : Unqual;
       ^~~~~~~~~~
vrange.d:380:8: error: std/random.d: no such file
import std.random;
       ^~~~~~~~~~
parser.d:932:17: error: unimplemented feature SwitchStm
		switch(ttype){
                ^~~~~~~~~~~~~~
parser.d:955:25: error: unimplemented feature SwitchStm
			switch(ttype){
                        ^~~~~~~~~~~~~~
terminal.d:18:1: error: feature declaration.VersionDecl not implemented
version(linux){
^~~~~~~~~~~~~~~
hashtable.d:3:22: error: std/typetuple.d: no such file
import std.typecons, std.typetuple;
                     ^~~~~~~~~~~~~
hashtable.d:4:8: error: std/functional.d: no such file
import std.functional, std.algorithm;
       ^~~~~~~~~~~~~~
hashtable.d:316:1: error: feature declaration.VersionDecl not implemented
version(none)
^~~~~~~~~~~~~
rope_.d:3:1: error: feature declaration.ModuleDecl not implemented
module rope_; // underscore to not conflict with the eponymous function
^~~~~~~~~~~~~
lexer.d:8:8: error: core/memory.d: no such file
import core.memory;
       ^~~~~~~~~~~
util.d:15:8: error: std/c/stdlib.d: no such file
import std.c.stdlib;
       ^~~~~~~~~~~~
variant.d:236:9: error: feature declaration.UnionDecl not implemented
	private union{
        ^~~~~~~~~~~~~~
variant.d:241:17: error: feature declaration.StructDecl not implemented
		struct{
                ^~~~~~~
variant.d:242:25: error: feature declaration.UnionDecl not implemented
			union{
                        ^~~~~~
variant.d:252:17: error: feature declaration.StructDecl not implemented
		struct{
                ^~~~~~~
d.d:9:8: error: std/path.d: no such file
import std.path;
       ^~~~~~~~
expression.d:279:17: error: current object 'super' of type 'Identifier' is not callable
	this(){ super(q{$}); }
                ^~~~~~~~~~~
semantic.d:4694:9: error: unimplemented feature WithStm
	with(InoutRes){
        ^~~~~~~~~~~~~~~
util.d:16:8: error: std/c/string.d: no such file
import std.c.string;
       ^~~~~~~~~~~~
util.d:164:5: error: type 'void*' is not an expression
int[void*] tag;
    ^~~~~
interpret.d:1102:17: error: unimplemented feature ForeachRangeStm
		foreach(i;0..num) emit(Instruction.tmppush);
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:1105:17: error: unimplemented feature ForeachRangeStm
		foreach(i;0..num) emit(Instruction.tmppop);
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:1153:27: error: no member 'sizeof' for type 'real'
		static if(real.sizeof == 12){
                          ^~~~~~~~~~~
expression.d:273:17: error: current object 'super' of type 'Identifier' is not callable
	this(){ super(q{~this}); }
                ^~~~~~~~~~~~~~~
expression.d:276:17: error: current object 'super' of type 'Identifier' is not callable
	this(){ super(q{invariant}); }
                ^~~~~~~~~~~~~~~~~~~
module_.d:11:8: error: std/file.d: no such file
import file=std.file;
       ^~~~~~~~~~~~~
interpret.d:941:23: error: no member 'sizeof' for type 'ulong'
	static assert(ulong.sizeof>=(void*).sizeof);
                      ^~~~~~~~~~~~
interpret.d:941:37: error: no member 'sizeof' for type 'void*'
	static assert(ulong.sizeof>=(void*).sizeof);
                                    ^~~~~~~~~~~~~~
interpret.d:970:28: error: no member 'sizeof' for type 'ulong'
		auto sz = (ulong.sizeof-1+c.length)/ulong.sizeof;
                           ^~~~~~~~~~~~
interpret.d:970:53: error: no member 'sizeof' for type 'ulong'
		auto sz = (ulong.sizeof-1+c.length)/ulong.sizeof;
                                                    ^~~~~~~~~~~~
interpret.d:971:17: error: unimplemented feature ForeachRangeStm
		foreach(i;0..sz) pushl(0);
                ^~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:974:24: error: core/stdc/string.d: no such file
		import core.stdc.string;
                       ^~~~~~~~~~~~~~~~
lexer.d:1129:9: error: unimplemented feature SwitchStm
	switch(*p){
        ^~~~~~~~~~~
util.d:84:15: error: undefined identifier 'string'
string lowerf(string s){
              ^~~~~~
util.d:89:15: error: undefined identifier 'string'
string upperf(string s){
              ^~~~~~
util.d:268:21: error: undefined identifier 'string'
template FileExists(string name){enum FileExists = is(typeof(import(name)));}
                    ^~~~~~
util.d:277:18: error: undefined identifier 'string'
template WriteTo(string name, alias data, CTWriteMode mode=CTWriteMode.clear){ // bug: data cannot contain some forms of XML code
                 ^~~~~~
util.d:327:12: error: undefined identifier 'string'
template X(string x){
           ^~~~~~
util.d:141:23: error: undefined identifier 'T'
struct NoOpAppender(T:T[]){
                      ^
util.d:71:15: error: undefined identifier 'string'
string indent(string code){
              ^~~~~~
hashtable.d:288:19: error: undefined identifier 'size_t'
private static if(size_t.sizeof==4) enum fnvp = 16777619U, fnvb = 2166136261U;
                  ^~~~~~
util.d:308:22: error: undefined identifier 'string'
private string Ximpl(string x){
                     ^~~~~~
util.d:331:13: error: undefined identifier 'string'
template XX(string x){
            ^~~~~~
interpret.d:1203:26: error: too many arguments to struct literal (expected zero)
		auto r = Label(&this, byteCode.length);
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
util.d:161:7: error: no member 'New' for type 'GCAlloc'
alias GCAlloc.New New; // transparently replace allocator
      ^~~~~~~~~~~
semantic.d:2166:21: error: function call result 'this.isGagged()' of type 'bool' is not callable
		if(!isGagged) Scheduler().add(this, scope_);
                    ^~~~~~~~
hashtable.d:310:16: error: undefined identifier 'size_t'
auto assocHash(size_t data){ return AssocHash(data); }
               ^~~~~~
util.d:245:1: error: undefined identifier 'string'
string toEngNum(uint i){ // pure
^~~~~~
hashtable.d:281:22: error: undefined identifier 'Object'
size_t identityHash0(Object o){
                     ^~~~~~
lexer.d:340:25: error: function call result 'this.empty()' of type 'bool' is not callable
		assert(!empty,"attempted to popFront empty lexer.");
                        ^~~~~
interpret.d:832:22: error: no member 'sizeof' for type 'Instruction'
private enum isize = Instruction.sizeof;
                     ^~~~~~~~~~~~~~~~~~
util.d:97:25: error: undefined identifier 'T'
struct MallocAppender(T:T[]){ // NO RAII. Loosely compatible to the std.array.appender interface.
                        ^
hashtable.d:305:9: error: undefined identifier 'size_t'
	size_t value;
        ^~~~~~
parser.d:1592:42: error: no member 'init' for type 'long'
	BlockDecl parseBlockDecl(STC stc=STC.init){
                                         ^~~~~~~~
parser.d:1439:48: error: no member 'init' for type 'long'
	Declaration parseAggregateDecl(STC stc=STC.init, bool anonclass=false)in{assert(anonclass||ttype==Tok!"struct"||ttype==Tok!"union"||ttype==Tok!"class"||ttype==Tok!"interface");}body{
                                               ^~~~~~~~
hashtable.d:291:12: error: undefined identifier 'size_t'
size_t FNV(size_t data, size_t start=fnvb){
           ^~~~~~
parser.d:1363:40: error: no member 'init' for type 'long'
	EnumDecl parseEnumDecl(STC stc=STC.init){
                                       ^~~~~~~~
hashtable.d:284:22: error: undefined identifier 'Object'
size_t identityHash1(Object o){
                     ^~~~~~
interpret.d:1076:40: error: no member 'max' for type 'ulong'
		assert(byteCode.length<ulong.max); // TODO: add this restriction explicitly
                                       ^~~~~~~~~
interpret.d:1200:24: error: too many arguments to struct literal (expected zero)
		return Label(&this);
                       ^~~~~~~~~~~~
parser.d:1337:45: error: no member 'init' for type 'long'
	Declaration parseImportDecl(STC stc=STC.init){
                                            ^~~~~~~~
util.d:71:1: error: undefined identifier 'string'
string indent(string code){
^~~~~~
util.d:84:1: error: undefined identifier 'string'
string lowerf(string s){
^~~~~~
util.d:89:1: error: undefined identifier 'string'
string upperf(string s){
^~~~~~
util.d:308:9: error: undefined identifier 'string'
private string Ximpl(string x){
        ^~~~~~
expression.d:405:23: error: cannot cast expression 'e' of type 'Expression' to 'bool'
		this(!e?0.assocHash():e.tmplArgToHash().assocHash(),!e||e.isType());
                      ^
expression.d:405:70: error: cannot cast expression 'e' of type 'Expression' to 'bool'
		this(!e?0.assocHash():e.tmplArgToHash().assocHash(),!e||e.isType());
                                                                     ^
hashtable.d:284:1: error: undefined identifier 'size_t'
size_t identityHash1(Object o){
^~~~~~
scheduler.d:248:24: error: cannot cast expression 'instance' of type 'Scheduler' to 'bool'
		return instance?instance:(instance=new Scheduler);
                       ^~~~~~~~
hashtable.d:291:25: error: undefined identifier 'size_t'
size_t FNV(size_t data, size_t start=fnvb){
                        ^~~~~~
hashtable.d:281:1: error: undefined identifier 'size_t'
size_t identityHash0(Object o){
^~~~~~
scope_.d:607:28: error: current object 'super' of type 'NestedScope' is not callable
	this(Scope parent){super(parent);}
                           ^~~~~~~~~~~~~
scope_.d:680:17: error: current object 'super' of type 'OrderedScope' is not callable
		super(parent);
                ^~~~~~~~~~~~~
lexer.d:176:42: error: incompatible types 'Source[]' and 'Source' for binary is
		foreach(i,x; sources) if(x is this){
                                         ^~~~~~~~~
vrange.d:191:20: error: undefined identifier 'string'
	R opBinary(string op:"/")(R rhs)in{assert(signed==rhs.signed);}body{
                   ^~~~~~
vrange.d:249:20: error: undefined identifier 'string'
	R opBinary(string op:"<<")(R rhs){ // do not care about signedness of rhs!
                   ^~~~~~
vrange.d:136:20: error: undefined identifier 'string'
	R opBinary(string op:"|")(R rhs)in{assert(signed==rhs.signed);}body{
                   ^~~~~~
vrange.d:107:20: error: undefined identifier 'string'
	R opBinary(string op:"^")(R rhs)in{assert(signed==rhs.signed);}body{
                   ^~~~~~
vrange.d:23:9: error: undefined identifier 'string'
	string toString(){return signed?text(cast(S)min,"..",cast(S)max):text(min,"..",max);}
        ^~~~~~
vrange.d:174:20: error: undefined identifier 'string'
	R opBinary(string op:"-")(R rhs)in{assert(signed==rhs.signed);}body{
                   ^~~~~~
vrange.d:104:19: error: undefined identifier 'string'
	R opUnary(string op:"~")(){return R(~max,~min,signed);}
                  ^~~~~~
variant.d:676:20: error: function call result 'this.occupies()' of type 'Occupies' is not callable
		if(occupies == Occupies.arr){
                   ^~~~~~~~
vrange.d:105:19: error: undefined identifier 'string'
	R opUnary(string op:"-")(){return ~this+R(1,1,signed);}
                  ^~~~~~
vrange.d:112:20: error: undefined identifier 'string'
	R opBinary(string op:"&")(R rhs)in{assert(signed==rhs.signed);}body{
                   ^~~~~~
vrange.d:217:20: error: undefined identifier 'string'
	R opBinary(string op:"*")(R rhs)in{assert(signed==rhs.signed);}body{
                   ^~~~~~
vrange.d:294:20: error: undefined identifier 'string'
	R opBinary(string op:">>>")(R rhs){
                   ^~~~~~
vrange.d:243:20: error: undefined identifier 'string'
	R opBinary(string op:"^^")(R rhs)in{assert(signed==rhs.signed);}body{
                   ^~~~~~
vrange.d:191:20: error: undefined identifier 'string'
	R opBinary(string op:"/")(R rhs)in{assert(signed==rhs.signed);}body{
                   ^~~~~~
vrange.d:294:20: error: undefined identifier 'string'
	R opBinary(string op:">>>")(R rhs){
                   ^~~~~~
vrange.d:306:20: error: undefined identifier 'string'
	R opBinary(string op:"%")(R rhs)in{assert(signed==rhs.signed);}body{
                   ^~~~~~
vrange.d:249:20: error: undefined identifier 'string'
	R opBinary(string op:"<<")(R rhs){ // do not care about signedness of rhs!
                   ^~~~~~
vrange.d:306:20: error: undefined identifier 'string'
	R opBinary(string op:"%")(R rhs)in{assert(signed==rhs.signed);}body{
                   ^~~~~~
vrange.d:158:20: error: undefined identifier 'string'
	R opBinary(string op:"+")(R rhs)in{assert(signed==rhs.signed);}body{
                   ^~~~~~
vrange.d:136:20: error: undefined identifier 'string'
	R opBinary(string op:"|")(R rhs)in{assert(signed==rhs.signed);}body{
                   ^~~~~~
vrange.d:158:20: error: undefined identifier 'string'
	R opBinary(string op:"+")(R rhs)in{assert(signed==rhs.signed);}body{
                   ^~~~~~
vrange.d:107:20: error: undefined identifier 'string'
	R opBinary(string op:"^")(R rhs)in{assert(signed==rhs.signed);}body{
                   ^~~~~~
vrange.d:23:9: error: undefined identifier 'string'
	string toString(){return signed?text(cast(S)min,"..",cast(S)max):text(min,"..",max);}
        ^~~~~~
vrange.d:174:20: error: undefined identifier 'string'
	R opBinary(string op:"-")(R rhs)in{assert(signed==rhs.signed);}body{
                   ^~~~~~
interpret.d:1006:9: error: undefined identifier 'string'
	string toString(){
        ^~~~~~
variant.d:517:26: error: undefined identifier 'string'
	Variant opBinary(string op)(Variant rhs)in{
                         ^~~~~~
vrange.d:104:19: error: undefined identifier 'string'
	R opUnary(string op:"~")(){return R(~max,~min,signed);}
                  ^~~~~~
lexer.d:171:27: error: undefined identifier 'string'
	static Source get(string rep){
                          ^~~~~~
vrange.d:105:19: error: undefined identifier 'string'
	R opUnary(string op:"-")(){return ~this+R(1,1,signed);}
                  ^~~~~~
vrange.d:243:20: error: undefined identifier 'string'
	R opBinary(string op:"^^")(R rhs)in{assert(signed==rhs.signed);}body{
                   ^~~~~~
vrange.d:112:20: error: undefined identifier 'string'
	R opBinary(string op:"&")(R rhs)in{assert(signed==rhs.signed);}body{
                   ^~~~~~
lexer.d:162:26: error: undefined identifier 'string'
	string getLineOf(string rep)in{assert(this is get(rep));}body{
                         ^~~~~~
lexer.d:162:9: error: undefined identifier 'string'
	string getLineOf(string rep)in{assert(this is get(rep));}body{
        ^~~~~~
vrange.d:217:20: error: undefined identifier 'string'
	R opBinary(string op:"*")(R rhs)in{assert(signed==rhs.signed);}body{
                   ^~~~~~
vrange.d:285:20: error: undefined identifier 'string'
	R opBinary(string op:">>")(R rhs){
                   ^~~~~~
vrange.d:285:20: error: undefined identifier 'string'
	R opBinary(string op:">>")(R rhs){
                   ^~~~~~
variant.d:697:20: error: function call result 'this.occupies()' of type 'Occupies' is not callable
		if(occupies == Occupies.arr){
                   ^~~~~~~~
interpret.d:1247:26: error: too many arguments to struct literal (expected zero)
		auto r = Allocc(&this, byteCode.length);
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
variant.d:27:24: error: too many arguments to struct literal (expected zero)
		return BCPointer(container, slice.ptr);
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
type.d:127:26: error: undefined identifier 'string'
	static @property string suffix(){
                         ^~~~~~
d.d:14:10: error: undefined identifier 'string'
int main(string[] args){
         ^~~~~~
interpret.d:1066:20: error: undefined identifier 'string'
	void error(string err, Location loc){
                   ^~~~~~
lexer.d:187:9: error: undefined identifier 'string'
	string rep;    // slice of the code representing the Location
        ^~~~~~
scope_.d:104:24: error: cannot cast expression 'inex' of type 'DoesNotExistDecl' to 'bool'
		return inex?inex:(inex=New!DoesNotExistDecl(null));
                       ^~~~
vrange.d:79:39: error: undefined identifier 'min'
		if(!signed) return R(.min(min, rhs.min), .max(max, rhs.max), 0);
                                      ^~~
hashtable.d:291:38: error: undefined identifier 'fnvb'
size_t FNV(size_t data, size_t start=fnvb){
                                     ^~~~
vrange.d:79:39: error: undefined identifier 'min'
		if(!signed) return R(.min(min, rhs.min), .max(max, rhs.max), 0);
                                      ^~~
scope_.d:464:17: error: current object 'super' of type 'NestedScope' is not callable
		super(parent);
                ^~~~~~~~~~~~~
scope_.d:213:26: error: undefined identifier 'string'
		override string toString(){
                         ^~~~~~
hashtable.d:291:1: error: undefined identifier 'size_t'
size_t FNV(size_t data, size_t start=fnvb){
^~~~~~
vrange.d:62:52: error: no member 'min' for type 'int'
	static R full(bool signed){return signed?R(S.min,S.max,true):R(T.min,T.max,false);}
                                                   ^~~~~
vrange.d:62:58: error: no member 'max' for type 'int'
	static R full(bool signed){return signed?R(S.min,S.max,true):R(T.min,T.max,false);}
                                                         ^~~~~
vrange.d:62:72: error: no member 'min' for type 'uint'
	static R full(bool signed){return signed?R(S.min,S.max,true):R(T.min,T.max,false);}
                                                                       ^~~~~
vrange.d:62:78: error: no member 'max' for type 'uint'
	static R full(bool signed){return signed?R(S.min,S.max,true):R(T.min,T.max,false);}
                                                                             ^~~~~
vrange.d:62:52: error: no member 'min' for type 'long'
	static R full(bool signed){return signed?R(S.min,S.max,true):R(T.min,T.max,false);}
                                                   ^~~~~
vrange.d:62:58: error: no member 'max' for type 'long'
	static R full(bool signed){return signed?R(S.min,S.max,true):R(T.min,T.max,false);}
                                                         ^~~~~
vrange.d:62:72: error: no member 'min' for type 'ulong'
	static R full(bool signed){return signed?R(S.min,S.max,true):R(T.min,T.max,false);}
                                                                       ^~~~~
vrange.d:62:78: error: no member 'max' for type 'ulong'
	static R full(bool signed){return signed?R(S.min,S.max,true):R(T.min,T.max,false);}
                                                                             ^~~~~
vrange.d:6:7: note: instantiated here
alias ValueRange!32 IntRange;
      ^~~~~~~~~~~~~
vrange.d:7:7: note: instantiated here
alias ValueRange!64 LongRange;
      ^~~~~~~~~~~~~
vrange.d:65:51: error: too many arguments to struct literal (expected zero)
		if(cast(S)min<=cast(S)max) return R(min, max, true);
                                                  ^~~~~~~~~~~~~~~~~
vrange.d:65:51: error: too many arguments to struct literal (expected zero)
		if(cast(S)min<=cast(S)max) return R(min, max, true);
                                                  ^~~~~~~~~~~~~~~~~
vrange.d:79:59: error: undefined identifier 'max'
		if(!signed) return R(.min(min, rhs.min), .max(max, rhs.max), 0);
                                                          ^~~
vrange.d:70:37: error: too many arguments to struct literal (expected zero)
		if(min<=max) return R(min, max, false);
                                    ^~~~~~~~~~~~~~~~~~
vrange.d:70:37: error: too many arguments to struct literal (expected zero)
		if(min<=max) return R(min, max, false);
                                    ^~~~~~~~~~~~~~~~~~
vrange.d:79:59: error: undefined identifier 'max'
		if(!signed) return R(.min(min, rhs.min), .max(max, rhs.max), 0);
                                                          ^~~
vrange.d:75:54: error: invalid argument type 'ValueRange!(64)' to unary -
		if(cast(S)(min^max)>=0) return max<0?-this:this;
                                                     ^~~~~
vrange.d:75:54: error: invalid argument type 'ValueRange!(32)' to unary -
		if(cast(S)(min^max)>=0) return max<0?-this:this;
                                                     ^~~~~
expression.d:60:47: error: cannot cast expression 'dependee' of type 'Dependee' to 'bool'
		bool isIndependent(){ return !dependee; }
                                              ^~~~~~~~
vrange.d:80:27: error: undefined identifier 'min'
		return R(.min(cast(S)min, cast(S)rhs.min), .max(cast(S)max, cast(S)rhs.max), 1);
                          ^~~
vrange.d:80:61: error: undefined identifier 'max'
		return R(.min(cast(S)min, cast(S)rhs.min), .max(cast(S)max, cast(S)rhs.max), 1);
                                                            ^~~
expression.d:65:26: note: instantiated here
auto indepvoid(){ return Dependent!void(Dependee()); }
                         ^~~~~~~~~~~~~~
vrange.d:80:27: error: undefined identifier 'min'
		return R(.min(cast(S)min, cast(S)rhs.min), .max(cast(S)max, cast(S)rhs.max), 1);
                          ^~~
vrange.d:80:61: error: undefined identifier 'max'
		return R(.min(cast(S)min, cast(S)rhs.min), .max(cast(S)max, cast(S)rhs.max), 1);
                                                            ^~~
vrange.d:76:29: error: undefined identifier 'max'
		return R(0,.max(abs(min),max),true);
                            ^~~
vrange.d:76:29: error: undefined identifier 'max'
		return R(0,.max(abs(min),max),true);
                            ^~~
rope_.d:16:30: error: undefined identifier 'size_t'
private size_t roundToPwrTwo(size_t v){ for(size_t t=1;t;t<<=1) v|=v>>t; return v+1; }
                             ^~~~~~
rope_.d:16:9: error: undefined identifier 'size_t'
private size_t roundToPwrTwo(size_t v){ for(size_t t=1;t;t<<=1) v|=v>>t; return v+1; }
        ^~~~~~
vrange.d:76:33: error: undefined identifier 'abs'
		return R(0,.max(abs(min),max),true);
                                ^~~
vrange.d:76:33: error: undefined identifier 'abs'
		return R(0,.max(abs(min),max),true);
                                ^~~
semantic.d:210:35: error: undefined identifier 'string'
template CreateBinderForDependent(string name, string fun=lowerf(name)){
                                  ^~~~~~
semantic.d:210:48: error: undefined identifier 'string'
template CreateBinderForDependent(string name, string fun=lowerf(name)){
                                               ^~~~~~
lexer.d:126:1: error: undefined identifier 'string'
string TokenNames(){
^~~~~~
parser.d:30:9: error: undefined identifier 'string'
private string STCEnum(){
        ^~~~~~
lexer.d:215:9: error: undefined identifier 'string'
	string toString() const{
        ^~~~~~
parser.d:47:1: error: undefined identifier 'string'
string STCtoString(STC stc){
^~~~~~
error.d:18:22: error: undefined identifier 'string'
	void message(string msg){ stderr.write(msg); }
                     ^~~~~~
error.d:16:24: error: undefined identifier 'string'
	void note(lazy string note, Location loc)in{assert(loc.rep);}body{};
                       ^~~~~~
parser.d:163:33: error: undefined identifier 'string'
private template fillParseNames(string base,T...){
                                ^~~~~~
lexer.d:1210:21: error: undefined identifier 'string'
private string isKw(string[] cases){
                    ^~~~~~
lexer.d:308:9: error: undefined identifier 'string'
	string code; // Manually allocated!
        ^~~~~~
parser.d:372:45: error: undefined identifier 'string'
	Expression[] parseAssocArgumentList(string delim, bool nonempty=false, Entry=ArrayAssocExp, T...)() if(T.length%2==0){
                                            ^~~~~~
parser.d:101:28: error: undefined identifier 'string'
private template TTfromStr(string arg){ // turns "a,b,c,..." into TypeTuple(a,b,c,...)
                           ^~~~~~
lexer.d:278:24: error: undefined identifier 'string'
string caseSimpleToken(string prefix="", bool needs = false)pure{
                       ^~~~~~
parser.d:674:23: error: undefined identifier 'string'
	void nonEmpty(string what="statement")(){if(ttype==Tok!";") error("use '{}' for an empty "~what~", not ';'");}
                      ^~~~~~
lexer.d:139:1: error: undefined identifier 'string'
string TokCharsImpl(){
^~~~~~
parser.d:142:43: error: undefined identifier 'string'
private template fillParseNamesImpl(int n,string b,T...){ // val: new TypeTuple, off: that many names have been filled in
                                          ^~~~~~
operators.d:11:23: error: undefined identifier 'string'
enum binaryOps=mixin({string r="[";
                      ^~~~~~
error.d:46:33: error: undefined identifier 'string'
	override void note(lazy string err, Location loc){
                                ^~~~~~
error.d:49:32: error: undefined identifier 'string'
	private void impl(lazy string err, Location loc, bool isNote){
                               ^~~~~~
lexer.d:1215:21: error: undefined identifier 'string'
TokenType isKeyword(string s){
                    ^~~~~~
parser.d:858:30: error: undefined identifier 'string'
	Expression parseType(string expectwhat="type"){
                             ^~~~~~
lexer.d:312:9: error: undefined identifier 'size_t'
	size_t n,m; // start and end index in buffer
        ^~~~~~
error.d:29:34: error: undefined identifier 'string'
	override void error(lazy string err, Location loc){
                                 ^~~~~~
lexer.d:113:1: error: undefined identifier 'string'
string[] keywords = ["abstract", "alias", "align", "asm", "assert", "auto", "body", "bool", "break", "byte", "case", "cast", "catch", "cdouble", "cent", "cfloat", "char", "class", "const", "continue", "creal", "dchar", "debug", "default", "delegate", "delete", "deprecated", "do", "double", "else", "enum", "export", "extern", "false", "final", "finally", "float", "for", "foreach", "foreach_reverse", "function", "goto", "idouble", "if", "ifloat", "immutable", "import", "in", "inout", "int", "interface", "invariant", "ireal", "is", "lazy", "long", "macro", "mixin", "module", "new", "nothrow", "null", "out", "override", "package", "pragma", "private", "protected", "public", "pure", "real", "ref", "return", "scope", "shared", "short", "static", "struct", "super", "switch", "synchronized", "template", "this", "throw", "true", "try", "typedef", "typeid", "typeof", "ubyte", "ucent", "uint", "ulong", "union", "unittest", "ushort", "version", "void", "volatile", "wchar", "while", "with", /*"__FILE__", "__LINE__",*/ "__gshared", "__thread", "__traits"];
^~~~~~
lexer.d:99:1: error: undefined identifier 'string'
string[2][] specialTokens = 
^~~~~~
lexer.d:36:1: error: undefined identifier 'string'
string[2][] simpleTokens = 
^~~~~~
lexer.d:155:17: error: undefined identifier 'string'
		string code;
                ^~~~~~
lexer.d:116:1: error: undefined identifier 'string'
string[2][] tokens = specialTokens ~ complexTokens ~ simpleTokens ~ compoundTokens ~ keywordTokens();
^~~~~~
lexer.d:315:9: error: undefined identifier 'size_t'
	size_t firstAnchor; // first local index that has to remain in buffer
        ^~~~~~
parser.d:411:33: error: undefined identifier 'string'
	Expression[] parseTuple(string delim, bool nonempty=false)(){
                                ^~~~~~
lexer.d:121:19: error: undefined identifier 'string'
	immutable(string[2])[] r;
                  ^~~~~~
parser.d:225:20: error: undefined identifier 'string'
	void error(string err, Location loc=Location.init){
                   ^~~~~~
lexer.d:313:9: error: undefined identifier 'size_t'
	size_t s,e; // global start and end index
        ^~~~~~
parser.d:281:24: error: undefined identifier 'string'
	void expectErr(string what)(){
                       ^~~~~~
lexer.d:157:14: error: undefined identifier 'string'
	this(string name, string code)in{auto c=code;assert(c.length>=4&&!c[$-4]&&!c[$-3]&&!c[$-2]&&!c[$-1]);}body{ // four padding zero bytes required because of UTF{
             ^~~~~~
lexer.d:304:9: error: undefined identifier 'size_t'
	size_t index;
        ^~~~~~
lexer.d:19:1: error: undefined identifier 'string'
string[2][] complexTokens =
^~~~~~
error.d:15:25: error: undefined identifier 'string'
	void error(lazy string err, Location loc)in{assert(loc.line>=1&&loc.rep);}body{nerrors++;}   // in{assert(loc.rep);}body
                        ^~~~~~
parser.d:12:33: error: undefined identifier 'string'
private immutable arrLbp=mixin({string r="[";foreach(t;EnumMembers!TokenType) r~=to!string(isRelationalOp(t)?-2:getLbp(t))~",";return r~"]";}());
                                ^~~~~~
lexer.d:14:14: error: undefined identifier 'string'
template Tok(string type){mixin(TokImpl());}
             ^~~~~~
lexer.d:150:1: error: undefined identifier 'string'
string toString(immutable(Token)[] a){string r;foreach(t;a) r~='['~t.toString()~']'; return r;}
^~~~~~
lexer.d:108:1: error: undefined identifier 'string'
string[2][] compoundTokens =
^~~~~~
lexer.d:154:17: error: undefined identifier 'string'
		string name;
                ^~~~~~
parser.d:359:40: error: undefined identifier 'string'
	Expression[] parseArgumentList(string delim, bool nonempty=false, Entry=AssignExp, T...)(T args){
                                       ^~~~~~
lexer.d:132:1: error: undefined identifier 'string'
string TokImpl(){
^~~~~~
lexer.d:314:9: error: undefined identifier 'size_t'
	size_t numAnchors;  // number of existing anchors for this lexer
        ^~~~~~
parser.d:59:27: error: undefined identifier 'string'
private string getTTCases(string[] s,string[] excl = []){
                          ^~~~~~
error.d:42:34: error: undefined identifier 'string'
	override void error(lazy string err, Location loc){
                                 ^~~~~~
lexer.d:266:16: error: undefined identifier 'string'
template token(string t){enum token=Token(Tok!t);} // unions not yet supported
               ^~~~~~
semantic.d:67:30: error: undefined identifier 'string'
template FinishDeductionProp(string s) if(!s.canFind(",")){
                             ^~~~~~
semantic.d:72:26: error: undefined identifier 'string'
template FinishDeduction(string s) if(!s.canFind(",")){
                         ^~~~~~
semantic.d:78:18: error: undefined identifier 'string'
template PropErr(string s) if(!s.canFind(",")){
                 ^~~~~~
semantic.d:258:18: error: undefined identifier 'string'
template IntChld(string s) if(!s.canFind(",")){
                 ^~~~~~
variant.d:501:9: error: undefined identifier 'size_t'
	size_t toHash()@trusted{
        ^~~~~~
scope_.d:373:25: error: undefined identifier 'string'
	void error(lazy string err, Location loc){handler.error(err,loc);}
                        ^~~~~~
semantic.d:266:20: error: undefined identifier 'string'
template Configure(string s){
                   ^~~~~~
interpret.d:5117:49: error: undefined identifier 'size_t'
Variant voidPointerOrArrayToVariant(void[] mem, size_t size){
                                                ^~~~~~
semantic.d:309:23: error: undefined identifier 'string'
template RevEpoNoHope(string e){
                      ^~~~~~
semantic.d:16:20: error: undefined identifier 'string'
string uniqueIdent(string base){
                   ^~~~~~
variant.d:29:9: error: undefined identifier 'size_t'
	size_t getLength(){
        ^~~~~~
interpret.d:1047:31: error: undefined identifier 'size_t'
	void addContextOffset(size_t amt){contextOffset+=amt;}
                              ^~~~~~
variant.d:650:19: error: undefined identifier 'size_t'
	@property size_t length()in{
                  ^~~~~~
semantic.d:38:32: error: undefined identifier 'string'
template MultiArgument(alias a,string s) if(s.canFind(",")){
                               ^~~~~~
interpret.d:1326:31: error: undefined identifier 'size_t'
	private this(ulong nn,size_t ct, ErrorInfo inf, bool iscc){
                              ^~~~~~
interpret.d:1219:25: error: undefined identifier 'size_t'
			size_t loc;
                        ^~~~~~
scope_.d:374:24: error: undefined identifier 'string'
	void note(lazy string err, Location loc){handler.note(err,loc);}
                       ^~~~~~
interpret.d:1275:22: error: undefined identifier 'size_t'
	private this(size_t off, size_t len, size_t ctlen, ErrorInfo info){
                     ^~~~~~
semantic.d:1065:22: error: undefined identifier 'string'
template BuildOpOver(string opover,string e, string name, string tmargs){
                     ^~~~~~
interpret.d:1319:9: error: undefined identifier 'size_t'
	size_t ctsiz;
        ^~~~~~
semantic.d:180:20: error: undefined identifier 'string'
template ConvertTo(string s) if(s.split(",").length==2){
                   ^~~~~~
module_.d:23:45: error: undefined identifier 'string'
	private static string getActualPath(string path){
                                            ^~~~~~
semantic.d:160:18: error: undefined identifier 'string'
template SemChld(string s){ // perform semantic analysis on child node, propagate all errors
                 ^~~~~~
interpret.d:1656:23: error: undefined identifier 'string'
template CheckPointer(string s) if(s.split(",").length==3){
                      ^~~~~~
interpret.d:1043:17: error: undefined identifier 'size_t'
	private size_t iloc;
                ^~~~~~
interpret.d:32:20: error: undefined identifier 'string'
template IntFCChld(string s){
                   ^~~~~~
semantic.d:279:21: error: undefined identifier 'string'
template RevEpoLkup(string e){
                    ^~~~~~
semantic.d:423:17: error: undefined identifier 'string'
template SetErr(string s) if(!s.canFind(",")){
                ^~~~~~
interpret.d:1270:9: error: undefined identifier 'size_t'
	size_t off, len, ctlen;
        ^~~~~~
semantic.d:23:22: error: undefined identifier 'string'
string[2] splitScope(string s){
                     ^~~~~~
interpret.d:1042:17: error: undefined identifier 'size_t'
	private size_t contextOffset=0;
                ^~~~~~
variant.d:710:25: error: undefined identifier 'size_t'
	Variant opSlice(size_t l, size_t r){
                        ^~~~~~
interpret.d:998:23: error: undefined identifier 'size_t'
	void popFront(size_t num)in{assert(stp+1>=num);}body{
                      ^~~~~~
interpret.d:1041:17: error: undefined identifier 'size_t'
	private size_t stackOffset=0;
                ^~~~~~
module_.d:20:17: error: undefined identifier 'string'
string readCode(string path){ return readCode(File(path)); }
                ^~~~~~
interpret.d:19:26: error: undefined identifier 'string'
template IntFCChldNoEplg(string s){
                         ^~~~~~
semantic.d:7584:34: error: undefined identifier 'string'
mixin template GetTailOperations(string tail, string puthead){
                                 ^~~~~~
semantic.d:165:21: error: undefined identifier 'string'
template SemChldPar(string s){
                    ^~~~~~
interpret.d:1045:29: error: undefined identifier 'size_t'
	void addStackOffset(size_t amt){stackOffset+=amt;}
                            ^~~~~~
interpret.d:977:33: error: undefined identifier 'size_t'
	void[] popRawSliceStack(size_t size){
                                ^~~~~~
semantic.d:114:20: error: undefined identifier 'string'
template PropRetry(string s) if(s.canFind(",")){ alias MultiArgument!(.PropRetry,s) PropRetry; }
                   ^~~~~~
interpret.d:1048:9: error: undefined identifier 'size_t'
	size_t getContextOffset(){return contextOffset;}
        ^~~~~~
interpret.d:1631:1: error: undefined identifier 'string'
string toString(ByteCode byteCode){
^~~~~~
semantic.d:190:24: error: undefined identifier 'string'
template ImplConvertTo(string s) if(s.split(",").length==2){
                       ^~~~~~
interpret.d:1420:70: error: undefined identifier 'size_t'
	override LValueStrategy emitFieldLV(ref ByteCodeBuilder bld, size_t off, size_t len, size_t ctlen, ErrorInfo){
                                                                     ^~~~~~
interpret.d:1182:25: error: undefined identifier 'size_t'
			size_t loc = -1; // no allocation if label used exactly once
                        ^~~~~~
semantic.d:405:18: error: undefined identifier 'string'
template RewEplg(string s) if(!s.canFind(",")){
                 ^~~~~~
semantic.d:116:18: error: undefined identifier 'string'
template SemProp(string s){
                 ^~~~~~
interpret.d:1183:25: error: undefined identifier 'size_t'
			size_t[] locs;
                        ^~~~~~
semantic.d:125:31: error: undefined identifier 'string'
private template _SemChldImpl(string s, string op, string sc){ // TODO: get rid of duplication
                              ^~~~~~
semantic.d:2364:19: error: undefined identifier 'size_t'
	@property size_t length();
                  ^~~~~~
semantic.d:1084:21: error: undefined identifier 'string'
template OpOverload(string name, string tmargs="", string args="", string e="e", string sc="sc"){
                    ^~~~~~
interpret.d:1063:27: error: undefined identifier 'size_t'
	void ignoreResult(size_t size){
                          ^~~~~~
semantic.d:170:21: error: undefined identifier 'string'
template SemChldExp(string s){ // perform semantic analysis on child node, require that it is an expression
                    ^~~~~~
variant.d:329:9: error: undefined identifier 'string'
	string toString(){
        ^~~~~~
semantic.d:200:27: error: undefined identifier 'string'
template ImplConvertToPar(string s) if(s.split(",").length==2){
                          ^~~~~~
interpret.d:1238:25: error: undefined identifier 'size_t'
			size_t loc;
                        ^~~~~~
interpret.d:1263:61: error: undefined identifier 'size_t'
	LValueStrategy emitFieldLV(ref ByteCodeBuilder bld, size_t off, size_t len, size_t ctlen, ErrorInfo info){
                                                            ^~~~~~
interpret.d:834:1: error: undefined identifier 'size_t'
size_t numArgs(Instruction inst){
^~~~~~
variant.d:119:9: error: undefined identifier 'string'
	string toString(){
        ^~~~~~
interpret.d:1046:9: error: undefined identifier 'size_t'
	size_t getStackOffset(){return stackOffset;}
        ^~~~~~
variant.d:33:24: error: undefined identifier 'size_t'
	void setLength(size_t len){
                       ^~~~~~
semantic.d:48:18: error: undefined identifier 'string'
template Rewrite(string s) if(!s.canFind(",")){
                 ^~~~~~
semantic.d:59:20: error: undefined identifier 'string'
template ConstFold(string s) if(!s.canFind(",")){
                   ^~~~~~
scope_.d:377:18: error: undefined identifier 'string'
	override string toString(){return to!string(typeid(this))~"{"~join(map!(to!string)(symtab.values),",")~"}";}
                 ^~~~~~
scope_.d:491:43: error: undefined identifier 'string'
template AggregateParentsInOrderTraversal(string bdy,string raggr="raggr", string parent="parent",bool weak=false){
                                          ^~~~~~
interpret.d:1220:25: error: undefined identifier 'size_t'
			size_t origoff;
                        ^~~~~~
semantic.d:175:24: error: undefined identifier 'string'
template SemChldExpPar(string s){
                       ^~~~~~
semantic.d:89:18: error: undefined identifier 'string'
template PropErr(string s) if(s.canFind(",")){ alias MultiArgument!(.PropErr,s) PropErr; }
                 ^~~~~~
variant.d:109:14: error: undefined identifier 'size_t'
	this(size_t index){
             ^~~~~~
variant.d:688:25: error: undefined identifier 'size_t'
	Variant opIndex(size_t index){
                        ^~~~~~
interpret.d:1272:23: error: undefined identifier 'size_t'
	static opCall(size_t off, size_t len, size_t ctlen, ErrorInfo info){
                      ^~~~~~
semantic.d:109:20: error: undefined identifier 'string'
template PropRetry(string s,bool reset=true) if(!s.canFind(",")){
                   ^~~~~~
semantic.d:91:25: error: undefined identifier 'string'
template PropRetryNoRew(string s,bool reset=true) if(!s.canFind(",")){
                        ^~~~~~
variant.d:628:25: error: undefined identifier 'string'
	Variant opUnary(string op)(){
                        ^~~~~~
interpret.d:942:9: error: undefined identifier 'size_t'
	size_t stp=-1;
        ^~~~~~
interpret.d:954:23: error: undefined identifier 'size_t'
	void allocate(size_t c){
                      ^~~~~~
module_.d:30:26: error: undefined identifier 'string'
	Module getModule(string path, out string err){
                         ^~~~~~
lexer.d:278:1: error: undefined identifier 'string'
string caseSimpleToken(string prefix="", bool needs = false)pure{
^~~~~~
lexer.d:384:45: error: undefined identifier 'size_t'
		if(!numAnchors) firstAnchor=size_t.max;
                                            ^~~~~~
lexer.d:157:27: error: undefined identifier 'string'
	this(string name, string code)in{auto c=code;assert(c.length>=4&&!c[$-4]&&!c[$-3]&&!c[$-2]&&!c[$-1]);}body{ // four padding zero bytes required because of UTF{
                          ^~~~~~
module_.d:23:24: error: undefined identifier 'string'
	private static string getActualPath(string path){
                       ^~~~~~
semantic.d:1065:36: error: undefined identifier 'string'
template BuildOpOver(string opover,string e, string name, string tmargs){
                                   ^~~~~~
semantic.d:1065:46: error: undefined identifier 'string'
template BuildOpOver(string opover,string e, string name, string tmargs){
                                             ^~~~~~
semantic.d:1065:59: error: undefined identifier 'string'
template BuildOpOver(string opover,string e, string name, string tmargs){
                                                          ^~~~~~
semantic.d:1084:34: error: undefined identifier 'string'
template OpOverload(string name, string tmargs="", string args="", string e="e", string sc="sc"){
                                 ^~~~~~
semantic.d:1084:52: error: undefined identifier 'string'
template OpOverload(string name, string tmargs="", string args="", string e="e", string sc="sc"){
                                                   ^~~~~~
semantic.d:1084:68: error: undefined identifier 'string'
template OpOverload(string name, string tmargs="", string args="", string e="e", string sc="sc"){
                                                                   ^~~~~~
semantic.d:1084:82: error: undefined identifier 'string'
template OpOverload(string name, string tmargs="", string args="", string e="e", string sc="sc"){
                                                                                 ^~~~~~
semantic.d:23:1: error: undefined identifier 'string'
string[2] splitScope(string s){
^~~~~~
lexer.d:1210:9: error: undefined identifier 'string'
private string isKw(string[] cases){
        ^~~~~~
interpret.d:1272:35: error: undefined identifier 'size_t'
	static opCall(size_t off, size_t len, size_t ctlen, ErrorInfo info){
                                  ^~~~~~
interpret.d:1272:47: error: undefined identifier 'size_t'
	static opCall(size_t off, size_t len, size_t ctlen, ErrorInfo info){
                                              ^~~~~~
scope_.d:491:54: error: undefined identifier 'string'
template AggregateParentsInOrderTraversal(string bdy,string raggr="raggr", string parent="parent",bool weak=false){
                                                     ^~~~~~
scope_.d:491:76: error: undefined identifier 'string'
template AggregateParentsInOrderTraversal(string bdy,string raggr="raggr", string parent="parent",bool weak=false){
                                                                           ^~~~~~
semantic.d:7584:47: error: undefined identifier 'string'
mixin template GetTailOperations(string tail, string puthead){
                                              ^~~~~~
interpret.d:1420:82: error: undefined identifier 'size_t'
	override LValueStrategy emitFieldLV(ref ByteCodeBuilder bld, size_t off, size_t len, size_t ctlen, ErrorInfo){
                                                                                 ^~~~~~
interpret.d:1420:94: error: undefined identifier 'size_t'
	override LValueStrategy emitFieldLV(ref ByteCodeBuilder bld, size_t off, size_t len, size_t ctlen, ErrorInfo){
                                                                                             ^~~~~~
semantic.d:125:41: error: undefined identifier 'string'
private template _SemChldImpl(string s, string op, string sc){ // TODO: get rid of duplication
                                        ^~~~~~
semantic.d:125:52: error: undefined identifier 'string'
private template _SemChldImpl(string s, string op, string sc){ // TODO: get rid of duplication
                                                   ^~~~~~
variant.d:710:35: error: undefined identifier 'size_t'
	Variant opSlice(size_t l, size_t r){
                                  ^~~~~~
module_.d:30:43: error: undefined identifier 'string'
	Module getModule(string path, out string err){
                                          ^~~~~~
interpret.d:1263:73: error: undefined identifier 'size_t'
	LValueStrategy emitFieldLV(ref ByteCodeBuilder bld, size_t off, size_t len, size_t ctlen, ErrorInfo info){
                                                                        ^~~~~~
interpret.d:1263:85: error: undefined identifier 'size_t'
	LValueStrategy emitFieldLV(ref ByteCodeBuilder bld, size_t off, size_t len, size_t ctlen, ErrorInfo info){
                                                                                    ^~~~~~
parser.d:59:38: error: undefined identifier 'string'
private string getTTCases(string[] s,string[] excl = []){
                                     ^~~~~~
parser.d:59:9: error: undefined identifier 'string'
private string getTTCases(string[] s,string[] excl = []){
        ^~~~~~
semantic.d:16:1: error: undefined identifier 'string'
string uniqueIdent(string base){
^~~~~~
module_.d:20:1: error: undefined identifier 'string'
string readCode(string path){ return readCode(File(path)); }
^~~~~~
interpret.d:1275:34: error: undefined identifier 'size_t'
	private this(size_t off, size_t len, size_t ctlen, ErrorInfo info){
                                 ^~~~~~
interpret.d:1275:46: error: undefined identifier 'size_t'
	private this(size_t off, size_t len, size_t ctlen, ErrorInfo info){
                                             ^~~~~~
interpret.d:1191:55: error: no member 'max' for type 'ulong'
			assert(outer.byteCode.length<=ulong.max); // TODO: add this restriction explicitly
                                                      ^~~~~~~~~
operators.d:151:21: error: undefined identifier 'TokenType'
bool isArithmeticOp(TokenType op){
                    ^~~~~~~~~
operators.d:27:12: error: undefined identifier 'TokenType'
int getLbp(TokenType type) pure{ // operator precedence
           ^~~~~~~~~
expression.d:360:18: error: undefined identifier 'TokenType'
class PostfixExp(TokenType op): Expression{
                 ^~~~~~~~~
type.d:290:24: error: undefined identifier 'TokenType'
template QualifiedType(TokenType op){
                       ^~~~~~~~~
operators.d:25:14: error: undefined identifier 'TokenType'
template rbp(TokenType type){enum rbp=type==Tok!"."?180:lbp!type-(type==Tok!"^^"||lbp!type==30||type==Tok!"?");}
             ^~~~~~~~~
type.d:206:22: error: undefined identifier 'TokenType'
int basicTypeBitSize(TokenType op){
                     ^~~~~~~~~
operators.d:104:21: error: undefined identifier 'TokenType'
bool isRelationalOp(TokenType op){
                    ^~~~~~~~~
lexer.d:214:9: error: undefined identifier 'TokenType'
	TokenType type;
        ^~~~~~~~~
parser.d:288:19: error: undefined identifier 'TokenType'
	bool skip(TokenType type){
                  ^~~~~~~~~
lexer.d:1121:35: error: undefined identifier 'Exception'
private class EscapeSeqException: Exception{string loc; this(string msg,string loc){this.loc=loc;super(msg);}}
                                  ^~~~~~~~~
operators.d:94:24: error: undefined identifier 'TokenType'
bool isIntRelationalOp(TokenType op){
                       ^~~~~~~~~
operators.d:117:18: error: undefined identifier 'TokenType'
bool isLogicalOp(TokenType op){
                 ^~~~~~~~~
parser.d:1105:17: error: undefined identifier 'TokenType'
		TokenType p;
                ^~~~~~~~~
lexer.d:146:26: error: undefined identifier 'TokenType'
string TokenTypeToString(TokenType type){
                         ^~~~~~~~~
parser.d:213:9: error: undefined identifier 'TokenType'
	TokenType ttype;
        ^~~~~~~~~
operators.d:138:16: error: undefined identifier 'TokenType'
bool isShiftOp(TokenType op){
               ^~~~~~~~~
operators.d:81:17: error: undefined identifier 'TokenType'
bool isAssignOp(TokenType op){
                ^~~~~~~~~
parser.d:65:21: error: undefined identifier 'TokenType'
bool isClosingToken(TokenType type){
                    ^~~~~~~~~
interpret.d:618:30: error: undefined identifier 'Exception'
class SilentUnwindException: Exception{this(){super("");}}
                             ^~~~~~~~~
operators.d:23:14: error: undefined identifier 'TokenType'
template lbp(TokenType type){enum lbp=getLbp(type);}
             ^~~~~~~~~
lexer.d:15:19: error: undefined identifier 'TokenType'
template TokChars(TokenType type){mixin(TokCharsImpl());}
                  ^~~~~~~~~
lexer.d:1215:1: error: undefined identifier 'TokenType'
TokenType isKeyword(string s){
^~~~~~~~~
parser.d:253:21: error: undefined identifier 'TokenType'
	void expect(TokenType type){
                    ^~~~~~~~~
operators.d:127:18: error: undefined identifier 'TokenType'
bool isBitwiseOp(TokenType op){
                 ^~~~~~~~~
expression.d:344:16: error: undefined identifier 'TokenType'
class UnaryExp(TokenType op): Expression{
               ^~~~~~~~~
expression.d:459:17: error: undefined identifier 'TokenType'
class BinaryExp(TokenType op): BinaryExpGetParent!op{
                ^~~~~~~~~
parser.d:252:43: error: undefined identifier 'Exception'
	static class ParseErrorException: Exception{this(string s){super(s);}} alias ParseErrorException PEE;
                                          ^~~~~~~~~
expression.d:452:29: error: undefined identifier 'TokenType'
template BinaryExpGetParent(TokenType op){
                            ^~~~~~~~~
type.d:229:24: error: undefined identifier 'TokenType'
bool basicTypeIsSigned(TokenType op){
                       ^~~~~~~~~
scope_.d:315:28: error: type 'const(char)*' is not an expression
	private Identifier[const(char)*] notImported;
                           ^~~~~~~~~~~~
semantic.d:4993:31: error: undefined identifier 'string'
	override void message(string err){
                              ^~~~~~
interpret.d:616:27: error: undefined identifier 'Exception'
class CTFERetryException: Exception{Node node;this(Node n){super("");node = n;}}
                          ^~~~~~~~~
semantic.d:4943:33: error: undefined identifier 'string'
	override void note(lazy string, Location){ /* do nothing */ }
                                ^~~~~~
semantic.d:4986:42: error: undefined identifier 'string'
		override void error(lazy string err, Location loc){
                                         ^~~~~~
error.d:25:25: error: undefined identifier 'getTabSize'
		tabsize=getTabSize();
                        ^~~~~~~~~~
interpret.d:617:24: error: undefined identifier 'Exception'
class UnwindException: Exception{this(){super("");}}
                       ^~~~~~~~~
semantic.d:4990:33: error: undefined identifier 'string'
	override void note(lazy string err, Location loc){
                                ^~~~~~
semantic.d:4942:34: error: undefined identifier 'string'
	override void error(lazy string, Location){ nerrors++; }
                                 ^~~~~~
lexer.d:1121:62: error: undefined identifier 'string'
private class EscapeSeqException: Exception{string loc; this(string msg,string loc){this.loc=loc;super(msg);}}
                                                             ^~~~~~
lexer.d:1121:45: error: undefined identifier 'string'
private class EscapeSeqException: Exception{string loc; this(string msg,string loc){this.loc=loc;super(msg);}}
                                            ^~~~~~
lexer.d:177:25: error: undefined identifier 'swap'
			swap(sources[i], sources[$-1]);
                        ^~~~
semantic.d:4944:31: error: undefined identifier 'string'
	override void message(string msg){ /* do nothing */ }
                              ^~~~~~
parser.d:294:17: error: undefined identifier 'string'
		string name;
                ^~~~~~
variant.d:137:21: error: cannot cast expression 'type' of type 'Type' to 'bool'
		if(!type) return Occupies.vars;		
                    ^~~~
variant.d:306:17: error: type 'VarDecl' is not an expression
	Variant[VarDecl] getDelegateContext()in{
                ^~~~~~~
variant.d:322:20: error: cannot cast expression 'type' of type 'Type' to 'bool'
		if(type){
                   ^~~~
scope_.d:591:17: error: current object 'super' of type 'NestedScope' is not callable
		super(parent);
                ^~~~~~~~~~~~~
scope_.d:469:21: error: cannot cast expression 'dollar' of type 'VarDecl' to 'bool'
		if(!dollar && provider){
                    ^~~~~~
scheduler.d:83:30: error: type 'Node' is not an expression
			Info[Node] info;
                             ^~~~
lexer.d:146:1: error: undefined identifier 'string'
string TokenTypeToString(TokenType type){
^~~~~~
parser.d:423:17: error: unimplemented feature SwitchStm
		switch(ttype){
                ^~~~~~~~~~~~~~
interpret.d:4294:1: error: undefined identifier 'size_t'
size_t getCTSizeof(Type type)out(res){assert(!!res);}body{
^~~~~~
parser.d:252:58: error: undefined identifier 'string'
	static class ParseErrorException: Exception{this(string s){super(s);}} alias ParseErrorException PEE;
                                                         ^~~~~~
parser.d:641:17: error: unimplemented feature TryStm
		try left = nud();catch(PEE err){error("found '"~tok.toString()~"' when expecting expression");nextToken();return new ErrorExp();}
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:1678:9: error: undefined identifier 'size_t'
	size_t ip = 0;
        ^~~~~~
interpret.d:1679:9: error: undefined identifier 'size_t'
	size_t nargs = stack.stp+1;
        ^~~~~~
lexer.d:1121:73: error: undefined identifier 'string'
private class EscapeSeqException: Exception{string loc; this(string msg,string loc){this.loc=loc;super(msg);}}
                                                                        ^~~~~~
scope_.d:637:17: error: current object 'super' of type 'OrderedScope' is not callable
		super(parent);
                ^~~~~~~~~~~~~
interpret.d:5482:16: error: type 'Variant*' is not an expression
	void[][Variant*] sl_aliasing; // preserve aliasing
               ^~~~~~~~
interpret.d:4323:1: error: undefined identifier 'size_t'
size_t getBCSizeof(Type type)in{ assert(!!type); }body{
^~~~~~
interpret.d:5126:9: error: unimplemented feature ForeachRangeStm
	foreach(i;0..arr.length){
        ^~~~~~~~~~~~~~~~~~~~~~~~~
lexer.d:330:29: error: undefined identifier 'size_t'
		firstAnchor=size_t.max;
                            ^~~~~~
parser.d:42:35: error: undefined identifier 'STCref'
enum STCinvariantunderoverride = (STCref|STCsynchronized);
                                  ^~~~~~
parser.d:37:18: error: undefined identifier 'STCref'
enum STCbyref = (STCref|STCout);
                 ^~~~~~
scope_.d:483:55: error: undefined identifier 'aggr'
	override AggregateDecl getAggregate(){ return aggr; }
                                                      ^~~~
scope_.d:605:33: error: undefined identifier 'symtab'
	invariant(){ foreach(d; symtab) assert(d&&typeid(d) !is typeid(DoesNotExistDecl)); }
                                ^~~~~~
variant.d:677:32: error: no member 'int64' for type 'Variant'
			assert(index.int64<arr.length, to!string(index.int64)~">="~to!string(arr.length));
                               ^~~~~~~~~~~
operators.d:12:27: error: undefined identifier 'EnumMembers'
		foreach(x;EnumMembers!TokenType)if(getLbp(x)!=-1&&!canFind([Tok!"++",Tok!"--",Tok!"(",Tok!"["],x)) r~=`"`~TokenTypeToString(x)~`",`;
                          ^~~~~~~~~~~
variant.d:107:60: error: undefined identifier '_field'
	@property field()in{assert(!isIndex);}body{ return _field; }
                                                           ^~~~~~
parser.d:1306:20: error: default parameters not implemented yet
		if(peek().type==Tok!"[") return parseCArrayDecl(stc,type);
                   ^~~~~~
interpret.d:975:17: error: undefined identifier 'memmove'
		memmove(stack.ptr+stp+1-sz, c.ptr, (cast(void[])c).length);
                ^~~~~~~
parser.d:41:36: error: undefined identifier 'STCref'
enum STCmattersforparamoverride = (STCref|STCin|STClazy|STCout|STCscope);
                                   ^~~~~~
scope_.d:146:24: error: undefined identifier 'symtab'
		return symtab.get(ident.ptr, null);
                       ^~~~~~
scope_.d:521:30: error: undefined identifier 'aggr'
	invariant(){ assert(!aggr||!!cast(ReferenceAggregateDecl)aggr); } // aggr is null during initialization
                             ^~~~
scope_.d:484:57: error: undefined identifier 'aggr'
	override AggregateDecl getDeclaration(){ return aggr; }
                                                        ^~~~
interpret.d:1682:25: error: too many arguments to struct literal (expected zero)
	auto tmpstack = Stack(tmp[]);
                        ^~~~~~~~~~~~
parser.d:1084:71: error: no member 'init' for type 'long'
	Declaration parseDeclaration(const ref Location begin,STC stc=STC.init){ // Helper function for parseDeclDef.
                                                                      ^~~~~~~~
variant.d:115:17: error: no member '_field' for type 'FieldAccess'
		this._field = field;
                ^~~~~~~~~~~
scope_.d:523:79: error: current object 'super' of type 'AggregateScope' is not callable
	this(ReferenceAggregateDecl decl) in{assert(decl&&decl.scope_);}body{ super(decl); }
                                                                              ^~~~~~~~~~~
variant.d:698:32: error: no member 'int64' for type 'Variant'
			assert(l.int64<=arr.length && r.int64<=arr.length);
                               ^~~~~~~
scope_.d:522:93: error: undefined identifier 'aggr'
	@property ref ReferenceAggregateDecl raggr(){ return *cast(ReferenceAggregateDecl*)&aggr; }
                                                                                            ^~~~
scope_.d:521:66: error: undefined identifier 'aggr'
	invariant(){ assert(!aggr||!!cast(ReferenceAggregateDecl)aggr); } // aggr is null during initialization
                                                                 ^~~~
scope_.d:141:20: error: cannot cast expression 'r' of type 'Declaration' to 'bool'
		if(r) if(auto ov=r.isOverloadSet()) if(!ov.sealingLookup) return null;
                   ^
scope_.d:253:21: error: cannot cast expression 'd' of type 'Declaration' to 'bool'
		if(!d) insert(New!DoesNotExistDecl(ident));
                    ^
semantic.d:4940:69: error: cannot cast expression 'instance' of type 'GaggingErrorHandler' to 'bool'
	static opCall(){static GaggingErrorHandler instance; return instance?instance:(instance=New!GaggingErrorHandler());}
                                                                    ^~~~~~~~
scope_.d:303:20: error: cannot cast expression 'auto d=symtabLookup(view, ident)' of type 'Declaration' to 'bool'
		if(auto d=symtabLookup(view, ident)){
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:1684:9: error: feature not implemented
	scope(success) if(_displayByteCodeIntp) writeln("stack: ",stack);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
scope_.d:381:26: error: undefined identifier 'symtab'
		r.symtab=symtab.dup;
                         ^~~~~~
scope_.d:353:20: error: cannot cast expression 'auto decl=getDeclaration()' of type 'Declaration' to 'bool'
		if(auto decl=getDeclaration()) return decl;
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~
scope_.d:660:20: error: cannot cast expression 'auto lbll = lookupLabel(l)' of type 'LabeledStm' to 'bool'
		if(auto lbll = lookupLabel(l)) stm.resolveLabel(lbll);
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~
variant.d:647:45: error: undefined identifier 'arr'
		return Variant([FieldAccess(arr.ptr-cnt.ptr)], cnt, type.getElementType().getPointer());
                                            ^~~
variant.d:105:37: error: undefined identifier '_isindex'
	@property isIndex(){ return _isindex; }
                                    ^~~~~~~~
scope_.d:696:17: error: undefined identifier 'brokenOne'
		brokenOne = brk;
                ^~~~~~~~~
scope_.d:699:17: error: undefined identifier 'brokenOne'
		brokenOne = theLoop = loop;
                ^~~~~~~~~
scope_.d:323:28: error: undefined identifier 'imports'
		foreach(im;imports) if(im[0] is sc) return true; // TODO: make more efficient?
                           ^~~~~~~
lexer.d:333:19: error: undefined identifier 'lexTo'
		e=lexTo(buffer);
                  ^~~~~
variant.d:698:41: error: undefined identifier 'arr'
			assert(l.int64<=arr.length && r.int64<=arr.length);
                                        ^~~
parser.d:295:41: error: function call result 'this.tok()' of type 'Token' is not callable
		if(ttype==Tok!"i") name=tok.name;
                                        ^~~
scope_.d:702:17: error: undefined identifier 'brokenOne'
		brokenOne = theSwitch = swstm;
                ^~~~~~~~~
parser.d:225:45: error: no member 'init' for type 'Location'
	void error(string err, Location loc=Location.init){
                                            ^~~~~~~~~~~~~
variant.d:116:17: error: undefined identifier '_isindex'
		_isindex = false;
                ^~~~~~~~
semantic.d:4151:70: error: undefined identifier 'max'
AccessCheck accessCheckCombine(AccessCheck a, AccessCheck b){ return max(a,b); }
                                                                     ^~~
parser.d:1192:30: error: function call result 'this.tok()' of type 'Token' is not callable
		Location loc=tok.loc;
                             ^~~
variant.d:297:24: error: undefined identifier 'fptr'
		return fptr;
                       ^~~~
variant.d:677:44: error: undefined identifier 'arr'
			assert(index.int64<arr.length, to!string(index.int64)~">="~to!string(arr.length));
                                           ^~~
scope_.d:716:24: error: undefined identifier 'brokenOne'
		return brokenOne is stm || parent.isEnclosing(stm);
                       ^~~~~~~~~
variant.d:303:24: error: undefined identifier 'dgfptr'
		return dgfptr;
                       ^~~~~~
module_.d:53:29: error: undefined identifier 'modules'
		foreach(_,m;modules) if(!m || m.sstate == SemState.error) return true;
                            ^~~~~~~
scope_.d:706:24: error: undefined identifier 'brokenOne'
		return brokenOne ? brokenOne : parent.getBreakableStm();
                       ^~~~~~~~~
lexer.d:346:30: error: undefined identifier 'lexTo'
			e+=m=lexTo(buffer[n=1..$]);
                             ^~~~~
module_.d:13:17: error: undefined identifier 'File'
string readCode(File f){
                ^~~~
interpret.d:4321:25: error: no member 'sizeof' for type 'BCPointer'
enum bcPointerBCSize = (BCPointer.sizeof+ulong.sizeof-1)/ulong.sizeof;
                        ^~~~~~~~~~~~~~~~
scope_.d:96:29: error: undefined identifier 'Object'
	private static bool[Object] visited;
                            ^~~~~~
variant.d:106:59: error: undefined identifier '_index'
	@property index()in{assert(isIndex);}body{ return _index; }
                                                          ^~~~~~
variant.d:666:24: error: undefined identifier 'ptr_'
		return ptr_;
                       ^~~~
variant.d:291:24: error: undefined identifier 'cnt'
		return cnt;
                       ^~~
lexer.d:179:25: error: no member 'assumeSafeAppend' for type 'Source[]'
			sources.assumeSafeAppend();
                        ^~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4321:42: error: no member 'sizeof' for type 'ulong'
enum bcPointerBCSize = (BCPointer.sizeof+ulong.sizeof-1)/ulong.sizeof;
                                         ^~~~~~~~~~~~
scope_.d:242:36: error: no member 'imports' for type 'Scope'
			foreach(im;outer.imports) r~=im[0].potentialLookup(view, ident);
                                   ^~~~~~~~~~~~~
variant.d:647:53: error: undefined identifier 'cnt'
		return Variant([FieldAccess(arr.ptr-cnt.ptr)], cnt, type.getElementType().getPointer());
                                                    ^~~
scope_.d:324:17: error: undefined identifier 'imports'
		imports ~= q(sc,kind);
                ^~~~~~~
<mixin@scope_.d:224>:3:17: error: feature not implemented
		scope(exit) visited=null;
                ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:4963:34: error: undefined identifier 'string'
	override void error(lazy string, Location){ /* do nothing */ }
                                 ^~~~~~
module_.d:13:1: error: undefined identifier 'string'
string readCode(File f){
^~~~~~
lexer.d:335:38: error: no member 'max' for type 'int'
		if(src.code.length > int.max) errors~=tokError("no support for sources exceeding 2GB",null),code.length=int.max;
                                     ^~~~~~~
semantic.d:4964:33: error: undefined identifier 'string'
	override void note(lazy string, Location){ /* do nothing */ }
                                ^~~~~~
variant.d:698:55: error: no member 'int64' for type 'Variant'
			assert(l.int64<=arr.length && r.int64<=arr.length);
                                                      ^~~~~~~
variant.d:698:64: error: undefined identifier 'arr'
			assert(l.int64<=arr.length && r.int64<=arr.length);
                                                               ^~~
interpret.d:4321:58: error: no member 'sizeof' for type 'ulong'
enum bcPointerBCSize = (BCPointer.sizeof+ulong.sizeof-1)/ulong.sizeof;
                                                         ^~~~~~~~~~~~
semantic.d:4953:28: error: current object 'super' of type 'NestedScope' is not callable
	this(Scope parent){super(parent);}
                           ^~~~~~~~~~~~~
variant.d:647:64: error: undefined identifier 'cnt'
		return Variant([FieldAccess(arr.ptr-cnt.ptr)], cnt, type.getElementType().getPointer());
                                                               ^~~
<mixin@scope_.d:121>:3:17: error: feature not implemented
		scope(exit) visited=null;
                ^~~~~~~~~~~~~~~~~~~~~~~~~
variant.d:699:32: error: no member 'int64' for type 'Variant'
			assert(l.int64<=r.int64);
                               ^~~~~~~
variant.d:699:41: error: no member 'int64' for type 'Variant'
			assert(l.int64<=r.int64);
                                        ^~~~~~~
variant.d:700:40: error: undefined identifier 'arr'
			return Variant(arr[cast(size_t)l.int64..cast(size_t)r.int64],cnt,type.getElementType().getDynArr()); // aliasing ok?
                                       ^~~
rope_.d:83:17: error: feature declaration.UnionDecl not implemented
		private union{
                ^~~~~~~~~~~~~~
rope_.d:85:25: error: feature declaration.StructDecl not implemented
			struct{
                        ^~~~~~~
rope_.d:175:17: error: feature declaration.UnionDecl not implemented
		union{
                ^~~~~~
rope_.d:177:25: error: feature declaration.StructDecl not implemented
			struct{
                        ^~~~~~~
rope_.d:83:17: error: feature declaration.UnionDecl not implemented
		private union{
                ^~~~~~~~~~~~~~
rope_.d:85:25: error: feature declaration.StructDecl not implemented
			struct{
                        ^~~~~~~
rope_.d:175:17: error: feature declaration.UnionDecl not implemented
		union{
                ^~~~~~
rope_.d:177:25: error: feature declaration.StructDecl not implemented
			struct{
                        ^~~~~~~
rope_.d:218:48: error: undefined identifier 'size_t'
		int opApply(scope int delegate(size_t,T) dg,size_t start=0){
                                               ^~~~~~
scope_.d:272:17: error: undefined identifier 'arbitrary'
		arbitrary ~= mxin;
                ^~~~~~~~~
rope_.d:141:48: error: undefined identifier 'size_t'
		int opApply(scope int delegate(size_t,T) dg){
                                               ^~~~~~
rope_.d:101:27: error: undefined identifier 'size_t'
		@property size_t length(){ return isArray() ? array.length : rope.length; }
                          ^~~~~~
rope_.d:125:27: error: undefined identifier 'size_t'
		T opIndex(size_t i){
                          ^~~~~~
rope_.d:200:27: error: undefined identifier 'size_t'
		T opIndex(size_t i){
                          ^~~~~~
rope_.d:141:48: error: undefined identifier 'size_t'
		int opApply(scope int delegate(size_t,T) dg){
                                               ^~~~~~
rope_.d:125:27: error: undefined identifier 'size_t'
		T opIndex(size_t i){
                          ^~~~~~
rope_.d:205:35: error: undefined identifier 'size_t'
		RopeImpl* opSlice(size_t a, size_t b){
                                  ^~~~~~
rope_.d:101:27: error: undefined identifier 'size_t'
		@property size_t length(){ return isArray() ? array.length : rope.length; }
                          ^~~~~~
rope_.d:114:33: error: undefined identifier 'string'
		Rope opOpAssign(string op:"~")(Rope rhs){
                                ^~~~~~
rope_.d:102:31: error: undefined identifier 'string'
		Rope opBinary(string op:"~")(Rope rhs){
                              ^~~~~~
rope_.d:200:27: error: undefined identifier 'size_t'
		T opIndex(size_t i){
                          ^~~~~~
rope_.d:117:33: error: undefined identifier 'string'
		Rope opOpAssign(string op:"~")(T rhs){
                                ^~~~~~
rope_.d:107:31: error: undefined identifier 'string'
		Rope opBinary(string op:"~")(T rhs){
                              ^~~~~~
interpret.d:5142:34: error: undefined identifier 'q'
			auto tag=q(tt.getUnqual(),vcnt.ptr);
                                 ^
rope_.d:110:36: error: undefined identifier 'string'
		Rope opBinaryRight(string op:"~")(T rhs){
                                   ^~~~~~
parser.d:39:33: error: undefined identifier 'STCprivate'
enum STCnonvirtualprotection = (STCprivate|STCpackage);
                                ^~~~~~~~~~
rope_.d:230:52: error: undefined identifier 'size_t'
		int unsafeByRef(scope int delegate(size_t,ref T) dg,size_t start=0){
                                                   ^~~~~~
parser.d:40:23: error: undefined identifier 'STCfinal'
enum STCnonvirtual = (STCfinal|STCstatic|STCnonvirtualprotection);
                      ^~~~~~~~
rope_.d:205:35: error: undefined identifier 'size_t'
		RopeImpl* opSlice(size_t a, size_t b){
                                  ^~~~~~
rope_.d:120:30: error: undefined identifier 'size_t'
		Rope opSlice(size_t a, size_t b)in{assert(a<=b && b<=length,text(this," ",a," ",b));}body{
                             ^~~~~~
rope_.d:114:33: error: undefined identifier 'string'
		Rope opOpAssign(string op:"~")(Rope rhs){
                                ^~~~~~
interpret.d:5153:18: error: undefined identifier 'q'
	auto tag=q(cast(Type)el.getUnqual().getDynArr(),mem.ptr);
                 ^
rope_.d:117:33: error: undefined identifier 'string'
		Rope opOpAssign(string op:"~")(T rhs){
                                ^~~~~~
rope_.d:183:36: error: undefined identifier 'string'
		RopeImpl* opBinary(string op:"~")(RopeImpl* rhs){
                                   ^~~~~~
rope_.d:65:28: error: incompatible types 'Type' and 'Type' for binary ==
			if(array==[]) return;
                           ^~~~~~~~~
rope_.d:102:31: error: undefined identifier 'string'
		Rope opBinary(string op:"~")(Rope rhs){
                              ^~~~~~
rope_.d:107:31: error: undefined identifier 'string'
		Rope opBinary(string op:"~")(T rhs){
                              ^~~~~~
rope_.d:120:30: error: undefined identifier 'size_t'
		Rope opSlice(size_t a, size_t b)in{assert(a<=b && b<=length,text(this," ",a," ",b));}body{
                             ^~~~~~
rope_.d:120:40: error: undefined identifier 'size_t'
		Rope opSlice(size_t a, size_t b)in{assert(a<=b && b<=length,text(this," ",a," ",b));}body{
                                       ^~~~~~
rope_.d:129:40: error: undefined identifier 'size_t'
		Rope opIndexAssign(T t,size_t i){
                                       ^~~~~~
rope_.d:133:44: error: undefined identifier 'size_t'
		Rope opSliceAssign(Rope r, size_t a, size_t b){
                                           ^~~~~~
rope_.d:133:54: error: undefined identifier 'size_t'
		Rope opSliceAssign(Rope r, size_t a, size_t b){
                                                     ^~~~~~
rope_.d:183:36: error: undefined identifier 'string'
		RopeImpl* opBinary(string op:"~")(RopeImpl* rhs){
                                   ^~~~~~
rope_.d:205:45: error: undefined identifier 'size_t'
		RopeImpl* opSlice(size_t a, size_t b){
                                            ^~~~~~
rope_.d:218:48: error: undefined identifier 'size_t'
		int opApply(scope int delegate(size_t,T) dg,size_t start=0){
                                               ^~~~~~
rope_.d:218:61: error: undefined identifier 'size_t'
		int opApply(scope int delegate(size_t,T) dg,size_t start=0){
                                                            ^~~~~~
rope_.d:230:52: error: undefined identifier 'size_t'
		int unsafeByRef(scope int delegate(size_t,ref T) dg,size_t start=0){
                                                   ^~~~~~
rope_.d:230:69: error: undefined identifier 'size_t'
		int unsafeByRef(scope int delegate(size_t,ref T) dg,size_t start=0){
                                                                    ^~~~~~
rope_.d:65:28: error: incompatible types 'Expression' and 'Expression' for binary ==
			if(array==[]) return;
                           ^~~~~~~~~
rope_.d:110:36: error: undefined identifier 'string'
		Rope opBinaryRight(string op:"~")(T rhs){
                                   ^~~~~~
rope_.d:120:40: error: undefined identifier 'size_t'
		Rope opSlice(size_t a, size_t b)in{assert(a<=b && b<=length,text(this," ",a," ",b));}body{
                                       ^~~~~~
rope_.d:129:40: error: undefined identifier 'size_t'
		Rope opIndexAssign(T t,size_t i){
                                       ^~~~~~
rope_.d:133:44: error: undefined identifier 'size_t'
		Rope opSliceAssign(Rope r, size_t a, size_t b){
                                           ^~~~~~
rope_.d:133:54: error: undefined identifier 'size_t'
		Rope opSliceAssign(Rope r, size_t a, size_t b){
                                                     ^~~~~~
rope_.d:205:45: error: undefined identifier 'size_t'
		RopeImpl* opSlice(size_t a, size_t b){
                                            ^~~~~~
rope_.d:218:61: error: undefined identifier 'size_t'
		int opApply(scope int delegate(size_t,T) dg,size_t start=0){
                                                            ^~~~~~
rope_.d:230:69: error: undefined identifier 'size_t'
		int unsafeByRef(scope int delegate(size_t,ref T) dg,size_t start=0){
                                                                    ^~~~~~
scope_.d:667:54: error: undefined identifier 'fun'
	override FunctionDef getDeclaration(){return fun;}
                                                     ^~~
interpret.d:5483:19: error: undefined identifier 'Q'
	Variant[][Q!(Type,void*)] sl_aliasing_rev; // preserve aliasing on reverse translation
                  ^
scope_.d:666:51: error: undefined identifier 'fun'
	override FunctionDef getFunction(){return fun;}
                                                  ^~~
scope_.d:276:30: error: undefined identifier 'arbitrary'
		foreach(i,x; arbitrary){
                             ^~~~~~~~~
parser.d:12:56: error: undefined identifier 'EnumMembers'
private immutable arrLbp=mixin({string r="[";foreach(t;EnumMembers!TokenType) r~=to!string(isRelationalOp(t)?-2:getLbp(t))~",";return r~"]";}());
                                                       ^~~~~~~~~~~
interpret.d:5480:17: error: undefined identifier 'Q'
	Variant[Q!(Type,void*)] aggr_aliasing_rev; // preserve aliasing on reverse translation
                ^
parser.d:44:23: error: undefined identifier 'STCpackage'
enum STCvisibility = (STCpackage|STCprivate|STCprotected|STCpublic);
                      ^~~~~~~~~~
parser.d:43:28: error: undefined identifier 'STCconst'
enum STCtypeconstructor = (STCconst|STCimmutable|STCshared|STCinout);
                           ^~~~~~~~
parser.d:38:19: error: undefined identifier 'STCenum'
enum STCrvalue = (STCenum|STClazy);
                  ^~~~~~~
scheduler.d:30:75: error: type 'Node' is not an expression
		static if(useBuiltin) private template Map(K, V){ alias V[K] Map; }
                                                                          ^
parser.d:44:34: error: undefined identifier 'STCprivate'
enum STCvisibility = (STCpackage|STCprivate|STCprotected|STCpublic);
                                 ^~~~~~~~~~
parser.d:39:44: error: undefined identifier 'STCpackage'
enum STCnonvirtualprotection = (STCprivate|STCpackage);
                                           ^~~~~~~~~~
scheduler.d:30:75: error: type 'Node' is not an expression
		static if(useBuiltin) private template Map(K, V){ alias V[K] Map; }
                                                                          ^
variant.d:700:56: error: no member 'int64' for type 'Variant'
			return Variant(arr[cast(size_t)l.int64..cast(size_t)r.int64],cnt,type.getElementType().getDynArr()); // aliasing ok?
                                                       ^~~~~~~
scope_.d:638:17: error: no member 'fun' for type 'FunctionScope'
		this.fun=fun;
                ^~~~~~~~
scheduler.d:36:17: note: instantiated here
		Map!(Node,Node[]) awaited;
                ^~~~~~~~~~~~~~~~~
parser.d:208:23: error: function call result 'this.tok()' of type 'Token' is not callable
		ttype=tok.type;
                      ^~~
scheduler.d:38:17: note: instantiated here
		Map!(Node,bool) done;
                ^~~~~~~~~~~~~~~
lexer.d:351:17: error: undefined identifier 'size_t'
		size_t num;
                ^~~~~~
lexer.d:353:29: error: undefined identifier 'lexTo'
			num=lexTo(buffer[n..firstAnchor]);
                            ^~~~~
semantic.d:4704:16: error: undefined identifier 'STCimmutable'
	if(stc&STCimmutable) return InoutRes.immutable_;
               ^~~~~~~~~~~~
rope_.d:92:28: error: function call result 'this.isArray()' of type 'bool' is not callable
			if(isArray()){
                           ^~~~~~~
rope_.d:73:51: error: function call result 'this.isArray()' of type 'bool' is not callable
			@property value(){ return isArray()?tree?tree.value:S.init:rope.value; }
                                                  ^~~~~~~
rope_.d:53:35: error: undefined identifier 'size_t'
			@property size_t length(){ return b-a; }
                                  ^~~~~~
rope_.d:23:35: error: undefined identifier 'size_t'
			@property size_t length(){ return t.length/2; }
                                  ^~~~~~
rope_.d:53:35: error: undefined identifier 'size_t'
			@property size_t length(){ return b-a; }
                                  ^~~~~~
rope_.d:73:51: error: function call result 'this.isArray()' of type 'bool' is not callable
			@property value(){ return isArray()?tree?tree.value:S.init:rope.value; }
                                                  ^~~~~~~
rope_.d:46:25: error: undefined identifier 'size_t'
			size_t a,b;
                        ^~~~~~
rope_.d:24:31: error: undefined identifier 'size_t'
			S get(size_t a, size_t b){
                              ^~~~~~
rope_.d:54:38: error: undefined identifier 'size_t'
			auto opSlice(size_t a, size_t b)in{assert(this.a+b<=this.b);}body{
                                     ^~~~~~
rope_.d:92:28: error: function call result 'this.isArray()' of type 'bool' is not callable
			if(isArray()){
                           ^~~~~~~
lexer.d:335:55: error: undefined identifier 'tokError'
		if(src.code.length > int.max) errors~=tokError("no support for sources exceeding 2GB",null),code.length=int.max;
                                                      ^~~~~~~~
rope_.d:138:28: error: function call result 'this.isArray()' of type 'bool' is not callable
			if(isArray()){foreach(x;array) if(auto r=dg(x)) return r; return 0; }
                           ^~~~~~~
rope_.d:149:44: error: 'Rope!(Type,TemplArgInfo)' is not indexable
		@property T back(){ return this[$-1]; }
                                           ^~~~~~~~~
parser.d:199:15: error: no member 'appender' for type 'ChunkGCAlloc'
	alias Alloc.appender appender;
              ^~~~~~~~~~~~~~
scope_.d:642:29: error: undefined identifier 'lstmsymtab'
		if(auto s = lstmsymtab.get(stm.l.ptr,null)){
                            ^~~~~~~~~~
rope_.d:148:45: error: 'Rope!(Expression,TemplArgInfo)' is not indexable
		@property T front(){ return this[0]; }
                                            ^~~~~~~
scope_.d:651:29: error: undefined identifier 'lstmsymtab'
		if(auto s = lstmsymtab.get(l.ptr,null)) return s;
                            ^~~~~~~~~~
scope_.d:38:16: error: undefined identifier 'STCpublic'
	if(stc&STCpublic) return ImportKind.public_;
               ^~~~~~~~~
rope_.d:138:28: error: function call result 'this.isArray()' of type 'bool' is not callable
			if(isArray()){foreach(x;array) if(auto r=dg(x)) return r; return 0; }
                           ^~~~~~~
rope_.d:54:38: error: undefined identifier 'size_t'
			auto opSlice(size_t a, size_t b)in{assert(this.a+b<=this.b);}body{
                                     ^~~~~~
rope_.d:24:31: error: undefined identifier 'size_t'
			S get(size_t a, size_t b){
                              ^~~~~~
parser.d:43:37: error: undefined identifier 'STCimmutable'
enum STCtypeconstructor = (STCconst|STCimmutable|STCshared|STCinout);
                                    ^~~~~~~~~~~~
scope_.d:324:28: error: undefined identifier 'q'
		imports ~= q(sc,kind);
                           ^
rope_.d:46:25: error: undefined identifier 'size_t'
			size_t a,b;
                        ^~~~~~
rope_.d:23:35: error: undefined identifier 'size_t'
			@property size_t length(){ return t.length/2; }
                                  ^~~~~~
parser.d:198:15: error: no member 'New' for type 'ChunkGCAlloc'
	alias Alloc.New New;
              ^~~~~~~~~
interpret.d:1687:25: error: undefined identifier 'writeln'
			writeln("stack: ",stack);
                        ^~~~~~~
rope_.d:46:25: error: undefined identifier 'size_t'
			size_t a,b;
                        ^~~~~~
rope_.d:47:44: error: undefined identifier 'size_t'
			this(SegTree tree, size_t a, size_t b){
                                           ^~~~~~
rope_.d:47:54: error: undefined identifier 'size_t'
			this(SegTree tree, size_t a, size_t b){
                                                     ^~~~~~
rope_.d:54:48: error: undefined identifier 'size_t'
			auto opSlice(size_t a, size_t b)in{assert(this.a+b<=this.b);}body{
                                               ^~~~~~
expression.d:60:47: error: cannot cast expression 'dependee' of type 'Dependee' to 'bool'
		bool isIndependent(){ return !dependee; }
                                              ^~~~~~~~
scope_.d:160:25: note: instantiated here
	final protected Dependent!Declaration lookupImports(Scope view, Identifier ident, bool onlyMixins, Declaration alt){
                        ^~~~~~~~~~~~~~~~~~~~~
rope_.d:46:25: error: undefined identifier 'size_t'
			size_t a,b;
                        ^~~~~~
rope_.d:47:44: error: undefined identifier 'size_t'
			this(SegTree tree, size_t a, size_t b){
                                           ^~~~~~
rope_.d:47:54: error: undefined identifier 'size_t'
			this(SegTree tree, size_t a, size_t b){
                                                     ^~~~~~
rope_.d:54:48: error: undefined identifier 'size_t'
			auto opSlice(size_t a, size_t b)in{assert(this.a+b<=this.b);}body{
                                               ^~~~~~
rope_.d:24:41: error: undefined identifier 'size_t'
			S get(size_t a, size_t b){
                                        ^~~~~~
semantic.d:4705:21: error: undefined identifier 'STCconst'
	else if(stc&STCconst){
                    ^~~~~~~~
rope_.d:149:44: error: 'Rope!(Expression,TemplArgInfo)' is not indexable
		@property T back(){ return this[$-1]; }
                                           ^~~~~~~~~
semantic.d:2409:29: error: no member 'type' for type 'VarDecl[]'
			if(!x.type) continue;
                            ^~~~~~
scheduler.d:30:75: error: type 'Node' is not an expression
		static if(useBuiltin) private template Map(K, V){ alias V[K] Map; }
                                                                          ^
variant.d:700:77: error: no member 'int64' for type 'Variant'
			return Variant(arr[cast(size_t)l.int64..cast(size_t)r.int64],cnt,type.getElementType().getDynArr()); // aliasing ok?
                                                                            ^~~~~~~
rope_.d:148:45: error: 'Rope!(Type,TemplArgInfo)' is not indexable
		@property T front(){ return this[0]; }
                                            ^~~~~~~
parser.d:657:25: error: unimplemented feature SwitchStm
			switch(ttype){
                        ^~~~~~~~~~~~~~
parser.d:217:23: error: function call result 'this.tok()' of type 'Token' is not callable
		ttype=tok.type;
                      ^~~
parser.d:219:70: error: function call result 'this.tok()' of type 'Token' is not callable
		while(code.errors.length&&code.errors[0].loc.rep.ptr<tok.loc.rep.ptr){
                                                                     ^~~
parser.d:233:23: error: function call result 'this.tok()' of type 'Token' is not callable
		ttype=tok.type;
                      ^~~
parser.d:296:70: error: undefined identifier 'string'
		else{expectErr!"identifier"(); auto e=New!Identifier(string.init); e.loc=tok.loc; return e;}
                                                                     ^~~~~~
parser.d:353:45: note: instantiated here
					if(!skipToUnmatched()||!skip(Tok!")")) return false;
                                            ^~~~~~~~~~~~~~~
parser.d:1151:38: error: function call result 'this.tok()' of type 'Token' is not callable
			Location loc=tok.loc;
                                     ^~~
parser.d:1207:20: error: cannot cast expression 'ret' of type 'Expression' to 'bool'
		if(ret) goto notspecial; // so that I don't have to test for ret multiple times
                   ^~~
parser.d:1494:58: error: function call result 'this.tok()' of type 'Token' is not callable
		if(ttype==Tok!"i"){auto e=New!Identifier(tok.name); e.loc=tok.loc; nextToken(); return e;}
                                                         ^~~
expression.d:60:47: error: cannot cast expression 'dependee' of type 'Dependee' to 'bool'
		bool isIndependent(){ return !dependee; }
                                              ^~~~~~~~
lexer.d:335:121: error: no member 'max' for type 'int'
		if(src.code.length > int.max) errors~=tokError("no support for sources exceeding 2GB",null),code.length=int.max;
                                                                                                                        ^~~~~~~
rope_.d:24:41: error: undefined identifier 'size_t'
			S get(size_t a, size_t b){
                                        ^~~~~~
rope_.d:75:36: error: incompatible types 'Expression' and 'Expression' for binary ==
				if(array==[]) return;
                                   ^~~~~~~~~
rope_.d:75:36: error: incompatible types 'Type' and 'Type' for binary ==
				if(array==[]) return;
                                   ^~~~~~~~~
scope_.d:326:20: error: undefined identifier 'imports'
		if(imports.length==1){
                   ^~~~~~~
scope_.d:327:40: error: undefined identifier 'symtab'
			foreach(_,decl;symtab){
                                       ^~~~~~
parser.d:1391:38: error: function call result 'this.tok()' of type 'Token' is not callable
			Location loc=tok.loc;
                                     ^~~
scheduler.d:34:17: note: instantiated here
		Map!(Node,Scope) asleep;
                ^~~~~~~~~~~~~~~~
parser.d:1494:75: error: function call result 'this.tok()' of type 'Token' is not callable
		if(ttype==Tok!"i"){auto e=New!Identifier(tok.name); e.loc=tok.loc; nextToken(); return e;}
                                                                          ^~~
variant.d:700:86: error: undefined identifier 'cnt'
			return Variant(arr[cast(size_t)l.int64..cast(size_t)r.int64],cnt,type.getElementType().getDynArr()); // aliasing ok?
                                                                                     ^~~
parser.d:246:17: error: function template 'skipToUnmatched' is not callable
		skipToUnmatched();
                ^~~~~~~~~~~~~~~~~
parser.d:248:24: error: function call result 'this.tok()' of type 'Token' is not callable
		auto t=tok;
                       ^~~
semantic.d:2410:36: error: no member 'type' for type 'VarDecl[]'
			if(auto tp=x.type.isTypeTuple()){
                                   ^~~~~~
parser.d:296:90: error: function call result 'this.tok()' of type 'Token' is not callable
		else{expectErr!"identifier"(); auto e=New!Identifier(string.init); e.loc=tok.loc; return e;}
                                                                                         ^~~
parser.d:1607:65: error: default parameters not implemented yet
		while(ttype!=Tok!"}" && ttype!=Tok!"EOF") x.put(parseDeclDef());
                                                                ^~~~~~~~~~~~~~
scope_.d:154:23: note: instantiated here
	/+protected+/ Dependent!IncompleteScope getUnresolvedHereImpl(Scope view, Identifier ident, bool onlyMixins, bool noHope){
                      ^~~~~~~~~~~~~~~~~~~~~~~~~
parser.d:1495:110: error: function call result 'this.tok()' of type 'Token' is not callable
		if(ttype==Tok!"0"||ttype==Tok!"0L"||ttype==Tok!"0U"||ttype==Tok!"0LU"){auto e=New!LiteralExp(tok); e.loc=tok.loc; nextToken(); return e;}
                                                                                                             ^~~
parser.d:1495:122: error: function call result 'this.tok()' of type 'Token' is not callable
		if(ttype==Tok!"0"||ttype==Tok!"0L"||ttype==Tok!"0U"||ttype==Tok!"0LU"){auto e=New!LiteralExp(tok); e.loc=tok.loc; nextToken(); return e;}
                                                                                                                         ^~~
parser.d:299:23: error: function call result 'this.tok()' of type 'Token' is not callable
		e.loc=tok.loc;
                      ^~~
expression.d:412:7: note: instantiated here
alias Rope!(Expression,TemplArgInfo) TemplArgs;
      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
expression.d:413:7: note: instantiated here
alias Rope!(Type,TemplArgInfo) TypeTemplArgs;
      ^~~~~~~~~~~~~~~~~~~~~~~~
rope_.d:90:58: error: undefined identifier 'array'
		private @property bool isArray(){ return array.length || rope is null; }
                                                         ^~~~~
rope_.d:138:49: error: undefined identifier 'array'
			if(isArray()){foreach(x;array) if(auto r=dg(x)) return r; return 0; }
                                                ^~~~~
rope_.d:93:72: error: undefined identifier 'array'
				static if(segtree) return new RopeImpl(array,tree);
                                                                       ^~~~~
rope_.d:226:58: error: undefined identifier 'array'
			if(tag==Tag.Array){foreach(ref x;array) if(auto r=dg(x)) return r; return 0; }
                                                         ^~~~~
rope_.d:214:54: error: undefined identifier 'array'
			if(tag==Tag.Array){foreach(x;array) if(auto r=dg(x)) return r; return 0; }
                                                     ^~~~~
rope_.d:226:58: error: undefined identifier 'array'
			if(tag==Tag.Array){foreach(ref x;array) if(auto r=dg(x)) return r; return 0; }
                                                         ^~~~~
rope_.d:214:54: error: undefined identifier 'array'
			if(tag==Tag.Array){foreach(x;array) if(auto r=dg(x)) return r; return 0; }
                                                     ^~~~~
rope_.d:93:72: error: undefined identifier 'array'
				static if(segtree) return new RopeImpl(array,tree);
                                                                       ^~~~~
rope_.d:138:49: error: undefined identifier 'array'
			if(isArray()){foreach(x;array) if(auto r=dg(x)) return r; return 0; }
                                                ^~~~~
rope_.d:90:58: error: undefined identifier 'array'
		private @property bool isArray(){ return array.length || rope is null; }
                                                         ^~~~~
scope_.d:699:29: error: undefined identifier 'theLoop'
		brokenOne = theLoop = loop;
                            ^~~~~~~
rope_.d:76:33: error: no member 'array' for type 'Rope!(Expression,TemplArgInfo)'
				this.array = array;
                                ^~~~~~~~~~
parser.d:42:42: error: undefined identifier 'STCsynchronized'
enum STCinvariantunderoverride = (STCref|STCsynchronized);
                                         ^~~~~~~~~~~~~~~
scope_.d:709:24: error: undefined identifier 'theLoop'
		return theLoop ? theLoop : parent.getLoopingStm();
                       ^~~~~~~
rope_.d:76:33: error: no member 'array' for type 'Rope!(Type,TemplArgInfo)'
				this.array = array;
                                ^~~~~~~~~~
util.d:261:9: error: undefined identifier 'size_t'
	size_t opHash()const @trusted pure nothrow{ return cast(size_t)cast(void*)x; }
        ^~~~~~
parser.d:41:43: error: undefined identifier 'STCin'
enum STCmattersforparamoverride = (STCref|STCin|STClazy|STCout|STCscope);
                                          ^~~~~
parser.d:37:25: error: undefined identifier 'STCout'
enum STCbyref = (STCref|STCout);
                        ^~~~~~
rope_.d:171:25: error: no member 'array' for type 'RopeImpl'
			this.array=array;
                        ^~~~~~~~~~
rope_.d:82:48: error: function template 'rope' is not callable
		invariant(){ assert(cast(void*)rope is array.ptr); }
                                               ^~~~
rope_.d:82:48: error: function template 'rope' is not callable
		invariant(){ assert(cast(void*)rope is array.ptr); }
                                               ^~~~
rope_.d:66:25: error: no member 'array' for type 'Rope!(Expression,TemplArgInfo)'
			this.array = array;
                        ^~~~~~~~~~
rope_.d:171:25: error: no member 'array' for type 'RopeImpl'
			this.array=array;
                        ^~~~~~~~~~
scope_.d:712:24: error: undefined identifier 'theSwitch'
		return theSwitch ? theSwitch : parent.getSwitchStm();
                       ^~~~~~~~~
scope_.d:702:29: error: undefined identifier 'theSwitch'
		brokenOne = theSwitch = swstm;
                            ^~~~~~~~~
scheduler.d:95:33: error: no member 'assumeSafeAppend' for type 'Node[]'
				stack.assumeSafeAppend();
                                ^~~~~~~~~~~~~~~~~~~~~~
rope_.d:66:25: error: no member 'array' for type 'Rope!(Type,TemplArgInfo)'
			this.array = array;
                        ^~~~~~~~~~
scope_.d:233:43: error: no member 'lookupExactlyHere' for type 'IncompleteScope[]'
				if(auto x=d.lookupExactlyHere(view, ident)) continue;
                                          ^~~~~~~~~~~~~~~~~~~
rope_.d:90:74: error: function template 'rope' is not callable
		private @property bool isArray(){ return array.length || rope is null; }
                                                                         ^~~~
rope_.d:82:56: error: undefined identifier 'array'
		invariant(){ assert(cast(void*)rope is array.ptr); }
                                                       ^~~~~
rope_.d:90:74: error: function template 'rope' is not callable
		private @property bool isArray(){ return array.length || rope is null; }
                                                                         ^~~~
rope_.d:82:56: error: undefined identifier 'array'
		invariant(){ assert(cast(void*)rope is array.ptr); }
                                                       ^~~~~
rope_.d:139:32: error: function template 'rope' is not callable
			return rope.opApply(dg);
                               ^~~~
parser.d:647:23: error: unimplemented feature TryStm
		loop: try left = led(left); catch(PEE err){error(err.msg);}
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
rope_.d:96:32: error: function template 'rope' is not callable
			return rope;
                               ^~~~
rope_.d:96:32: error: function template 'rope' is not callable
			return rope;
                               ^~~~
rope_.d:139:32: error: function template 'rope' is not callable
			return rope.opApply(dg);
                               ^~~~
parser.d:238:17: error: unimplemented feature ForeachRangeStm
		foreach(i;0..x) nextToken();
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
parser.d:239:24: error: function call result 'this.tok()' of type 'Token' is not callable
		auto t=tok;
                       ^~~
lexer.d:357:29: error: undefined identifier 'lexTo'
			num=lexTo(buffer[m..$]);
                            ^~~~~
parser.d:1641:16: error: default parameters not implemented yet
	return Parser(lex(source),handler).parseExpression();
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
parser.d:38:27: error: undefined identifier 'STClazy'
enum STCrvalue = (STCenum|STClazy);
                          ^~~~~~~
parser.d:41:49: error: undefined identifier 'STClazy'
enum STCmattersforparamoverride = (STCref|STCin|STClazy|STCout|STCscope);
                                                ^~~~~~~
semantic.d:4955:58: error: type 'GaggingErrorHandler' is not callable
	override @property ErrorHandler handler(){return GaggingErrorHandler();}
                                                         ^~~~~~~~~~~~~~~~~~~~~
parser.d:44:45: error: undefined identifier 'STCprotected'
enum STCvisibility = (STCpackage|STCprivate|STCprotected|STCpublic);
                                            ^~~~~~~~~~~~
scope_.d:49:23: error: undefined identifier 'format'
		error(format("declaration of '%s' "~suspiciousDeclDesc, decl), decl.loc);
                      ^~~~~~
scope_.d:39:16: error: undefined identifier 'STCprotected'
	if(stc&STCprotected) return ImportKind.protected_;
               ^~~~~~~~~~~~
parser.d:1052:25: error: unimplemented feature SwitchStm
			switch(ttype){
                        ^~~~~~~~~~~~~~
scope_.d:685:21: error: no member 'canDeclareNested' for type 'Scope'
		if(!parent.canDeclareNested(decl)){
                    ^~~~~~~~~~~~~~~~~~~~~~~
parser.d:44:58: error: undefined identifier 'STCpublic'
enum STCvisibility = (STCpackage|STCprivate|STCprotected|STCpublic);
                                                         ^~~~~~~~~
parser.d:41:57: error: undefined identifier 'STCout'
enum STCmattersforparamoverride = (STCref|STCin|STClazy|STCout|STCscope);
                                                        ^~~~~~
parser.d:1107:20: note: instantiated here
		if(skipSTC!toplevelSTC()){
                   ^~~~~~~~~~~~~~~~~~~
lexer.d:358:46: error: undefined identifier 'lexTo'
			if(firstAnchor) num+=lexTo(buffer[0..firstAnchor]);
                                             ^~~~~
parser.d:1108:48: error: default parameters not implemented yet
			if((ttype!=Tok!"i"||(p=peek().type)!=Tok!"=") && p!=Tok!"(" && !skipType()) return false;
                                               ^~~~~~
parser.d:1110:24: error: default parameters not implemented yet
		return peek().type==Tok!"(" && skipFunctionDeclaration() || skipDeclarators();
                       ^~~~~~
rope_.d:227:35: error: undefined identifier 'l'
			if(auto r=l.unsafeByRef(dg)) return r;
                                  ^
rope_.d:227:35: error: undefined identifier 'l'
			if(auto r=l.unsafeByRef(dg)) return r;
                                  ^
rope_.d:215:35: error: undefined identifier 'l'
			if(auto r=l.opApply(dg)) return r;
                                  ^
rope_.d:215:35: error: undefined identifier 'l'
			if(auto r=l.opApply(dg)) return r;
                                  ^
parser.d:40:32: error: undefined identifier 'STCstatic'
enum STCnonvirtual = (STCfinal|STCstatic|STCnonvirtualprotection);
                               ^~~~~~~~~
variant.d:677:56: error: undefined identifier 'to'
			assert(index.int64<arr.length, to!string(index.int64)~">="~to!string(arr.length));
                                                       ^~
interpret.d:1689:25: error: undefined identifier 'write'
			write("inst: ",cast(Instruction)byteCode[ip]);
                        ^~~~~
semantic.d:4706:24: error: undefined identifier 'STCinout'
		if(stc&STCinout) return InoutRes.inoutConst;
                       ^~~~~~~~
rope_.d:166:25: error: no member 'l' for type 'RopeImpl'
			this.l=l, this.r=r;
                        ^~~~~~
variant.d:677:66: error: no member 'int64' for type 'Variant'
			assert(index.int64<arr.length, to!string(index.int64)~">="~to!string(arr.length));
                                                                 ^~~~~~~~~~~
util.d:260:11: error: type 'VarDecl' is not an expression
	V[K] x;
          ^
semantic.d:2411:40: error: no member 'tupleContext' for type 'VarDecl[]'
				assert(x.tupleContext && x.tupleContext.tupleAlias);
                                       ^~~~~~~~~~~~~~
rope_.d:166:25: error: no member 'l' for type 'RopeImpl'
			this.l=l, this.r=r;
                        ^~~~~~
semantic.d:2411:58: error: no member 'tupleContext' for type 'VarDecl[]'
				assert(x.tupleContext && x.tupleContext.tupleAlias);
                                                         ^~~~~~~~~~~~~~
variant.d:677:84: error: undefined identifier 'to'
			assert(index.int64<arr.length, to!string(index.int64)~">="~to!string(arr.length));
                                                                                   ^~
variant.d:677:94: error: undefined identifier 'arr'
			assert(index.int64<arr.length, to!string(index.int64)~">="~to!string(arr.length));
                                                                                             ^~~
semantic.d:4708:22: error: undefined identifier 'STCinout'
	}else if(stc&STCinout) return InoutRes.inout_;
                     ^~~~~~~~
interpret.d:5479:16: note: instantiated here
	void[][AAbyIdentity!(VarDecl,Variant)] aggr_aliasing; // preserve aliasing
               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
variant.d:678:32: error: undefined identifier 'arr'
			return arr[cast(size_t)index.int64];
                               ^~~
scope_.d:655:27: error: undefined identifier '_unresolvedLabels'
		foreach(x;_unresolvedLabels) if(auto r = dg(x)) return r;
                          ^~~~~~~~~~~~~~~~~
parser.d:43:50: error: undefined identifier 'STCshared'
enum STCtypeconstructor = (STCconst|STCimmutable|STCshared|STCinout);
                                                 ^~~~~~~~~
scope_.d:273:17: error: undefined identifier 'arbitrarydecls'
		arbitrarydecls ~= decl;
                ^~~~~~~~~~~~~~
scheduler.d:100:41: error: too many arguments to struct literal (expected zero)
				info[n]=Info(index, index);
                                        ^~~~~~~~~~~~~~~~~~
variant.d:678:48: error: no member 'int64' for type 'Variant'
			return arr[cast(size_t)index.int64];
                                               ^~~~~~~~~~~
rope_.d:81:47: error: function template 'rope' is not callable
		private this(RopeImpl* rope){ this.rope = rope; }
                                              ^~~~~~~~~
scope_.d:234:44: error: no member 'inexistentImpl' for type 'IncompleteScope[]'
				success &= d.inexistentImpl(view, ident);
                                           ^~~~~~~~~~~~~~~~
parser.d:43:60: error: undefined identifier 'STCinout'
enum STCtypeconstructor = (STCconst|STCimmutable|STCshared|STCinout);
                                                           ^~~~~~~~
rope_.d:81:47: error: function template 'rope' is not callable
		private this(RopeImpl* rope){ this.rope = rope; }
                                              ^~~~~~~~~
semantic.d:5019:76: error: current object 'super' of type 'GaggingScope' is not callable
	this(Scope parent){ _handler = New!GaggingRecordingErrorHandler(); super(parent); }
                                                                           ^~~~~~~~~~~~~
parser.d:1401:41: error: default parameters not implemented yet
				auto tt=peek().type;
                                        ^~~~~~
variant.d:679:23: error: unimplemented feature SwitchStm
		}else switch(occupies){
                      ^~~~~~~~~~~~~~~~~
rope_.d:216:32: error: undefined identifier 'r'
			return r.opApply(dg);
                               ^
rope_.d:228:32: error: undefined identifier 'r'
			return r.unsafeByRef(dg);
                               ^
semantic.d:4998:27: error: undefined identifier 'records'
		foreach(r;records)
                          ^~~~~~~
rope_.d:228:32: error: undefined identifier 'r'
			return r.unsafeByRef(dg);
                               ^
rope_.d:216:32: error: undefined identifier 'r'
			return r.opApply(dg);
                               ^
rope_.d:166:35: error: no member 'r' for type 'RopeImpl'
			this.l=l, this.r=r;
                                  ^~~~~~
rope_.d:166:35: error: no member 'r' for type 'RopeImpl'
			this.l=l, this.r=r;
                                  ^~~~~~
parser.d:1019:25: error: unimplemented feature SwitchStm
			switch(ttype){
                        ^~~~~~~~~~~~~~
semantic.d:2412:48: error: no member 'tupleContext' for type 'VarDecl[]'
				r~=a[index..i]~x.tupleContext.vds;
                                               ^~~~~~~~~~~~~~
parser.d:1152:29: note: instantiated here
			stc=parseSTC!(parameterSTC, false)(); // false means no @attributes allowed
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
parser.d:1409:69: error: cannot cast expression 'type' of type 'Expression' to 'bool'
			if(which == WhichTemplateParameter.type && !type && ttype==Tok!"..."){
                                                                    ^~~~
parser.d:1155:46: error: default parameters not implemented yet
				auto ptype = peek().type;
                                             ^~~~~~
parser.d:1163:36: error: default parameters not implemented yet
				if(peek().type==Tok!"["){
                                   ^~~~~~
parser.d:41:64: error: undefined identifier 'STCscope'
enum STCmattersforparamoverride = (STCref|STCin|STClazy|STCout|STCscope);
                                                               ^~~~~~~~
parser.d:1416:95: error: cannot cast expression 'type' of type 'Expression' to 'bool'
					nextToken(); spec=isAlias ? parseTypeOrExpression() : type?parseExpression(rbp!(Tok!",")):parseType();}
                                                                                              ^~~~
parser.d:221:60: error: no member 'str' for type 'Token'
			if(displayExpectErr) handler.error(code.errors[0].str,code.errors[0].loc);
                                                           ^~~~~~~~~~~~~~~~~~
interpret.d:1691:33: error: undefined identifier 'write'
				write(" ",byteCode[ip+1]);
                                ^~~~~
lexer.d:369:29: error: undefined identifier 'lexTo'
			num=lexTo(buffer[n..$]);
                            ^~~~~
parser.d:107:40: error: undefined identifier 'string'
	else static if(is(typeof(T[0]):string)) enum doParseImpl={
                                       ^~~~~~
parser.d:1125:38: error: function call result 'this.tok()' of type 'Token' is not callable
			Location loc=tok.loc;
                                     ^~~
parser.d:649:25: error: unimplemented feature TryStm
			try left = led(left); catch(PEE err){error(err.msg);}
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
parser.d:1417:118: error: cannot cast expression 'type' of type 'Expression' to 'bool'
				if(ttype==Tok!"=") {parseinit: nextToken(); init=isAlias ? parseTypeOrExpression() : type?parseExpression(rbp!(Tok!",")):parseType();}
                                                                                                                     ^~~~
lexer.d:373:29: error: undefined identifier 'lexTo'
			num=lexTo(buffer[0..firstAnchor]);
                            ^~~~~
parser.d:125:39: note: instantiated here
private template doParse(T...){ alias doParseImpl!(true,T) doParse; }
                                      ^~~~~~~~~~~~~~~~~~~~
parser.d:1436:23: note: instantiated here
		mixin(doParse!("_","(",Expression,"e",")"));
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:1693:41: error: undefined identifier 'write'
					write(", ",byteCode[ip+2]);
                                        ^~~~~
rope_.d:167:25: error: no member 'length' for type 'RopeImpl'
			this.length = l.length+r.length;
                        ^~~~~~~~~~~
rope_.d:167:39: error: no member 'length' for type 'RopeImpl'
			this.length = l.length+r.length;
                                      ^~~~~~~~
rope_.d:167:48: error: no member 'length' for type 'RopeImpl'
			this.length = l.length+r.length;
                                               ^~~~~~~~
rope_.d:167:25: error: no member 'length' for type 'RopeImpl'
			this.length = l.length+r.length;
                        ^~~~~~~~~~~
rope_.d:167:39: error: no member 'length' for type 'RopeImpl'
			this.length = l.length+r.length;
                                      ^~~~~~~~
rope_.d:167:48: error: no member 'length' for type 'RopeImpl'
			this.length = l.length+r.length;
                                               ^~~~~~~~
interpret.d:1695:25: error: undefined identifier 'writeln'
			writeln();
                        ^~~~~~~
interpret.d:1698:23: error: unimplemented feature SwitchStm
		swtch:final switch(cast(Instruction)byteCode[ip++]){
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2584:17: error: undefined identifier 'size_t'
		size_t i, j;
                ^~~~~~
parser.d:222:25: error: no member 'popFront' for type 'Token[]'
			code.errors.popFront();
                        ^~~~~~~~~~~~~~~~~~~~
parser.d:1437:24: error: undefined identifier 'e'
		return e;
                       ^
parser.d:1330:43: error: function call result 'this.tok()' of type 'Token' is not callable
			if(isAA){auto loc=tok.loc; mixin(doParse!("_",Type,"e","]")); pfix=New!IndexExp(pfix,[e]); pfix.loc = loc.to(ptok.loc);}
                                          ^~~
parser.d:1330:43: error: function call result 'this.tok()' of type 'Token' is not callable
			if(isAA){auto loc=tok.loc; mixin(doParse!("_",Type,"e","]")); pfix=New!IndexExp(pfix,[e]); pfix.loc = loc.to(ptok.loc);}
                                          ^~~
parser.d:107:40: error: undefined identifier 'string'
	else static if(is(typeof(T[0]):string)) enum doParseImpl={
                                       ^~~~~~
parser.d:125:39: note: instantiated here
private template doParse(T...){ alias doParseImpl!(true,T) doParse; }
                                      ^~~~~~~~~~~~~~~~~~~~
parser.d:1330:58: note: instantiated here
			if(isAA){auto loc=tok.loc; mixin(doParse!("_",Type,"e","]")); pfix=New!IndexExp(pfix,[e]); pfix.loc = loc.to(ptok.loc);}
                                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~
parser.d:1330:111: error: undefined identifier 'e'
			if(isAA){auto loc=tok.loc; mixin(doParse!("_",Type,"e","]")); pfix=New!IndexExp(pfix,[e]); pfix.loc = loc.to(ptok.loc);}
                                                                                                              ^
parser.d:1330:111: error: undefined identifier 'e'
			if(isAA){auto loc=tok.loc; mixin(doParse!("_",Type,"e","]")); pfix=New!IndexExp(pfix,[e]); pfix.loc = loc.to(ptok.loc);}
                                                                                                              ^
interpret.d:1553:17: error: undefined identifier 'string'
		string r;
                ^~~~~~
interpret.d:1587:17: error: undefined identifier 'string'
		string r;
                ^~~~~~
parser.d:1019:25: error: unimplemented feature SwitchStm
			switch(ttype){
                        ^~~~~~~~~~~~~~
parser.d:1127:34: note: instantiated here
			auto stc=parseSTC!toplevelSTC();
                                 ^~~~~~~~~~~~~~~~~~~~
parser.d:1130:85: error: function template 'skipToUnmatched' is not callable
			if(ttype!=Tok!"="){expectErr!"initializer for condition"(); skipToUnmatched(); return New!ErrorExp();}
                                                                                    ^~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
util.d:299:1: error: undefined identifier 'string'
string _dgliteral(T...)(){string r;foreach(t;T) r~=t.stringof ~ " is"~t.stringof~"(){return null;}"; return r;}
^~~~~~
util.d:301:15: note: instantiated here
	mixin(_dgliteral!T()); // DMD bug
              ^~~~~~~~~~~~
expression.d:22:15: note: instantiated here
	mixin DownCastMethods!(
              ^~~~~~~~~~~~~~~~~
interpret.d:2671:35: error: undefined identifier 'writeln'
		import std.stdio; writeln(this);
                                  ^~~~~~~
interpret.d:2672:27: error: undefined identifier 'to'
		assert(0, to!string(typeid(this)));}
                          ^~
interpret.d:2672:37: error: feature TypeidExp not implemented
		assert(0, to!string(typeid(this)));}
                                    ^~~~~~~~~~~~
expression.d:30:15: note: instantiated here
	mixin CTFEInterpret!Node; // TODO: minimize, report
              ^~~~~~~~~~~~~~~~~~
util.d:299:1: error: undefined identifier 'string'
string _dgliteral(T...)(){string r;foreach(t;T) r~=t.stringof ~ " is"~t.stringof~"(){return null;}"; return r;}
^~~~~~
util.d:301:15: note: instantiated here
	mixin(_dgliteral!T()); // DMD bug
              ^~~~~~~~~~~~
statement.d:14:15: note: instantiated here
	mixin DownCastMethods!(
              ^~~~~~~~~~~~~~~~~
<mixin@semantic.d:473>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:473>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:473>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:475>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:475>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
expression.d:100:20: error: cannot cast expression 'sc' of type 'Scope' to 'bool'
		if(sc)foreach(d;deps) d.noHope(sc);
                   ^~
interpret.d:927:18: error: undefined identifier 'string'
	override string kind(){assert(0);}// kind
                 ^~~~~~
interpret.d:930:9: error: undefined identifier 'string'
	string err;
        ^~~~~~
expression.d:103:18: error: undefined identifier 'string'
	override string toString(){
                 ^~~~~~
expression.d:97:18: error: undefined identifier 'string'
	override string kind(){ return "multi dependency";}
                 ^~~~~~
expression.d:83:17: error: type 'Scheduler' is not callable
		Scheduler().add(this, null);
                ^~~~~~~~~~~
expression.d:20:28: error: undefined identifier 'string'
	abstract @property string kind();
                           ^~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
expression.d:84:20: error: cannot cast expression 'sc' of type 'Scope' to 'bool'
		if(sc) foreach(ref d; deps){
                   ^~
expression.d:28:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
expression.d:18:50: error: undefined identifier 'q'
	final @property sourcePriority(){ return q(loc.source.name,loc.line,loc.getColumn(1)); }
                                                 ^
interpret.d:1053:27: error: no member 'sizeof' for type 'Node'
		static if(ErrorInfo.sizeof%ulong.sizeof)
                          ^~~~~~~~~~~~~~~~
interpret.d:1053:44: error: no member 'sizeof' for type 'ulong'
		static if(ErrorInfo.sizeof%ulong.sizeof)
                                           ^~~~~~~~~~~~
interpret.d:1058:87: error: cannot implicitly convert expression 'errtbl' of type 'Node[]' to 'ulong[]'
		auto r = cast(ByteCode)((byteCode~=Instruction.errtbl)~=cast(ByteCode)errtbl);
                                                                                      ^~~~~~
expression.d:100:39: error: no member 'noHope' for type 'Node[]'
		if(sc)foreach(d;deps) d.noHope(sc);
                                      ^~~~~~~~
expression.d:86:25: error: type 'Scheduler' is not callable
			Scheduler().await(this, d, sc);
                        ^~~~~~~~~~~
expression.d:89:49: error: cannot cast expression 'd' of type 'Node[]' to 'Declaration'
			assert(cast(Declaration)d);
                                                ^
expression.d:90:25: error: type 'Scheduler' is not callable
			Scheduler().await(this, d, (cast(Declaration)cast(void*)d).scope_);
                        ^~~~~~~~~~~
expression.d:90:81: error: cannot cast expression 'd' of type 'Node[]' to 'void*'
			Scheduler().await(this, d, (cast(Declaration)cast(void*)d).scope_);
                                                                                ^
<mixin@<mixin@expression.d:94>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
expression.d:110:33: error: too many arguments to struct literal (expected zero)
	if(dep.length>1) return Dependee(new MultiDep(dep, sc));
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
expression.d:111:12: error: incompatible types 'bool' and 'SemState' for binary ==
	if(!dep[0].sstate==SemState.error) dep[0].needRetry = true; // TODO: ok?
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@expression.d:94>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
expression.d:112:20: error: no member 'isDeclaration' for type 'Node'
	assert(sc||dep[0].isDeclaration());
                   ^~~~~~~~~~~~~~~~~~~~
expression.d:113:13: error: cannot cast expression 'sc' of type 'Scope' to 'bool'
	if(!sc) sc = dep[0].isDeclaration().scope_;
            ^~
expression.d:113:22: error: no member 'isDeclaration' for type 'Node'
	if(!sc) sc = dep[0].isDeclaration().scope_;
                     ^~~~~~~~~~~~~~~~~~~~
expression.d:114:18: error: cannot cast expression 'sc' of type 'Scope' to 'bool'
	assert(!!sc);
                 ^~
expression.d:115:16: error: too many arguments to struct literal (expected zero)
	return Dependee(dep[0],sc);
               ^~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'Expression'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'Type'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'Expression'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'Type'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'MultiReturnValueExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'VoidInitializerExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'FieldExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'LiteralExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'CallExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'UFCSCallExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'StructConsExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'ImportBindingsExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'LengthExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'ImplicitCastExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'CastExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'FunctionLiteralExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
expression.d:155:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'TernaryExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'ArrayLiteralExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'TemplateInstanceExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'TemporaryExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'EnumTy'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'BasicType'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
type.d:83:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'QualifiedTy'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'FunctionTy'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'DelegateTy'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'MatcherTy'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'FunctionLiteralExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'StructConsExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'MultiReturnValueExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'VoidInitializerExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'CallExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'TemporaryExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'ImportBindingsExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'TernaryExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'ArrayLiteralExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'FieldExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'UFCSCallExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'LiteralExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'LengthExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'ImplicitCastExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'CastExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'TemplateInstanceExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'EnumTy'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'MatcherTy'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
parser.d:182:21: error: no member 'stringof' for type 'Expression'
	enum SetLoc=T.stringof~q{
                    ^~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'FunctionTy'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'BasicType'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'DelegateTy'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'QualifiedTy'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
expression.d:478:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
expression.d:215:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
expression.d:198:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
semantic.d:5388:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
expression.d:292:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
semantic.d:6187:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
expression.d:394:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
expression.d:424:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
semantic.d:5273:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
semantic.d:2612:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
expression.d:531:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
expression.d:231:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
expression.d:448:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
semantic.d:5348:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
declaration.d:87:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
semantic.d:4718:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
type.d:247:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
type.d:300:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
type.d:164:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
type.d:181:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
semantic.d:1736:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
parser.d:972:23: note: instantiated here
		mixin(SetLoc!Expression);
                      ^~~~~~~~~~~~~~~~~
type.d:353:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
parser.d:441:17: error: unimplemented feature SwitchStm
		switch(ttype){
                ^~~~~~~~~~~~~~
parser.d:973:71: error: undefined identifier 'res'
		if(!recursive&&ttype==Tok!"void"){nextToken(); return res=New!VoidInitializerExp();}
                                                                      ^~~
parser.d:980:40: error: undefined identifier 'res'
				return res=New!ArrayLiteralExp(e);
                                       ^~~
parser.d:989:33: error: unimplemented feature SwitchStm
				switch(ttype){
                                ^~~~~~~~~~~~~~
parser.d:1010:32: error: undefined identifier 'res'
			return res=New!StructLiteralExp(e);
                               ^~~
parser.d:1019:25: error: unimplemented feature SwitchStm
			switch(ttype){
                        ^~~~~~~~~~~~~~
parser.d:1292:81: note: instantiated here
		if(ttype==Tok!"(") params=parseParameterList(vararg,true), stc|=parseSTC!("auto ref"~functionSTC)();
                                                                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(ReturnStm)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(LabeledStm)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(CompoundStm)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(TemplateParameter)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(MixinStm)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(BlockStm)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(CaseStm)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(GotoStm)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(IfStm)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(CaseRangeStm)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(CatchStm)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(ContinueStm)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(EmptyStm)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(BreakStm)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(WithStm)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(ExpressionStm)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(Statement)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(TryStm)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(ForeachRangeStm)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(DefaultStm)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(Expression)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(Statement)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
statement.d:19:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(DefaultStm)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(TryStm)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(CaseRangeStm)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(ForeachRangeStm)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(CaseStm)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(TemplateParameter)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(MixinStm)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(WithStm)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(CatchStm)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
statement.d:153:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
statement.d:264:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
statement.d:124:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
statement.d:146:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
statement.d:201:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
statement.d:228:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
statement.d:215:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
statement.d:139:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
declaration.d:232:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(ErrorStm)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
util.d:299:1: error: undefined identifier 'string'
string _dgliteral(T...)(){string r;foreach(t;T) r~=t.stringof ~ " is"~t.stringof~"(){return null;}"; return r;}
^~~~~~
util.d:301:15: note: instantiated here
	mixin(_dgliteral!T()); // DMD bug
              ^~~~~~~~~~~~
expression.d:127:15: note: instantiated here
	mixin DownCastMethods!(
              ^~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:53:17: error: undefined identifier 'weakenAccessCheck'
		weakenAccessCheck(AccessCheck.memberFuns);
                ^~~~~~~~~~~~~~~~~
visitors.d:17:78: note: instantiated here
	static if(is(typeof(this):Expression)&&!is(typeof(this):Type)) mixin Interpret!(typeof(this));// TODO: minimize and report bug
                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~
expression.d:159:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(IsExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(PtrExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(AssertExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(ABinaryExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(ThisExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(ConditionDeclExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(NewExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(TypeidExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(CurrentExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(ErrorExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(ArrayInitAssocExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(MixinExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(TemplateInstanceExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(CastExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(UFCSCallExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(SliceExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(TemporaryExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(MultiReturnValueExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(LiteralExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(ArrayLiteralExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(StructConsExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(FieldExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(FunctionLiteralExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(CallExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(LengthExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(TernaryExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(VoidInitializerExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
semantic.d:5330:25: error: cannot cast expression 'tmpVarDecl' of type 'VarDecl' to 'bool'
		assert(!tmpVarDecl||tmpVarDecl is decl);
                        ^~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
interpret.d:2684:73: error: undefined identifier 'to'
	LValueStrategy byteCompileLV(ref ByteCodeBuilder bld){assert(0, to!string(typeid(this))~" "~to!string(this));}
                                                                        ^~
interpret.d:2684:83: error: feature TypeidExp not implemented
	LValueStrategy byteCompileLV(ref ByteCodeBuilder bld){assert(0, to!string(typeid(this))~" "~to!string(this));}
                                                                                  ^~~~~~~~~~~~
interpret.d:2684:101: error: undefined identifier 'to'
	LValueStrategy byteCompileLV(ref ByteCodeBuilder bld){assert(0, to!string(typeid(this))~" "~to!string(this));}
                                                                                                    ^~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:17:78: error: no matching template for instantiation 'Interpret!(TemplateInstanceExp)'
	static if(is(typeof(this):Expression)&&!is(typeof(this):Type)) mixin Interpret!(typeof(this));// TODO: minimize and report bug
                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:37:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==MixinExp) || is(T==IsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:42:1: note: candidate template not viable
mixin template Interpret(T) if(is(T:Expression) && NotYetImplemented!T || is(T==ThisExp)||is(T==SuperExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:50:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:138:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:165:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:168:2: note: candidate template not viable
}mixin template Interpret(T) if(!is(T==Type) && is(T:Type)){}
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:170:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:191:2: note: candidate template not viable
}mixin template Interpret(T) if(is(T==Identifier)||is(T==ModuleIdentifier)){}
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:193:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:213:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==BinaryExp!(Tok!"."))){ } // (workaround for DMD bug)
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:215:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==LengthExp)||is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:229:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:256:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:322:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:346:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==IndexExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:391:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:438:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:466:1: note: candidate template not viable
mixin template Interpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:489:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:494:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:495:1: note: candidate template not viable
mixin template Interpret(T) if(is(T _==BinaryExp!S, TokenType S) && !is(T==BinaryExp!(Tok!"."))){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:569:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:582:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==TemporaryExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:585:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==StructConsExp)||is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:597:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:613:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==UFCSCallExp)){ }
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:17:78: error: no matching template for instantiation 'Interpret!(FunctionLiteralExp)'
	static if(is(typeof(this):Expression)&&!is(typeof(this):Type)) mixin Interpret!(typeof(this));// TODO: minimize and report bug
                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:37:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==MixinExp) || is(T==IsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:42:1: note: candidate template not viable
mixin template Interpret(T) if(is(T:Expression) && NotYetImplemented!T || is(T==ThisExp)||is(T==SuperExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:50:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:138:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:165:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:168:2: note: candidate template not viable
}mixin template Interpret(T) if(!is(T==Type) && is(T:Type)){}
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:170:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:191:2: note: candidate template not viable
}mixin template Interpret(T) if(is(T==Identifier)||is(T==ModuleIdentifier)){}
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:193:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:213:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==BinaryExp!(Tok!"."))){ } // (workaround for DMD bug)
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:215:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==LengthExp)||is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:229:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:256:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:322:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:346:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==IndexExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:391:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:438:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:466:1: note: candidate template not viable
mixin template Interpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:489:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:494:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:495:1: note: candidate template not viable
mixin template Interpret(T) if(is(T _==BinaryExp!S, TokenType S) && !is(T==BinaryExp!(Tok!"."))){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:569:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:582:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==TemporaryExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:585:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==StructConsExp)||is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:597:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:613:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==UFCSCallExp)){ }
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
expression.d:232:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
expression.d:425:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
<mixin@semantic.d:7980>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:7980>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:7980>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:7982>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:7982>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
statement.d:206:18: error: undefined identifier 'string'
	override string toString(){return "synchronized"~(e?"("~e.toString()~")":"")~" "~s.toString();}
                 ^~~~~~
statement.d:12:28: error: undefined identifier 'string'
	override @property string kind(){return "statement";}
                           ^~~~~~
statement.d:243:18: error: undefined identifier 'string'
	override string toString(){
                 ^~~~~~
statement.d:233:18: error: undefined identifier 'string'
	override string toString(){return "throw "~e.toString()~";";}
                 ^~~~~~
parser.d:182:21: error: no member 'stringof' for type 'Statement'
	enum SetLoc=T.stringof~q{
                    ^~~~~~~~~~
parser.d:688:23: note: instantiated here
		mixin(SetLoc!Statement);
                      ^~~~~~~~~~~~~~~~
parser.d:691:40: error: default parameters not implemented yet
		if(ttype == Tok!"i" && peek().type == Tok!":"){
                                       ^~~~~~
parser.d:692:49: error: function call result 'this.tok()' of type 'Token' is not callable
			auto l = New!Identifier(tok.name);
                                                ^~~
parser.d:693:31: error: function call result 'this.tok()' of type 'Token' is not callable
			l.loc=tok.loc;
                              ^~~
util.d:305:27: error: no member 'stringof' for type 'LoopingStm'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'LoopingStm'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
visitors.d:17:78: error: no matching template for instantiation 'Interpret!(ThisExp)'
	static if(is(typeof(this):Expression)&&!is(typeof(this):Type)) mixin Interpret!(typeof(this));// TODO: minimize and report bug
                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:37:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==MixinExp) || is(T==IsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:42:1: note: candidate template not viable
mixin template Interpret(T) if(is(T:Expression) && NotYetImplemented!T || is(T==ThisExp)||is(T==SuperExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:50:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:138:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:165:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:168:2: note: candidate template not viable
}mixin template Interpret(T) if(!is(T==Type) && is(T:Type)){}
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:170:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:191:2: note: candidate template not viable
}mixin template Interpret(T) if(is(T==Identifier)||is(T==ModuleIdentifier)){}
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:193:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:213:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==BinaryExp!(Tok!"."))){ } // (workaround for DMD bug)
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:215:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==LengthExp)||is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:229:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:256:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:322:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:346:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==IndexExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:391:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:438:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:466:1: note: candidate template not viable
mixin template Interpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:489:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:494:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:495:1: note: candidate template not viable
mixin template Interpret(T) if(is(T _==BinaryExp!S, TokenType S) && !is(T==BinaryExp!(Tok!"."))){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:569:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:582:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==TemporaryExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:585:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==StructConsExp)||is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:597:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:613:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==UFCSCallExp)){ }
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'BreakableStm'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'BreakableStm'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
visitors.d:17:78: error: no matching template for instantiation 'Interpret!(CurrentExp)'
	static if(is(typeof(this):Expression)&&!is(typeof(this):Type)) mixin Interpret!(typeof(this));// TODO: minimize and report bug
                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:37:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==MixinExp) || is(T==IsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:42:1: note: candidate template not viable
mixin template Interpret(T) if(is(T:Expression) && NotYetImplemented!T || is(T==ThisExp)||is(T==SuperExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:50:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:138:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:165:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:168:2: note: candidate template not viable
}mixin template Interpret(T) if(!is(T==Type) && is(T:Type)){}
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:170:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:191:2: note: candidate template not viable
}mixin template Interpret(T) if(is(T==Identifier)||is(T==ModuleIdentifier)){}
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:193:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:213:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==BinaryExp!(Tok!"."))){ } // (workaround for DMD bug)
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:215:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==LengthExp)||is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:229:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:256:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:322:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:346:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==IndexExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:391:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:438:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:466:1: note: candidate template not viable
mixin template Interpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:489:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:494:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:495:1: note: candidate template not viable
mixin template Interpret(T) if(is(T _==BinaryExp!S, TokenType S) && !is(T==BinaryExp!(Tok!"."))){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:569:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:582:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==TemporaryExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:585:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==StructConsExp)||is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:597:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:613:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==UFCSCallExp)){ }
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
statement.d:80:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
visitors.d:17:78: error: no matching template for instantiation 'Interpret!(VoidInitializerExp)'
	static if(is(typeof(this):Expression)&&!is(typeof(this):Type)) mixin Interpret!(typeof(this));// TODO: minimize and report bug
                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:37:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==MixinExp) || is(T==IsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:42:1: note: candidate template not viable
mixin template Interpret(T) if(is(T:Expression) && NotYetImplemented!T || is(T==ThisExp)||is(T==SuperExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:50:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:138:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:165:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:168:2: note: candidate template not viable
}mixin template Interpret(T) if(!is(T==Type) && is(T:Type)){}
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:170:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:191:2: note: candidate template not viable
}mixin template Interpret(T) if(is(T==Identifier)||is(T==ModuleIdentifier)){}
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:193:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:213:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==BinaryExp!(Tok!"."))){ } // (workaround for DMD bug)
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:215:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==LengthExp)||is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:229:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:256:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:322:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:346:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==IndexExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:391:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:438:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:466:1: note: candidate template not viable
mixin template Interpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:489:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:494:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:495:1: note: candidate template not viable
mixin template Interpret(T) if(is(T _==BinaryExp!S, TokenType S) && !is(T==BinaryExp!(Tok!"."))){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:569:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:582:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==TemporaryExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:585:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==StructConsExp)||is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:597:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:613:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==UFCSCallExp)){ }
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:17:78: error: no matching template for instantiation 'Interpret!(ErrorExp)'
	static if(is(typeof(this):Expression)&&!is(typeof(this):Type)) mixin Interpret!(typeof(this));// TODO: minimize and report bug
                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:37:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==MixinExp) || is(T==IsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:42:1: note: candidate template not viable
mixin template Interpret(T) if(is(T:Expression) && NotYetImplemented!T || is(T==ThisExp)||is(T==SuperExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:50:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:138:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:165:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:168:2: note: candidate template not viable
}mixin template Interpret(T) if(!is(T==Type) && is(T:Type)){}
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:170:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:191:2: note: candidate template not viable
}mixin template Interpret(T) if(is(T==Identifier)||is(T==ModuleIdentifier)){}
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:193:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:213:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==BinaryExp!(Tok!"."))){ } // (workaround for DMD bug)
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:215:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==LengthExp)||is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:229:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:256:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:322:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:346:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==IndexExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:391:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:438:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:466:1: note: candidate template not viable
mixin template Interpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:489:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:494:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:495:1: note: candidate template not viable
mixin template Interpret(T) if(is(T _==BinaryExp!S, TokenType S) && !is(T==BinaryExp!(Tok!"."))){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:569:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:582:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==TemporaryExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:585:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==StructConsExp)||is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:597:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:613:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==UFCSCallExp)){ }
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
statement.d:76:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
visitors.d:17:78: error: no matching template for instantiation 'Interpret!(ArrayInitAssocExp)'
	static if(is(typeof(this):Expression)&&!is(typeof(this):Type)) mixin Interpret!(typeof(this));// TODO: minimize and report bug
                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:37:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==MixinExp) || is(T==IsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:42:1: note: candidate template not viable
mixin template Interpret(T) if(is(T:Expression) && NotYetImplemented!T || is(T==ThisExp)||is(T==SuperExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:50:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:138:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:165:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:168:2: note: candidate template not viable
}mixin template Interpret(T) if(!is(T==Type) && is(T:Type)){}
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:170:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:191:2: note: candidate template not viable
}mixin template Interpret(T) if(is(T==Identifier)||is(T==ModuleIdentifier)){}
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:193:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:213:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==BinaryExp!(Tok!"."))){ } // (workaround for DMD bug)
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:215:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==LengthExp)||is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:229:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:256:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:322:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:346:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==IndexExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:391:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:438:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:466:1: note: candidate template not viable
mixin template Interpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:489:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:494:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:495:1: note: candidate template not viable
mixin template Interpret(T) if(is(T _==BinaryExp!S, TokenType S) && !is(T==BinaryExp!(Tok!"."))){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:569:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:582:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==TemporaryExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:585:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==StructConsExp)||is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:597:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:613:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==UFCSCallExp)){ }
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:17:78: error: no matching template for instantiation 'Interpret!(TypeidExp)'
	static if(is(typeof(this):Expression)&&!is(typeof(this):Type)) mixin Interpret!(typeof(this));// TODO: minimize and report bug
                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:37:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==MixinExp) || is(T==IsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:42:1: note: candidate template not viable
mixin template Interpret(T) if(is(T:Expression) && NotYetImplemented!T || is(T==ThisExp)||is(T==SuperExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:50:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:138:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:165:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:168:2: note: candidate template not viable
}mixin template Interpret(T) if(!is(T==Type) && is(T:Type)){}
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:170:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:191:2: note: candidate template not viable
}mixin template Interpret(T) if(is(T==Identifier)||is(T==ModuleIdentifier)){}
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:193:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:213:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==BinaryExp!(Tok!"."))){ } // (workaround for DMD bug)
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:215:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==LengthExp)||is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:229:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:256:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:322:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:346:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==IndexExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:391:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:438:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:466:1: note: candidate template not viable
mixin template Interpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:489:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:494:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:495:1: note: candidate template not viable
mixin template Interpret(T) if(is(T _==BinaryExp!S, TokenType S) && !is(T==BinaryExp!(Tok!"."))){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:569:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:582:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==TemporaryExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:585:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==StructConsExp)||is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:597:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:613:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==UFCSCallExp)){ }
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:17:78: error: no matching template for instantiation 'Interpret!(MultiReturnValueExp)'
	static if(is(typeof(this):Expression)&&!is(typeof(this):Type)) mixin Interpret!(typeof(this));// TODO: minimize and report bug
                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:37:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==MixinExp) || is(T==IsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:42:1: note: candidate template not viable
mixin template Interpret(T) if(is(T:Expression) && NotYetImplemented!T || is(T==ThisExp)||is(T==SuperExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:50:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:138:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:165:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:168:2: note: candidate template not viable
}mixin template Interpret(T) if(!is(T==Type) && is(T:Type)){}
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:170:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:191:2: note: candidate template not viable
}mixin template Interpret(T) if(is(T==Identifier)||is(T==ModuleIdentifier)){}
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:193:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:213:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==BinaryExp!(Tok!"."))){ } // (workaround for DMD bug)
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:215:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==LengthExp)||is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:229:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:256:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:322:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:346:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==IndexExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:391:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:438:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:466:1: note: candidate template not viable
mixin template Interpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:489:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:494:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:495:1: note: candidate template not viable
mixin template Interpret(T) if(is(T _==BinaryExp!S, TokenType S) && !is(T==BinaryExp!(Tok!"."))){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:569:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:582:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==TemporaryExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:585:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==StructConsExp)||is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:597:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:613:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==UFCSCallExp)){ }
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:17:78: error: no matching template for instantiation 'Interpret!(ConditionDeclExp)'
	static if(is(typeof(this):Expression)&&!is(typeof(this):Type)) mixin Interpret!(typeof(this));// TODO: minimize and report bug
                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:37:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==MixinExp) || is(T==IsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:42:1: note: candidate template not viable
mixin template Interpret(T) if(is(T:Expression) && NotYetImplemented!T || is(T==ThisExp)||is(T==SuperExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:50:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:138:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:165:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:168:2: note: candidate template not viable
}mixin template Interpret(T) if(!is(T==Type) && is(T:Type)){}
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:170:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:191:2: note: candidate template not viable
}mixin template Interpret(T) if(is(T==Identifier)||is(T==ModuleIdentifier)){}
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:193:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:213:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==BinaryExp!(Tok!"."))){ } // (workaround for DMD bug)
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:215:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==LengthExp)||is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:229:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:256:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:322:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:346:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==IndexExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:391:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:438:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:466:1: note: candidate template not viable
mixin template Interpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:489:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:494:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:495:1: note: candidate template not viable
mixin template Interpret(T) if(is(T _==BinaryExp!S, TokenType S) && !is(T==BinaryExp!(Tok!"."))){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:569:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:582:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==TemporaryExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:585:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==StructConsExp)||is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:597:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:613:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==UFCSCallExp)){ }
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
expression.d:532:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
expression.d:513:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
expression.d:169:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
expression.d:564:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
expression.d:547:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
expression.d:263:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
semantic.d:2613:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
semantic.d:5757:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
statement.d:72:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
statement.d:174:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
interpret.d:3512:20: error: cannot cast expression 'e' of type 'Expression' to 'bool'
		if(e) e.byteCompileRet(bld, isRefReturn);
                   ^
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
statement.d:63:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
statement.d:26:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
interpret.d:3397:21: error: undefined identifier 'bclabel'
		if(!bclabel.initialized(bld)) bclabel = bld.getLabel();
                    ^~~~~~~
interpret.d:3402:21: error: undefined identifier 'bclabel'
		if(!bclabel.initialized(bld)) bclabel = bld.getLabel();
                    ^~~~~~~
interpret.d:3397:47: error: undefined identifier 'bclabel'
		if(!bclabel.initialized(bld)) bclabel = bld.getLabel();
                                              ^~~~~~~
interpret.d:3402:47: error: undefined identifier 'bclabel'
		if(!bclabel.initialized(bld)) bclabel = bld.getLabel();
                                              ^~~~~~~
interpret.d:3398:17: error: undefined identifier 'bclabel'
		bclabel.here();
                ^~~~~~~
interpret.d:3403:24: error: undefined identifier 'bclabel'
		return bclabel;
                       ^~~~~~~
expression.d:52:42: error: cannot cast expression 'dependee' of type 'Dependee' to 'bool'
				D b; if(!dependee&&value) b = lb;
                                         ^~~~~~~~
expression.d:53:42: error: cannot cast expression 'dependee' of type 'Dependee' to 'bool'
				return D(dependee?dependee:b.dependee, value && b.value);
                                         ^~~~~~~~
expression.d:56:42: error: cannot cast expression 'dependee' of type 'Dependee' to 'bool'
				D b; if(!dependee&&!value) b = lb;
                                         ^~~~~~~~
expression.d:57:42: error: cannot cast expression 'dependee' of type 'Dependee' to 'bool'
				return D(dependee?dependee:b.dependee, value || b.value);
                                         ^~~~~~~~
expression.d:60:47: error: cannot cast expression 'dependee' of type 'Dependee' to 'bool'
		bool isIndependent(){ return !dependee; }
                                              ^~~~~~~~
expression.d:50:41: error: too many arguments to struct literal (expected zero)
			D not(){ return D(dependee, !value); }
                                        ^~~~~~~~~~~~~~~~~~~
semantic.d:2781:15: note: instantiated here
	final Dependent!bool matches(Expression arg)in{
              ^~~~~~~~~~~~~~
semantic.d:2819:61: error: cannot cast expression 'rtype' of type 'Expression' to 'bool'
	invariant(){assert(sstate != SemState.completed || !rtype || !!type);}
                                                            ^~~~~
<mixin@semantic.d:2760>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
semantic.d:2819:72: error: cannot cast expression 'type' of type 'Type' to 'bool'
	invariant(){assert(sstate != SemState.completed || !rtype || !!type);}
                                                                       ^~~~
<mixin@<mixin@semantic.d:2760>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:2760>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:8206>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@semantic.d:8347>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@semantic.d:8355>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@semantic.d:8363>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@semantic.d:8232>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@semantic.d:8240>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@semantic.d:8224>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
semantic.d:2761:20: error: cannot cast expression 'rtype' of type 'Expression' to 'bool'
		if(rtype){
                   ^~~~~
<mixin@<mixin@semantic.d:8206>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8347>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8355>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8363>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8232>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8240>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8224>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:8224>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:8206>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:8347>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:8355>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:8363>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:8232>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:8240>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8365>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8208>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8349>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8242>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8234>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8357>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8226>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8234>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8357>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8226>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8365>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8208>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8349>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8242>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
statement.d:226:18: error: undefined identifier 'string'
	override string toString(){return "try "~statement.toString()~join(map!(to!string)(catches),"\n")~(finally_?"\nfinally "~finally_.toString():"");}
                 ^~~~~~
statement.d:199:18: error: undefined identifier 'string'
	override string toString(){return "with("~e.toString()~") "~s.toString();}
                 ^~~~~~
statement.d:122:18: error: undefined identifier 'string'
	override string toString(){return "foreach"~(isReverse?"_reverse":"")~"("~var.toString()~";"~left.toString()~".."~right.toString()~") "~bdy.toString();}
                 ^~~~~~
statement.d:137:18: error: undefined identifier 'string'
	override string toString(){return "case "~join(map!(to!string)(e),",")~":"~(s?"\n":"")~indent(join(map!(to!string)(s),"\n"));}
                 ^~~~~~
statement.d:151:18: error: undefined identifier 'string'
	override string toString(){return "default:"~(s?"\n":"")~indent(join(map!(to!string)(s),"\n"));}
                 ^~~~~~
statement.d:144:18: error: undefined identifier 'string'
	override string toString(){return "case "~e1.toString()~": .. case "~e2.toString()~":"~(s?"\n":"")~indent(join(map!(to!string)(s),"\n"));}
                 ^~~~~~
statement.d:213:18: error: undefined identifier 'string'
	override string toString(){return "catch"~(type?"("~type.toString()~(ident?" "~ident.toString():"")~")":" ")~statement.toString();}
                 ^~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
statement.d:40:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
interpret.d:3372:28: error: no member 'sstate' for type 'Statement[]'
			if(x.sstate == SemState.completed){
                           ^~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
statement.d:55:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
interpret.d:3520:17: error: undefined identifier 'theLoop'
		theLoop.emitBCContinueLabel(bld);
                ^~~~~~~
interpret.d:3526:17: error: undefined identifier 'brokenOne'
		brokenOne.emitBCEnd(bld);
                ^~~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
statement.d:167:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
statement.d:160:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
interpret.d:3532:31: error: undefined identifier 'target'
		bld.emitLabel(target.getBCLabel(bld));
                              ^~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
statement.d:194:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:11100>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:11100>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:11100>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
interpret.d:3373:33: error: no member 'byteCompile' for type 'Statement[]'
				x.byteCompile(bld);
                                ^~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(ErrorStm)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
statement.d:32:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
interpret.d:3376:47: error: no member 'sizeof' for type 'Statement[]'
				static assert(x.sizeof <= (void*).sizeof && (void*).sizeof<=ulong.sizeof);
                                              ^~~~~~~~
interpret.d:3376:59: error: no member 'sizeof' for type 'void*'
				static assert(x.sizeof <= (void*).sizeof && (void*).sizeof<=ulong.sizeof);
                                                          ^~~~~~~~~~~~~~
interpret.d:3377:72: error: cannot cast expression 'x' of type 'Statement[]' to 'void*'
				bld.emitConstant(cast(ulong)cast(void*)x);
                                                                       ^
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(DoStm)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(SwitchStm)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(ForeachStm)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(LoopingStm)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(WhileStm)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(BreakableStm)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(ForStm)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(ArrayInitAssocExp)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(TypeidExp)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(ThisExp)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
expression.d:432:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(FunctionLiteralExp)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(TemplateInstanceExp)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(VoidInitializerExp)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(ErrorExp)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
interpret.d:4205:24: error: cannot cast expression 'tmpVarDecl' of type 'VarDecl' to 'bool'
		assert(tmpVarDecl);
                       ^~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:712:54: error: no member 'isAddressExp' for type 'Expression[]'
					if(auto ae = a.isAddressExp())
                                                     ^~~~~~~~~~~~~~
expression.d:60:47: error: cannot cast expression 'dependee' of type 'Dependee' to 'bool'
		bool isIndependent(){ return !dependee; }
                                              ^~~~~~~~
expression.d:60:47: error: cannot cast expression 'dependee' of type 'Dependee' to 'bool'
		bool isIndependent(){ return !dependee; }
                                              ^~~~~~~~
semantic.d:765:15: note: instantiated here
	final Dependent!Type typeMostGeneral(Expression rhs)in{
              ^~~~~~~~~~~~~~
semantic.d:813:15: note: instantiated here
	final Dependent!Expression matchCall(Scope sc, const ref Location loc, Expression[] args)in{
              ^~~~~~~~~~~~~~~~~~~~
semantic.d:835:26: error: undefined identifier 'format'
		sc.error(format("%s '%s' of type '%s' is not callable",kind,toString(),type.toString()),loc);
                         ^~~~~~
semantic.d:656:26: error: undefined identifier 'format'
		sc.error(format("%s '%s' is not an lvalue",kind,toString()),l);
                         ^~~~~~
semantic.d:573:34: error: undefined identifier 'format'
			sc.error(format("%s '%s' is not an expression", f.kind, f.toString()), loc);
                                 ^~~~~~
semantic.d:865:9: error: undefined identifier 'size_t'
	size_t tmplArgToHash(){
        ^~~~~~
<mixin@semantic.d:542>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
interpret.d:75:20: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
		if(rewrite) return;
                   ^~~~~~~
semantic.d:800:38: error: no member 'init' for type 'long'
		auto r = New!CastExp(STC.init,to,this);
                                     ^~~~~~~~
<mixin@<mixin@semantic.d:542>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:553:36: error: no member 'isType' for type 'Expression'
			if(auto ty=me.isType()) return ty;
                                   ^~~~~~~~~
<mixin@semantic.d:542>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:543:37: error: undefined identifier 'to'
		sc.error("feature "~to!string(typeid(this))~" not implemented",loc);
                                    ^~
semantic.d:543:47: error: feature TypeidExp not implemented
		sc.error("feature "~to!string(typeid(this))~" not implemented",loc);
                                              ^~~~~~~~~~~~
interpret.d:81:38: error: undefined identifier 'isArrayLiteralExp'
			if(auto tl = isArrayLiteralExp()){
                                     ^~~~~~~~~~~~~~~~~
interpret.d:82:46: error: no member 'isArrayLiteralExp' for type 'Expression'
				if(auto rl = r.isArrayLiteralExp())
                                             ^~~~~~~~~~~~~~~~~~~
analyze.d:44:19: error: feature expression.TraitsExp not implemented
	static if(__traits(hasMember,T,"manualPropagate") && T.manualPropagate)
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:48:26: error: feature expression.TraitsExp not implemented
	alias TypeTuple!(__traits(getOverloads,T,"perform")) overloads;
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:52:28: error: undefined identifier 'manualPropagate'
		static if(!manualPropagate) node._doAnalyze(&runIt);
                           ^~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:544>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:544>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:61:20: error: undefined identifier 'manualPropagate'
	static if(!manualPropagate) return result;
                   ^~~~~~~~~~~~~~~
semantic.d:720:17: note: instantiated here
		runAnalysis!PropagateErrors(this);
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:67:26: error: undefined identifier 'format'
		sc.error(format("%s '%s' is not interpretable at compile time",kind,loc.rep),loc);
                         ^~~~~~
semantic.d:558:28: error: no member 'isExpTuple' for type 'Expression'
		if(auto et=me.isExpTuple()) if(!et.length) return et.type;
                           ^~~~~~~~~~~~~
<mixin@<mixin@interpret.d:89>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@interpret.d:89>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:559:29: error: no member 'isSymbol' for type 'Expression'
		if(auto sym=me.isSymbol()) if(auto ov=sym.meaning.isCrossScopeOverloadSet()){
                            ^~~~~~~~~~~
semantic.d:563:26: error: undefined identifier 'format'
		sc.error(format("%s '%s' is used as a type",me.kind,me.toString()),loc);
                         ^~~~~~
semantic.d:8339:17: error: undefined identifier 'target'
		target = tgt;
                ^~~~~~
<mixin@semantic.d:8020>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@semantic.d:8296>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@semantic.d:8296>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@semantic.d:8325>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:8020>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8296>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8296>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8325>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:8020>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:8296>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:8296>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:8325>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:8326:17: error: unimplemented feature SwitchStm
		final switch(t) with(WhichGoto){
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8297:21: error: cannot cast expression 'e' of type 'Identifier' to 'bool'
		if(!e){
                    ^
semantic.d:8297:21: error: cannot cast expression 'e' of type 'Identifier' to 'bool'
		if(!e){
                    ^
<mixin@semantic.d:8298>:1:1: error: undefined identifier 'theLoop'
theLoop
^~~~~~~
<mixin@semantic.d:8298>:1:1: error: undefined identifier 'brokenOne'
brokenOne
^~~~~~~~~
<mixin@semantic.d:8298>:1:1: error: undefined identifier 'brokenOne'
brokenOne
^~~~~~~~~
<mixin@semantic.d:8298>:1:1: error: undefined identifier 'theLoop'
theLoop
^~~~~~~
<mixin@semantic.d:8299>:1:1: error: undefined identifier 'brokenOne'
brokenOne
^~~~~~~~~
<mixin@semantic.d:8299>:1:1: error: undefined identifier 'theLoop'
theLoop
^~~~~~~
<mixin@<mixin@semantic.d:8336>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8336>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
statement.d:185:18: error: undefined identifier 'string'
	override string toString(){
                 ^~~~~~
scope_.d:661:22: error: undefined identifier '_unresolvedLabels'
		else _unresolvedLabels~=stm;
                     ^~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8301>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8301>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8301>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8301>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:8304>:1:1: error: undefined identifier 'theLoop'
theLoop
^~~~~~~
semantic.d:8306:37: error: cannot cast expression 'lstm' of type 'LabeledStm' to 'bool'
				if(!lstm) goto Lerr;
                                    ^~~~
<mixin@semantic.d:8304>:1:1: error: undefined identifier 'brokenOne'
brokenOne
^~~~~~~~~
semantic.d:8306:37: error: cannot cast expression 'lstm' of type 'LabeledStm' to 'bool'
				if(!lstm) goto Lerr;
                                    ^~~~
<mixin@<mixin@semantic.d:8023>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8023>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
parser.d:70:50: error: no member 'stringof' for type 'LabeledStm'
private template GetStringOf(T){enum GetStringOf=T.stringof;} // Workaround for strange compiler limitations
                                                 ^~~~~~~~~~
statement.d:53:18: error: undefined identifier 'string'
	override string toString(){return l.toString()~": "~s.toString();}
                 ^~~~~~
parser.d:177:55: note: instantiated here
		return doParse!(a)~"return res=New!("~GetStringOf!(T[0])~")("~getParseNames!a~");";
                                                      ^~~~~~~~~~~~~~~~~~
<mixin@semantic.d:8307>:1:1: error: no member 'isLoopingStm' for type 'Statement'
lstm.s.isLoopingStm
^~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:8307>:1:1: error: no member 'isBreakableStm' for type 'Statement'
lstm.s.isBreakableStm
^~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:8307>:1:1: error: undefined identifier 'brokenOne'
brokenOne
^~~~~~~~~
<mixin@semantic.d:8307>:1:1: error: undefined identifier 'theLoop'
theLoop
^~~~~~~
<mixin@semantic.d:8309>:1:1: error: undefined identifier 'brokenOne'
brokenOne
^~~~~~~~~
<mixin@semantic.d:8309>:1:1: error: undefined identifier 'theLoop'
theLoop
^~~~~~~
<mixin@<mixin@semantic.d:8312>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8312>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8312>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8312>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8314:26: error: undefined identifier 'format'
		sc.error(format("enclosing label '%s' for "~_which~" statement not found",e.toString()),e.loc);
                         ^~~~~~
semantic.d:8314:26: error: undefined identifier 'format'
		sc.error(format("enclosing label '%s' for "~_which~" statement not found",e.toString()),e.loc);
                         ^~~~~~
parser.d:695:31: note: instantiated here
			mixin(rule!(LabeledStm,Existing,"l",Statement));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
parser.d:697:17: error: unimplemented feature SwitchStm
		switch(ttype){
                ^~~~~~~~~~~~~~
statement.d:23:18: error: undefined identifier 'string'
	override string toString(){return ";";}
                 ^~~~~~
<mixin@statement.d:24>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@statement.d:24>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@statement.d:24>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@<mixin@statement.d:24>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@statement.d:24>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
statement.d:30:18: error: undefined identifier 'string'
	override string toString(){return "__error;";}
                 ^~~~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(Declaration)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(SwitchStm)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(ForeachStm)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
statement.d:132:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
statement.d:114:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
statement.d:77:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
statement.d:81:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
<mixin@semantic.d:4131>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@semantic.d:4113>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@semantic.d:6249>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:4131>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:4113>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:4131>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:4113>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:4123>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:6249>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:6249>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:4123>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:4123>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:6250:41: error: no member 'init' for type 'long'
		auto dg=New!FunctionDef(STC.init,fty,New!Identifier(uniqueIdent("__dgliteral")),cast(BlockStm)null,cast(BlockStm)null,cast(Identifier)null,bdy, which==Kind.none);
                                        ^~~~~~~~
<mixin@<mixin@semantic.d:4133>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:4133>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
expression.d:545:18: error: undefined identifier 'string'
	override string toString(){return key.toString()~":"~value.toString();}
                 ^~~~~~
<mixin@<mixin@semantic.d:4116>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:4116>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
expression.d:511:18: error: undefined identifier 'string'
	override string toString(){return "typeid("~e.toString()~")";}
                 ^~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
expression.d:509:39: error: undefined identifier 'text'
	invariant(){assert(e !is null,text(loc));}
                                      ^~~~
semantic.d:6256:46: error: cannot cast expression 'decl' of type 'Declaration' to 'bool'
		if(which==Kind.function_ || !decl) dg.stc |= STCstatic;
                                             ^~~~
semantic.d:6256:62: error: undefined identifier 'STCstatic'
		if(which==Kind.function_ || !decl) dg.stc |= STCstatic;
                                                             ^~~~~~~~~
util.d:299:1: error: undefined identifier 'string'
string _dgliteral(T...)(){string r;foreach(t;T) r~=t.stringof ~ " is"~t.stringof~"(){return null;}"; return r;}
^~~~~~
util.d:305:27: error: no member 'stringof' for type 'AssignExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'AssignExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:301:15: note: instantiated here
	mixin(_dgliteral!T()); // DMD bug
              ^~~~~~~~~~~~
expression.d:436:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
declaration.d:28:15: note: instantiated here
	mixin DownCastMethods!(
              ^~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(Module)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
semantic.d:527:25: error: unimplemented feature SwitchStm
			final switch(inContext) with(InContext){
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
expression.d:167:18: error: undefined identifier 'string'
	override string toString(){return _brk("__error");}
                 ^~~~~~
module_.d:112:15: note: instantiated here
	mixin DeepDup!Module;
              ^~~~~~~~~~~~~~
util.d:359:21: error: initializer required for 'ref' declaration
	foreach(ref x; args)
                    ^
util.d:360:27: error: undefined identifier 'x'
		if(arg == x) return true;
                          ^
semantic.d:521:47: note: instantiated here
			assert(this.inContext.among(InContext.none, inContext), text(this," ",this.inContext," ",inContext));
                                              ^~~~~
semantic.d:521:81: error: undefined identifier 'text'
			assert(this.inContext.among(InContext.none, inContext), text(this," ",this.inContext," ",inContext));
                                                                                ^~~~
semantic.d:3154:15: note: instantiated here
	mixin ContextSensitive;
              ^~~~~~~~~~~~~~~~
semantic.d:3278:21: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
		if(!rewrite) return;
                    ^~~~~~~
semantic.d:3279:42: error: cannot cast expression 'rewrite' of type 'Node' to 'Expression'
		assert(!!cast(Expression)rewrite);
                                         ^~~~~~~
semantic.d:3280:48: error: cannot cast expression 'rewrite' of type 'Node' to 'void*'
		if((cast(Expression)cast(void*)rewrite).isType()) return;
                                               ^~~~~~~
semantic.d:3207:21: error: undefined identifier 'inst'
		if(!inst.isTemplateInstanceDecl
                    ^~~~
semantic.d:3198:21: error: undefined identifier 'inst'
		if(!inst){
                    ^~~~
semantic.d:3199:25: error: undefined identifier 'inst'
			inst = sym.meaning.matchInstantiation(sc, loc, false, isMixin, this, TemplArgsWithTypes(analyzedArgs,argTypes));
                        ^~~~
semantic.d:3208:59: error: undefined identifier 'inst'
		|| !(cast(TemplateInstanceDecl)cast(void*)inst).completedMatching){
                                                          ^~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
semantic.d:3316:20: error: undefined identifier 'res'
		if(res){
                   ^~~
semantic.d:3317:43: error: undefined identifier 'res'
			auto unresolved = res.getMemberScope();
                                          ^~~
expression.d:422:18: error: undefined identifier 'string'
	override string toString(){return _brk(e.toString()~"!"~(args.length!=1?"(":"")~join(map!(to!string)(args),",")~(args.length!=1?")":""));}
                 ^~~~~~
semantic.d:3318:66: error: undefined identifier 'eponymous'
			if(unresolved&&!unresolved.inexistent(sc,eponymous))
                                                                 ^~~~~~~~~
semantic.d:3252:20: error: undefined identifier 'eponymous'
		if(eponymous){
                   ^~~~~~~~~
semantic.d:3253:29: error: undefined identifier 'eponymous'
			if(!eponymous.meaning && eponymous.sstate != SemState.failed
                            ^~~~~~~~~
semantic.d:3253:50: error: undefined identifier 'eponymous'
			if(!eponymous.meaning && eponymous.sstate != SemState.failed
                                                 ^~~~~~~~~
semantic.d:3326:17: error: undefined identifier 'matchOnly'
		matchOnly = true;
                ^~~~~~~~~
semantic.d:3254:31: error: undefined identifier 'eponymous'
			   && eponymous.sstate != SemState.error){
                              ^~~~~~~~~
semantic.d:3255:33: error: undefined identifier 'eponymous'
				eponymous.recursiveLookup = false;
                                ^~~~~~~~~
<mixin@semantic.d:3086>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:3086>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
semantic.d:3213:52: error: undefined identifier 'inst'
		assert(!!cast(TemplateInstanceDecl)inst, text(typeid(this.inst)));
                                                   ^~~~
semantic.d:3213:58: error: undefined identifier 'text'
		assert(!!cast(TemplateInstanceDecl)inst, text(typeid(this.inst)));
                                                         ^~~~
semantic.d:3213:70: error: no member 'inst' for type 'TemplateInstanceExp'
		assert(!!cast(TemplateInstanceDecl)inst, text(typeid(this.inst)));
                                                                     ^~~~~~~~~
semantic.d:3214:66: error: undefined identifier 'inst'
		auto inst = cast(TemplateInstanceDecl)cast(void*)inst; // update static type of inst
                                                                 ^~~~
<mixin@semantic.d:3086>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:3088:22: error: undefined identifier 'res'
		if(!!res){
                     ^~~
semantic.d:3256:39: error: undefined identifier 'Lookup'
				mixin(Lookup!q{_; eponymous, sc, res.getMemberScope()});
                                      ^~~~~~
semantic.d:3258:36: error: undefined identifier 'eponymous'
			if(auto nr=eponymous.needRetry) { needRetry = nr; return; }
                                   ^~~~~~~~~
<mixin@<mixin@semantic.d:3319>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:3319>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:3261:21: error: undefined identifier 'eponymous'
		if(!eponymous||eponymous.sstate == SemState.failed){
                    ^~~~~~~~~
semantic.d:3261:32: error: undefined identifier 'eponymous'
		if(!eponymous||eponymous.sstate == SemState.failed){
                               ^~~~~~~~~
semantic.d:3263:34: error: undefined identifier 'res'
			auto r = res;
                                 ^~~
<mixin@<mixin@semantic.d:3220>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:3220>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:3226:77: error: undefined identifier 'matchOnly'
		if(!inst.finishedInstantiation()) inst.finishInstantiation(!matchOnly); // start analysis?
                                                                            ^~~~~~~~~
semantic.d:3268:56: error: undefined identifier 'res'
		Expression r=New!(BinaryExp!(Tok!"."))(res, eponymous);
                                                       ^~~
semantic.d:3268:61: error: undefined identifier 'eponymous'
		Expression r=New!(BinaryExp!(Tok!"."))(res, eponymous);
                                                            ^~~~~~~~~
semantic.d:3096:25: error: no member 'willPassToTemplate' for type 'Expression[]'
			x.willPassToTemplate();
                        ^~~~~~~~~~~~~~~~~~~~
semantic.d:3097:28: error: no member 'sstate' for type 'Expression[]'
			if(x.sstate != SemState.completed && !x.isFunctionLiteralExp()){
                           ^~~~~~~~
semantic.d:3097:63: error: no member 'isFunctionLiteralExp' for type 'Expression[]'
			if(x.sstate != SemState.completed && !x.isFunctionLiteralExp()){
                                                              ^~~~~~~~~~~~~~~~~~~~~~
semantic.d:3098:33: error: no member 'prepareInterpret' for type 'Expression[]'
				x.prepareInterpret();
                                ^~~~~~~~~~~~~~~~~~
semantic.d:3099:33: error: no member 'weakenAccessCheck' for type 'Expression[]'
				x.weakenAccessCheck(AccessCheck.none);
                                ^~~~~~~~~~~~~~~~~~~
semantic.d:3105:27: error: no member 'isUFCSCallExp' for type 'Expression'
		if(auto r=e.isUFCSCallExp()){
                          ^~~~~~~~~~~~~~~
semantic.d:3117:28: error: no member 'isSymbol' for type 'Expression'
		auto sym = e.isSymbol();
                           ^~~~~~~~~~
semantic.d:3120:39: error: no member 'isFieldExp' for type 'Expression'
			if(auto fld = e.isFieldExp()){
                                      ^~~~~~~~~~~~
semantic.d:3126:42: error: undefined identifier 'format'
				sc.error(format("can only instantiate templates, not %s%ss",e.kind,e.kind[$-1]=='s'?"e":""),loc);
                                         ^~~~~~
expression.d:125:28: error: undefined identifier 'string'
	override @property string kind(){return isConstant?"constant":"expression";}
                           ^~~~~~
<mixin@<mixin@semantic.d:3127>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:3127>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
expression.d:122:18: error: undefined identifier 'string'
	override string toString(){return _brk("{}()");}
                 ^~~~~~
expression.d:123:31: error: undefined identifier 'string'
	protected string _brk(string s){return std.array.replicate("(",brackets)~s~std.array.replicate(")",brackets); return s;}
                              ^~~~~~
expression.d:123:19: error: undefined identifier 'string'
	protected string _brk(string s){return std.array.replicate("(",brackets)~s~std.array.replicate(")",brackets); return s;}
                  ^~~~~~
<mixin@<mixin@semantic.d:565>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:565>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:575>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:575>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:578:28: error: no member 'isType' for type 'Expression'
			if(f.isType()) return errorOut();
                           ^~~~~~~~
semantic.d:579:41: error: no member 'isTuple' for type 'Expression'
			else if(auto et=f.isTuple()){
                                        ^~~~~~~~~
semantic.d:3281:68: note: instantiated here
		auto tmp = rewrite.sstate!=SemState.completed?null.independent!Expression:
                                                                   ^~~~~~~~~~~~~~~~~~~~~~
semantic.d:3282:53: error: cannot cast expression 'rewrite' of type 'Node' to 'void*'
			(cast(Expression)cast(void*)rewrite).matchCall(sc, loc, iftiArgs);
                                                    ^~~~~~~
semantic.d:3303:42: error: undefined identifier 'string'
				override string toString(){ return exp.toString(); }
                                         ^~~~~~
<mixin@semantic.d:3291>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:3291>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:3291>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:3295:44: error: no member 'isType' for type 'Expression'
					if(exp.isType()) r=exp;
                                           ^~~~~~~~~~
semantic.d:3297:55: error: undefined identifier 'MatchCall'
						mixin(MatchCall!q{r; exp, sc, loc, iftiArgs});
                                                      ^~~~~~~~~
semantic.d:3298:53: error: cannot cast expression 'r' of type 'Expression' to 'bool'
						if(!r) mixin(ErrEplg);
                                                    ^
<mixin@<mixin@semantic.d:3298>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:3298>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:3300:44: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
					if(rewrite) return; // TODO: ok?
                                           ^~~~~~~
semantic.d:3305:84: error: cannot cast expression 'rewrite' of type 'Node' to 'void*'
			auto r = New!MatchCallWhenReady(cast(Expression)cast(void*)rewrite, loc, iftiArgs);
                                                                                   ^~~~~~~
semantic.d:3308:28: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
			if(rewrite) return; // TODO: ok?
                           ^~~~~~~
semantic.d:3312:21: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
		if(!rewrite) mixin(ErrEplg);
                    ^~~~~~~
<mixin@<mixin@semantic.d:3312>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:3312>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(ErrorDecl)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(StaticAssertDecl)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(PragmaDecl)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(VarDecl)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(Declarators)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(EnumVarDecl)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(CArrayDecl)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(CArrayParam)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(TmpVarDecl)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(EmptyDecl)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(Parameter)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(FunctionDecl)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
util.d:299:1: error: undefined identifier 'string'
string _dgliteral(T...)(){string r;foreach(t;T) r~=t.stringof ~ " is"~t.stringof~"(){return null;}"; return r;}
^~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
util.d:301:15: note: instantiated here
	mixin(_dgliteral!T()); // DMD bug
              ^~~~~~~~~~~~
type.d:84:15: note: instantiated here
	mixin DownCastMethods!(
              ^~~~~~~~~~~~~~~~~
semantic.d:503:56: error: cannot cast expression 'type' of type 'Type' to 'bool'
		assert(sstate != SemState.completed || type && type.sstate == SemState.completed,to!string(typeid(this)));
                                                       ^~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
semantic.d:503:98: error: undefined identifier 'to'
		assert(sstate != SemState.completed || type && type.sstate == SemState.completed,to!string(typeid(this)));
                                                                                                 ^~
semantic.d:503:108: error: feature TypeidExp not implemented
		assert(sstate != SemState.completed || type && type.sstate == SemState.completed,to!string(typeid(this)));
                                                                                                           ^~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
expression.d:334:18: error: undefined identifier 'string'
	override string toString(){return _brk("import("~join(map!(to!string)(a),",")~")");}
                 ^~~~~~
expression.d:207:18: error: undefined identifier 'string'
	override string toString(){return key.toString()~":"~value.toString();}
                 ^~~~~~
declaration.d:85:18: error: undefined identifier 'string'
	override string toString(){return symbol.toString()~": "~join(map!(to!string)(bindings),", ");}
                 ^~~~~~
expression.d:539:18: error: undefined identifier 'string'
	override string toString(){return key.toString()~":"~value.toString();}
                 ^~~~~~
expression.d:524:18: error: undefined identifier 'string'
	override string toString(){return "delete "~e.toString();}
                 ^~~~~~
expression.d:552:18: error: undefined identifier 'string'
	override string toString(){return "{"~join(map!(to!string)(args),",")~"}";}
                 ^~~~~~
expression.d:311:18: error: undefined identifier 'string'
	override string toString(){
                 ^~~~~~
expression.d:405:73: error: no member 'isType' for type 'Expression'
		this(!e?0.assocHash():e.tmplArgToHash().assocHash(),!e||e.isType());
                                                                        ^~~~~~~~
expression.d:321:18: error: undefined identifier 'string'
	override string toString(){return inst.toString()~'.'~nexp.toString();}
                 ^~~~~~
expression.d:519:18: error: undefined identifier 'string'
	override string toString(){return "__traits("~join(map!(to!string)(args),",")~")";}
                 ^~~~~~
parser.d:433:25: error: function call result 'this.tok()' of type 'Token' is not callable
		e.loc = tok.loc;
                        ^~~
parser.d:1420:65: error: function call result 'this.tok()' of type 'Token' is not callable
					auto oloc = spec.loc.to(tok.loc);
                                                                ^~~
parser.d:567:17: error: feature not implemented
		scope(success) if(res) res.loc=loc.to(ptok.loc);
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
parser.d:568:17: error: unimplemented feature SwitchStm
		switch(ttype){
                ^~~~~~~~~~~~~~
rope_.d:39:53: error: no matching function for call to 'this(Type[])'
			foreach(i,x;rng) arr[len+i]=S(x);;
                                                    ^~~~
expression.d:403:9: note: candidate constructor not viable
	this(AssocHash hash, bool typeOnly){this.hash=hash;this.typeOnly=typeOnly;}
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
expression.d:404:9: note: candidate constructor not viable
	this(Expression e){
        ^~~~~~~~~~~~~~~~~~~
rope_.d:39:53: error: no matching function for call to 'this(Expression[])'
			foreach(i,x;rng) arr[len+i]=S(x);;
                                                    ^~~~
expression.d:403:9: note: candidate constructor not viable
	this(AssocHash hash, bool typeOnly){this.hash=hash;this.typeOnly=typeOnly;}
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
expression.d:404:9: note: candidate constructor not viable
	this(Expression e){
        ^~~~~~~~~~~~~~~~~~~
rope_.d:40:25: error: unimplemented feature ForeachRangeStm
			foreach_reverse(i;1..len) arr[i]=arr[2*i].combine(arr[2*i+1]);
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
rope_.d:40:25: error: unimplemented feature ForeachRangeStm
			foreach_reverse(i;1..len) arr[i]=arr[2*i].combine(arr[2*i+1]);
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
parser.d:1427:95: error: function call result 'this.ptok()' of type 'const(Token)' is not callable
			auto p=New!TemplateParameter(which,type,name,spec,init); p.loc=loc.to(ptok.loc);
                                                                                              ^~~~
parser.d:1330:134: error: function call result 'this.ptok()' of type 'const(Token)' is not callable
			if(isAA){auto loc=tok.loc; mixin(doParse!("_",Type,"e","]")); pfix=New!IndexExp(pfix,[e]); pfix.loc = loc.to(ptok.loc);}
                                                                                                                                     ^~~~
parser.d:1330:134: error: function call result 'this.ptok()' of type 'const(Token)' is not callable
			if(isAA){auto loc=tok.loc; mixin(doParse!("_",Type,"e","]")); pfix=New!IndexExp(pfix,[e]); pfix.loc = loc.to(ptok.loc);}
                                                                                                                                     ^~~~
<mixin@expression.d:179>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@expression.d:179>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2695:41: error: no member 'init' for type 'long'
		auto fty=New!FunctionTy(STC.init,cast(Expression)null,cast(Parameter[])null,VarArgs.none);
                                        ^~~~~~~~
interpret.d:129:32: error: no member 'loc' for type 'Expression[]'
		r.lit[i].loc = x.loc;
                               ^~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
<mixin@expression.d:179>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
interpret.d:107:58: error: undefined identifier 'to'
		return Variant("TODO: cannot interpret "~to!string(this)~" yet",Type.get!string());
                                                         ^~
interpret.d:130:30: error: no member 'isArrayLiteralExp' for type 'Expression'
		if(auto rl = r.lit[i].isArrayLiteralExp()){
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:114:20: error: undefined identifier 'isArrayLiteralExp'
		if(isArrayLiteralExp()){
                   ^~~~~~~~~~~~~~~~~
interpret.d:131:38: error: no member 'isArrayLiteralExp' for type 'Expression[]'
			if(auto al = x.isArrayLiteralExp()){
                                     ^~~~~~~~~~~~~~~~~~~
interpret.d:115:48: error: cannot cast expression 'r' of type 'Expression' to 'LiteralExp'
			assert(cast(LiteralExp)r);
                                               ^
interpret.d:2710:20: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
		if(rewrite) return;
                   ^~~~~~~
analyze.d:44:19: error: feature expression.TraitsExp not implemented
	static if(__traits(hasMember,T,"manualPropagate") && T.manualPropagate)
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:116:57: error: cannot cast expression 'r' of type 'Expression' to 'void*'
			r = (cast(LiteralExp)cast(void*)r).toArrayLiteral();
                                                        ^
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
analyze.d:48:26: error: feature expression.TraitsExp not implemented
	alias TypeTuple!(__traits(getOverloads,T,"perform")) overloads;
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
variant.d:260:33: error: undefined identifier 'string'
		static if(is(T==string)){
                                ^~~~~~
interpret.d:308:26: note: instantiated here
		auto arr=value.get!(Variant[])();
                         ^~~~~~~~~~~~~~~~~~~~~
interpret.d:3973:17: error: undefined identifier 'decl'
		decl.byteCompile(bld);
                ^~~~
analyze.d:52:28: error: undefined identifier 'manualPropagate'
		static if(!manualPropagate) node._doAnalyze(&runIt);
                           ^~~~~~~~~~~~~~~
<mixin@<mixin@expression.d:179>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@expression.d:179>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:61:20: error: undefined identifier 'manualPropagate'
	static if(!manualPropagate) return result;
                   ^~~~~~~~~~~~~~~
interpret.d:61:17: note: instantiated here
		runAnalysis!ApplyLazyConditionalSemantic(this);
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
parser.d:1164:43: note: instantiated here
					p=parseCArrayDecl!CArrayParam(stc,type);
                                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~
parser.d:1167:53: error: function call result 'this.tok()' of type 'Token' is not callable
				name=New!Identifier(tok.name); name.loc=tok.loc; nextToken();
                                                    ^~~
semantic.d:2764:28: error: cannot cast expression 'rspec' of type 'Expression' to 'bool'
			if(rspec){
                           ^~~~~
analyze.d:44:19: error: feature expression.TraitsExp not implemented
	static if(__traits(hasMember,T,"manualPropagate") && T.manualPropagate)
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
parser.d:1306:49: note: instantiated here
		if(peek().type==Tok!"[") return parseCArrayDecl(stc,type);
                                                ^~~~~~~~~~~~~~~
parser.d:1309:38: error: function call result 'this.tok()' of type 'Token' is not callable
			Location loc=tok.loc;
                                     ^~~
parser.d:1313:78: error: function call result 'this.ptok()' of type 'const(Token)' is not callable
			auto v=New!VarDecl(stc,type,name,init); v.loc=loc.to(ptok.loc);
                                                                             ^~~~
interpret.d:2696:41: error: undefined identifier 'STCstatic'
		auto dg=New!FunctionDef(STCstatic,fty,New!Identifier("__ctfeCallWrapper"),cast(BlockStm)null,cast(BlockStm)null,cast(Identifier)null,bdy, false);
                                        ^~~~~~~~~
analyze.d:48:26: error: feature expression.TraitsExp not implemented
	alias TypeTuple!(__traits(getOverloads,T,"perform")) overloads;
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:52:28: error: undefined identifier 'manualPropagate'
		static if(!manualPropagate) node._doAnalyze(&runIt);
                           ^~~~~~~~~~~~~~~
analyze.d:61:20: error: undefined identifier 'manualPropagate'
	static if(!manualPropagate) return result;
                   ^~~~~~~~~~~~~~~
interpret.d:2723:17: note: instantiated here
		runAnalysis!MakeStrong(this);
                ^~~~~~~~~~~~~~~~~~~~~~
interpret.d:2724:20: error: cannot cast expression 'e' of type 'Expression' to 'bool'
		if(e) mixin(SemChld!q{e});
                   ^
interpret.d:2726:21: error: cannot cast expression 'ctfeCallWrapper' of type 'FunctionDef' to 'bool'
		if(!ctfeCallWrapper){
                    ^~~~~~~~~~~~~~~
interpret.d:2732:17: error: unimplemented feature TryStm
		try{
                ^~~~
<mixin@<mixin@semantic.d:11106>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:11106>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:11109>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:11109>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:2773:33: error: cannot cast expression 'spec' of type 'Type' to 'bool'
			assert(!spec);
                                ^~~~
semantic.d:2774:26: error: cannot cast expression 'rspec' of type 'Expression' to 'bool'
		}else if(rspec){
                         ^~~~~
<mixin@<mixin@semantic.d:2779>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:2779>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
declaration.d:230:18: error: undefined identifier 'string'
	override string kind(){return "template parameter";}
                 ^~~~~~
declaration.d:224:18: error: undefined identifier 'string'
	override string toString(){
                 ^~~~~~
semantic.d:527:25: error: unimplemented feature SwitchStm
			final switch(inContext) with(InContext){
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
rope_.d:68:55: note: instantiated here
				tree=new SliceSegTree(buildSegTree(array/+.map!(function(a)=>a.tmplArgToHash().assocHash())+/),0,array.length);
                                                      ^~~~~~~~~~~~
rope_.d:68:55: note: instantiated here
				tree=new SliceSegTree(buildSegTree(array/+.map!(function(a)=>a.tmplArgToHash().assocHash())+/),0,array.length);
                                                      ^~~~~~~~~~~~
<mixin@visitors.d:38>:13:28: error: cannot cast expression 'init' of type 'inout(Expression)' to 'bool'
			if(init)
                           ^~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
interpret.d:338:25: error: no member '_interpretFunctionCalls' for type 'Expression[]'
			x._interpretFunctionCalls(sc);
                        ^~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:325:37: error: no member 'checkInterpret' for type 'Expression[]'
		foreach(x; lit) if(!x.checkInterpret(sc)) ok=false;
                                    ^~~~~~~~~~~~~~~~
visitors.d:17:78: note: instantiated here
	static if(is(typeof(this):Expression)&&!is(typeof(this):Type)) mixin Interpret!(typeof(this));// TODO: minimize and report bug
                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~
expression.d:216:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
<mixin@visitors.d:38>:14:37: error: no member 'isTemporaryExp' for type 'Expression'
			if(auto tmp=(cast()init).isTemporaryExp()){
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3974:17: error: undefined identifier 'sym'
		sym.byteCompile(bld);
                ^~~
interpret.d:3512:45: error: undefined identifier 'isRefReturn'
		if(e) e.byteCompileRet(bld, isRefReturn);
                                            ^~~~~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'Symbol'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'Symbol'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
semantic.d:4649:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
semantic.d:4657:31: error: no member 'isSymbol' for type 'Expression'
		if(auto sym = rhs.isSymbol()){
                              ^~~~~~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
semantic.d:2557:31: error: undefined identifier 'exprs'
	mixin TupleImplConvTo!exprs;
                              ^~~~~
interpret.d:268:42: error: no member 'int64' for type 'Token'
		if(lit.type==Tok!"true") lit.int64=1;
                                         ^~~~~~~~~
interpret.d:269:48: error: no member 'int64' for type 'Token'
		else if(lit.type==Tok!"false") lit.int64=0;
                                               ^~~~~~~~~
interpret.d:270:23: error: unimplemented feature SwitchStm
		swtch:switch(lit.type){
                      ^~~~~~~~~~~~~~~~~
visitors.d:17:78: note: instantiated here
	static if(is(typeof(this):Expression)&&!is(typeof(this):Type)) mixin Interpret!(typeof(this));// TODO: minimize and report bug
                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~
expression.d:200:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
interpret.d:590:32: error: undefined identifier 'ctfeCallWrapper'
		callWrapper(sc,ctfeCallWrapper,consCall?consCall.e:null);		
                               ^~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'ExpTuple'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'IndexExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'ExpTuple'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'IndexExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
expression.d:374:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
semantic.d:2559:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
semantic.d:2503:28: error: undefined identifier 'exprs'
		foreach(x; exprs) if(auto r = dg(x)) return r;
                           ^~~~~
interpret.d:3426:20: error: cannot cast expression 's2' of type 'Statement' to 'bool'
		if(s2){
                   ^~
visitors.d:17:78: note: instantiated here
	static if(is(typeof(this):Expression)&&!is(typeof(this):Type)) mixin Interpret!(typeof(this));// TODO: minimize and report bug
                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:6188:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(Type)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
interpret.d:590:48: error: undefined identifier 'consCall'
		callWrapper(sc,ctfeCallWrapper,consCall?consCall.e:null);		
                                               ^~~~~~~~
visitors.d:17:78: note: instantiated here
	static if(is(typeof(this):Expression)&&!is(typeof(this):Type)) mixin Interpret!(typeof(this));// TODO: minimize and report bug
                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:17:78: note: instantiated here
	static if(is(typeof(this):Expression)&&!is(typeof(this):Type)) mixin Interpret!(typeof(this));// TODO: minimize and report bug
                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:6164:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
expression.d:305:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
semantic.d:2430:46: note: instantiated here
	this(Expression[] exprs){ this(exprs.captureTemplArgs); }
                                             ^~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
interpret.d:397:24: error: 'Variant' is not sliceable
		return lit[l.interpretV()..r.interpretV()];
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:17:78: note: instantiated here
	static if(is(typeof(this):Expression)&&!is(typeof(this):Type)) mixin Interpret!(typeof(this));// TODO: minimize and report bug
                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~
expression.d:384:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'AggregateTy'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'AggregateTy'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
type.d:339:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
expression.d:339:18: error: undefined identifier 'string'
	override string toString(){return _brk("assert("~join(map!(to!string)(a),",")~")");}
                 ^~~~~~
visitors.d:26:65: error: instantiation of template 'DeepDup' is ambiguous
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:37:1: note: candidate template
mixin template DeepDup(T) if(is(T: Node) && !is(T: BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:96:1: note: candidate template
mixin template DeepDup(T: Symbol) {
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(FunctionTy)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(TypeofReturnExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(ArrayTy)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(DynArrTy)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(PointerTy)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(NullPtrTy)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(ErrorTy)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(EmptyArrTy)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(TypeofExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(ConstTy)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(SharedTy)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(IndexExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(InoutTy)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(ImmutableTy)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(MatcherTy)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(EnumTy)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(DelegateTy)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(ExpTuple)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(IsExp)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
expression.d:504:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(MixinExp)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
expression.d:329:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
declaration.d:54:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
scope_.d:59:20: error: cannot cast expression 'd' of type 'Declaration' to 'bool'
		if(d){
                   ^
scope_.d:60:29: error: feature TypeidExp not implemented
			 if(typeid(d) is typeid(DoesNotExistDecl)){
                            ^~~~~~~~~
scope_.d:60:42: error: feature TypeidExp not implemented
			 if(typeid(d) is typeid(DoesNotExistDecl)){
                                         ^~~~~~~~~~~~~~~~~~~~~~~~
scope_.d:688:31: error: undefined identifier 'format'
			error(format("declaration '%s' shadows a %s%s",decl.name,confl.kind=="parameter"?"":"local ",confl.kind), decl.name.loc);
                              ^~~~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(BlockDecl)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:8142>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@semantic.d:8215>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:8142>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8215>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:8142>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:8215>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:8143:21: error: undefined identifier 'lsc'
		if(!lsc){lsc = New!BlockScope(sc); lsc.setLoopingStm(this);}
                    ^~~
semantic.d:8143:26: error: undefined identifier 'lsc'
		if(!lsc){lsc = New!BlockScope(sc); lsc.setLoopingStm(this);}
                         ^~~
semantic.d:8143:52: error: undefined identifier 'lsc'
		if(!lsc){lsc = New!BlockScope(sc); lsc.setLoopingStm(this);}
                                                   ^~~
<mixin@<mixin@semantic.d:8217>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8217>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
statement.d:130:18: error: undefined identifier 'string'
	override string toString(){return (f?"final ":"")~"switch("~e.toString()~") "~s.toString();}
                 ^~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
statement.d:104:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
interpret.d:3478:23: error: undefined identifier 'doBCStart'
		mixin(doBCStart~doBCEnd);
                      ^~~~~~~~~
interpret.d:3466:23: error: undefined identifier 'doBCStart'
		mixin(doBCStart~doBCEnd);
                      ^~~~~~~~~
interpret.d:3489:23: error: undefined identifier 'doBCStart'
		mixin(doBCStart~doBCEnd);
                      ^~~~~~~~~
interpret.d:3478:33: error: undefined identifier 'doBCEnd'
		mixin(doBCStart~doBCEnd);
                                ^~~~~~~
interpret.d:3466:33: error: undefined identifier 'doBCEnd'
		mixin(doBCStart~doBCEnd);
                                ^~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
statement.d:96:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
statement.d:89:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
interpret.d:3489:33: error: undefined identifier 'doBCEnd'
		mixin(doBCStart~doBCEnd);
                                ^~~~~~~
interpret.d:3491:17: error: undefined identifier 'bccontinue'
		bccontinue = &bccnt; scope(exit) bccontinue = null;
                ^~~~~~~~~~
interpret.d:3491:38: error: feature not implemented
		bccontinue = &bccnt; scope(exit) bccontinue = null;
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3504:32: error: undefined identifier 'bccontinue'
		bld.emitLabel(*bccontinue);
                               ^~~~~~~~~~
interpret.d:3492:20: error: cannot cast expression 'e1' of type 'Expression' to 'bool'
		if(e1){
                   ^~
interpret.d:3469:31: error: undefined identifier 'end'
		bld.emitLabel(end);
                              ^~~
interpret.d:357:24: error: 'Variant' is not indexable
		return lit[ind];
                       ^~~~~~~~
visitors.d:17:78: note: instantiated here
	static if(is(typeof(this):Expression)&&!is(typeof(this):Type)) mixin Interpret!(typeof(this));// TODO: minimize and report bug
                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~
expression.d:373:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
interpret.d:3482:34: error: undefined identifier 'start'
		bld.emitConstant(start);
                                 ^~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3472:34: error: undefined identifier 'start'
		bld.emitConstant(start);
                                 ^~~~~
interpret.d:3495:39: error: undefined identifier 'end'
			bld.emitLabel(end);
                                      ^~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:6285>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:6285>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:6285>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:6286:21: error: undefined identifier 'decl'
		if(!decl) decl=New!VarDecl(stc,ty,name,init);
                    ^~~~
semantic.d:6286:27: error: undefined identifier 'decl'
		if(!decl) decl=New!VarDecl(stc,ty,name,init);
                          ^~~~
semantic.d:4246:17: error: feature declaration.DebugDecl not implemented
		debug scope(exit) assert(sstate != SemState.started||needRetry||rewrite,toString()~" "~typeid(this.meaning).toString());
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:4247:17: error: feature declaration.DebugDecl not implemented
		debug scope(exit) assert(needRetry==2||!circ,toString()~" nR: "~to!string(needRetry)~" circ: "~to!string(circ));
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:4510:30: error: cannot cast expression 'meaning' of type 'Declaration' to 'bool'
	invariant(){ assert(!meaning||meaning.name !is this, text(typeid(this.meaning)," ",meaning.loc)); }
                             ^~~~~~~
semantic.d:4571:26: error: cannot cast expression 'meaning' of type 'Declaration' to 'bool'
		assert(!!meaning,toString());
                         ^~~~~~~
interpret.d:3499:20: error: cannot cast expression 'e2' of type 'Expression' to 'bool'
		if(e2) ExpressionStm.byteCompileIgnoreResult(bld, e2);
                   ^~
semantic.d:8287:14: error: declaration of 'isRefReturn' smells suspicously fishy
	bool isRefReturn;
             ^~~~~~~~~~~
interpret.d:3512:45: note: this lookup should have succeeded if it was valid
		if(e) e.byteCompileRet(bld, isRefReturn);
                                            ^~~~~~~~~~~
semantic.d:4196:54: error: no member 'scope_' for type 'Symbol[]'
				foreach(x; clist) if(x.scope_.handler.showsEffect()){
                                                     ^~~~~~~~
semantic.d:4198:49: error: no member 'scope_' for type 'Symbol[]'
					errsc = x.scope_;
                                                ^~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
type.d:101:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
statement.d:172:18: error: undefined identifier 'string'
	override string toString(){return "return"~(e?" "~e.toString():"")~";";}
                 ^~~~~~
interpret.d:3499:24: error: need 'this' to access member function 'ExpressionStm.byteCompileIgnoreResult'
		if(e2) ExpressionStm.byteCompileIgnoreResult(bld, e2);
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3412:9: note: member function was declared here
	static void byteCompileIgnoreResult(ref ByteCodeBuilder bld, Expression e){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:44:19: error: feature expression.TraitsExp not implemented
	static if(__traits(hasMember,T,"manualPropagate") && T.manualPropagate)
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:4200:42: error: no member 'meaning' for type 'Symbol[]'
				}else if(x.meaning.scope_&&x.meaning.scope_.handler.showsEffect()){
                                         ^~~~~~~~~
semantic.d:4200:60: error: no member 'meaning' for type 'Symbol[]'
				}else if(x.meaning.scope_&&x.meaning.scope_.handler.showsEffect()){
                                                           ^~~~~~~~~
semantic.d:4201:49: error: no member 'meaning' for type 'Symbol[]'
					errsc = x.meaning.scope_;
                                                ^~~~~~~~~
semantic.d:4207:28: error: cannot cast expression 'errsc.handler' of type 'ErrorHandler' to 'bool'
			if(errsc.handler){
                           ^~~~~~~~~~~~~
analyze.d:47:23: error: too many arguments to struct literal (expected zero)
	auto result = T(args);
                      ^~~~~~~
analyze.d:48:26: error: feature expression.TraitsExp not implemented
	alias TypeTuple!(__traits(getOverloads,T,"perform")) overloads;
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:52:28: error: undefined identifier 'manualPropagate'
		static if(!manualPropagate) node._doAnalyze(&runIt);
                           ^~~~~~~~~~~~~~~
analyze.d:61:20: error: undefined identifier 'manualPropagate'
	static if(!manualPropagate) return result;
                   ^~~~~~~~~~~~~~~
semantic.d:728:51: note: instantiated here
					result &= runAnalysis!FinishDeduction(sym.meaning,sc).result;
                                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:729:36: error: cannot cast expression 'sym.meaning' of type 'Declaration' to 'bool'
				if(sym.meaning)
                                   ^~~~~~~~~~~
semantic.d:6288:24: error: undefined identifier 'decl'
		type = decl.type;
                       ^~~~
<mixin@semantic.d:8248>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@semantic.d:8042>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@semantic.d:8032>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:8032>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8248>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8042>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:8032>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:8248>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:8042>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:6289>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:6289>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8250:20: error: cannot cast expression 'e' of type 'Expression' to 'bool'
		if(e) mixin(SemChldExpPar!q{e});
                   ^
expression.d:562:18: error: undefined identifier 'string'
	override string toString(){return (stc?STCtoString(stc)~" ":"")~(ty?ty.toString()~" ":"")~name.toString()~(init?"="~init.toString():"");}
                 ^~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
semantic.d:8043:21: error: undefined identifier 'tsc'
		if(!tsc) tsc = New!BlockScope(sc);
                    ^~~
semantic.d:8043:26: error: undefined identifier 'tsc'
		if(!tsc) tsc = New!BlockScope(sc);
                         ^~~
<mixin@<mixin@semantic.d:8035>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8035>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
statement.d:61:18: error: undefined identifier 'string'
	override string toString(){return e.toString() ~ ';';}
                 ^~~~~~
interpret.d:3501:34: error: undefined identifier 'start'
		bld.emitConstant(start);
                                 ^~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(StaticAssertDecl)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(EmptyDecl)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
declaration.d:166:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
declaration.d:61:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(FunctionDecl)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
declaration.d:457:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
interpret.d:4548:35: error: no member 'byteCompile' for type 'VarDecl[]'
		foreach(x; decls) x.byteCompile(bld);
                                  ^~~~~~~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
declaration.d:405:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
declaration.d:487:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(IndexExp)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
semantic.d:8383:20: error: cannot cast expression 'name' of type 'Identifier' to 'bool'
		if(name) sc.potentialRemove(name, decl);
                   ^~~~
semantic.d:8380:20: error: cannot cast expression 'name' of type 'Identifier' to 'bool'
		if(name) sc.potentialInsert(name, decl);
                   ^~~~
semantic.d:8474:120: error: undefined identifier 'to'
	void nestedTemplateInstantiation(TemplateInstanceDecl decl){ assert(0,"TODO: nestedTemplateInstantiation for "~to!string(typeid(this))); }
                                                                                                                       ^~
semantic.d:8476:98: error: undefined identifier 'to'
	void nestedFunctionLiteral(FunctionDef def){ assert(0,"TODO: nestedDelegateLiteral for "~to!string(typeid(this))); }
                                                                                                 ^~
semantic.d:8474:130: error: feature TypeidExp not implemented
	void nestedTemplateInstantiation(TemplateInstanceDecl decl){ assert(0,"TODO: nestedTemplateInstantiation for "~to!string(typeid(this))); }
                                                                                                                                 ^~~~~~~~~~~~
semantic.d:8476:108: error: feature TypeidExp not implemented
	void nestedFunctionLiteral(FunctionDef def){ assert(0,"TODO: nestedDelegateLiteral for "~to!string(typeid(this))); }
                                                                                                           ^~~~~~~~~~~~
semantic.d:8373:55: error: cannot cast expression 'scope_' of type 'Scope' to 'bool'
	invariant(){assert(sstate != SemState.pre || !scope_, to!string(typeid(this)));}
                                                      ^~~~~~
semantic.d:8373:63: error: undefined identifier 'to'
	invariant(){assert(sstate != SemState.pre || !scope_, to!string(typeid(this)));}
                                                              ^~
semantic.d:8373:73: error: feature TypeidExp not implemented
	invariant(){assert(sstate != SemState.pre || !scope_, to!string(typeid(this)));}
                                                                        ^~~~~~~~~~~~
semantic.d:8393:21: error: cannot cast expression 'name' of type 'Identifier' to 'bool'
		if(!name){sc.error("feature "~to!string(typeid(this))~" not implemented",loc); sstate = SemState.error; return;} // TODO: obvious
                    ^~~~
semantic.d:8393:47: error: undefined identifier 'to'
		if(!name){sc.error("feature "~to!string(typeid(this))~" not implemented",loc); sstate = SemState.error; return;} // TODO: obvious
                                              ^~
semantic.d:8393:57: error: feature TypeidExp not implemented
		if(!name){sc.error("feature "~to!string(typeid(this))~" not implemented",loc); sstate = SemState.error; return;} // TODO: obvious
                                                        ^~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
declaration.d:506:18: error: undefined identifier 'string'
	override string toString(){
                 ^~~~~~
module_.d:66:39: error: undefined identifier 'string'
	private this(Identifier name, string path, string code, ModuleRepository repository){
                                      ^~~~~~
declaration.d:145:18: error: undefined identifier 'string'
	override string toString(){return (stc?STCtoString(astStc)~" ":"")~"debug="~spec.toString()~";";}
                 ^~~~~~
declaration.d:517:18: error: undefined identifier 'string'
	override string toString(){
                 ^~~~~~
declaration.d:478:18: error: undefined identifier 'string'
	override string toString(){return (stc?STCtoString(astStc)~" ":"")~"unittest"~bdy.toString();}
                 ^~~~~~
declaration.d:25:28: error: undefined identifier 'string'
	override @property string kind(){return "declaration";}
                           ^~~~~~
declaration.d:78:18: error: undefined identifier 'string'
	override string toString(){return (stc?STCtoString(astStc)~" ":"")~"module "~symbol.toString()~";";}
                 ^~~~~~
module_.d:114:28: error: undefined identifier 'string'
	override @property string kind(){return "module";}
                           ^~~~~~
module_.d:115:18: error: undefined identifier 'string'
	override string toString(){return "module "~name.name~";";}
                 ^~~~~~
scope_.d:20:18: error: undefined identifier 'string'
	override string toString(){ return "'"~originalReference.name~"' does not exist."; }
                 ^~~~~~
declaration.d:134:18: error: undefined identifier 'string'
	override string toString(){return (stc?STCtoString(astStc)~" ":"")~"version="~spec.toString()~";";}
                 ^~~~~~
scope_.d:17:63: error: no member 'init' for type 'long'
	this(Identifier orig){originalReference = orig; super(STC.init, orig); sstate = SemState.completed;}
                                                              ^~~~~~~~
declaration.d:191:18: error: undefined identifier 'string'
	override string toString(){return (stc?STCtoString(astStc)~" ":"")~"typedef "~decl.toString();}
                 ^~~~~~
declaration.d:133:70: error: current object 'super' of type 'Declaration' is not callable
	this(STC stc,Expression s)in{assert(s!is null);}body{spec=s; super(stc,null);}
                                                                     ^~~~~~~~~~~~~~~
declaration.d:190:66: error: current object 'super' of type 'Declaration' is not callable
	this(STC stc, Declaration declaration){decl=declaration; super(stc, declaration.name);}
                                                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
module_.d:66:52: error: undefined identifier 'string'
	private this(Identifier name, string path, string code, ModuleRepository repository){
                                                   ^~~~~~
semantic.d:9767:39: error: current object 'super' of type 'Declaration' is not callable
	this(STC stc,Identifier name){super(stc,name);}
                                      ^~~~~~~~~~~~~~~
declaration.d:144:70: error: current object 'super' of type 'Declaration' is not callable
	this(STC stc,Expression s)in{assert(s!is null);}body{spec=s; super(stc,null);}
                                                                     ^~~~~~~~~~~~~~~
declaration.d:515:17: error: current object 'super' of type 'Declaration' is not callable
		super(stc,d.name);
                ^~~~~~~~~~~~~~~~~
declaration.d:20:17: error: expression 'astStc' of type 'immutable(long)' is read-only
		astStc = stc;
                ^~~~~~~~~~~~
declaration.d:77:51: error: current object 'super' of type 'Declaration' is not callable
	this(STC stc, Expression sym){symbol=sym; super(stc, null);}
                                                  ^~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
module_.d:110:15: note: instantiated here
	mixin Analyze;
              ^~~~~~~
declaration.d:477:71: error: current object 'super' of type 'Declaration' is not callable
	this(STC stc,CompoundStm b)in{assert(b!is null);}body{ bdy=b; super(stc,null); }
                                                                      ^~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
parser.d:182:21: error: no member 'stringof' for type 'Declaration'
	enum SetLoc=T.stringof~q{
                    ^~~~~~~~~~
parser.d:1507:23: note: instantiated here
		mixin(SetLoc!Declaration);
                      ^~~~~~~~~~~~~~~~~~
parser.d:1510:25: error: no member 'init' for type 'long'
		STC stc=STC.init;
                        ^~~~~~~~
parser.d:1512:17: error: unimplemented feature SwitchStm
		switch(ttype){
                ^~~~~~~~~~~~~~
scope_.d:254:33: error: no member 'isOverloadSet' for type 'Declaration'
		else if(auto ov=d.isOverloadSet()){
                                ^~~~~~~~~~~~~~~
scope_.d:141:34: error: no member 'isOverloadSet' for type 'Declaration'
		if(r) if(auto ov=r.isOverloadSet()) if(!ov.sealingLookup) return null;
                                 ^~~~~~~~~~~~~~~
scope_.d:304:28: error: no member 'isOverloadSet' for type 'Declaration'
			if(d.isOverloadSet()){
                           ^~~~~~~~~~~~~~~
scope_.d:257:26: error: feature TypeidExp not implemented
		}else if(typeid(d) !is typeid(DoesNotExistDecl)){
                         ^~~~~~~~~
scope_.d:257:40: error: feature TypeidExp not implemented
		}else if(typeid(d) !is typeid(DoesNotExistDecl)){
                                       ^~~~~~~~~~~~~~~~~~~~~~~~
declaration.d:504:17: error: current object 'super' of type 'Declaration' is not callable
		super(stc,d.name);
                ^~~~~~~~~~~~~~~~~
module_.d:83:37: error: no member 'isImportDecl' for type 'Declaration[]'
				if(!x.isImportDecl()) x.stc|=STCstatic;
                                    ^~~~~~~~~~~~~~
semantic.d:8414:26: error: undefined identifier 'format'
		sc.error(format("%s '%s' is not callable",kind,name.toString()),loc);
                         ^~~~~~
semantic.d:4544:20: error: no member 'isTemplateInstanceDecl' for type 'Declaration'
		if(meaning.isTemplateInstanceDecl()) return null;
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:4582:30: error: no member 'isVarDecl' for type 'Declaration'
		if(auto vd = meaning.isVarDecl()) return !!(vd.stc&STCenum);
                             ^~~~~~~~~~~~~~~~~
semantic.d:4528:30: error: no member 'isTemplateInstanceDecl' for type 'Declaration'
		if(auto tmpl=meaning.isTemplateInstanceDecl()) return tmpl.bdy.scope_;
                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:4477:44: error: no member 'isFunctionDecl' for type 'Declaration'
		Declaration implcalldecl = meaning.isFunctionDecl();
                                           ^~~~~~~~~~~~~~~~~~~~~~
semantic.d:6257:25: error: no member 'isAggregateDecl' for type 'Declaration'
		else if(decl.isAggregateDecl()){
                        ^~~~~~~~~~~~~~~~~~~~
semantic.d:4553:28: error: no member 'isAggregateDecl' for type 'Declaration'
		    decl&&!decl.isAggregateDecl();
                           ^~~~~~~~~~~~~~~~~~~~
interpret.d:3381:66: error: no member 'isFunctionDecl' for type 'Declaration'
						if(self.meaning&&self.meaning.isFunctionDecl()&&self.meaning.sstate==SemState.started){
                                                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:196:21: error: no member 'isVarDecl' for type 'Declaration'
		if(!e2.meaning.isVarDecl()) return false;
                    ^~~~~~~~~~~~~~~~~~~~
semantic.d:4478:21: error: cannot cast expression 'implcalldecl' of type 'Declaration' to 'bool'
		if(!implcalldecl)
                    ^~~~~~~~~~~~
semantic.d:4479:36: error: no member 'isOverloadSet' for type 'Declaration'
			if(auto ov=meaning.isOverloadSet())
                                   ^~~~~~~~~~~~~~~~~~~~~
semantic.d:4483:17: error: unimplemented feature SwitchStm
		switch(inContext) with(InContext){
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:4488:58: error: function call result 'this.ignoreProperty()' of type 'bool' is not callable
		return implcalldecl && (implicitCall || !ignoreProperty && meaning.stc&STCproperty);
                                                         ^~~~~~~~~~~~~~
semantic.d:8418:20: error: cannot cast expression 'sc' of type 'Scope' to 'bool'
		if(sc) sc.error(format("can only instantiate templates, not %s%ss",kind,kind[$-1]=='s'?"e":""),loc);
                   ^~
semantic.d:8418:33: error: undefined identifier 'format'
		if(sc) sc.error(format("can only instantiate templates, not %s%ss",kind,kind[$-1]=='s'?"e":""),loc);
                                ^~~~~~
semantic.d:8423:20: error: cannot cast expression 'sc' of type 'Scope' to 'bool'
		if(sc) sc.error(format("%s '%s' is not a function template",kind, name.name),loc);
                   ^~
semantic.d:8423:33: error: undefined identifier 'format'
		if(sc) sc.error(format("%s '%s' is not a function template",kind, name.name),loc);
                                ^~~~~~
interpret.d:3382:61: error: cannot cast expression 'result' of type 'Scope' to 'bool'
							if(!result) result = self.scope_; // TODO: shortcut
                                                            ^~~~~~
semantic.d:10163:28: error: undefined identifier 'string'
	override @property string kind(){
                           ^~~~~~
semantic.d:9810:18: error: undefined identifier 'string'
	override string toString(){ return join(map!(to!string)(decls~cast(OverloadableDecl[])tdecls),"\n");}
                 ^~~~~~
scope_.d:307:43: error: undefined identifier 'psymtab'
				auto psym=psymtab.get(ident.ptr,[]);
                                          ^~~~~~~
module_.d:83:55: error: no member 'stc' for type 'Declaration[]'
				if(!x.isImportDecl()) x.stc|=STCstatic;
                                                      ^~~~~
<mixin@module_.d:93>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
semantic.d:9815:36: error: no member 'isFunctionDecl' for type 'OverloadableDecl[]'
			if(auto fd=x.isFunctionDecl())
                                   ^~~~~~~~~~~~~~~~
semantic.d:9785:37: error: no member 'init' for type 'long'
	this(Identifier name){super(STC.init,name);}
                                    ^~~~~~~~
<mixin@semantic.d:8399>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
semantic.d:9781:23: error: no member 'init' for type 'long'
		super(STC.init,args[0].name);
                      ^~~~~~~~
<mixin@<mixin@module_.d:93>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
scope_.d:64:39: error: no member 'isOverloadableDecl' for type 'Declaration'
		     }else if(auto fd=decl.isOverloadableDecl()){ // some declarations can be overloaded, so no error
                                      ^~~~~~~~~~~~~~~~~~~~~~~
scope_.d:65:44: error: no member 'isOverloadSet' for type 'Declaration'
				if(auto os=d.isOverloadSet()){
                                           ^~~~~~~~~~~~~~~
scope_.d:75:41: error: no member 'isOverloadableDecl' for type 'Declaration'
				assert(!d.isOverloadableDecl());
                                        ^~~~~~~~~~~~~~~~~~~~
scope_.d:77:31: error: undefined identifier 'format'
			error(format("redefinition of '%s'",decl.name), decl.name.loc);
                              ^~~~~~
semantic.d:9782:37: error: cannot implicitly convert parameter 'd' of type 'OverloadableDecl[]' to 'OverloadableDecl'
		foreach(d;args) add(d);
                                    ^
semantic.d:9787:18: note: while matching function parameter 'decl'
	void add(OverloadableDecl decl)in{
                 ^~~~~~~~~~~~~~~~~~~~~
semantic.d:9818:38: error: no member 'iftiDecl' for type 'TemplateDecl[]'
			if(auto ep = x.iftiDecl())
                                     ^~~~~~~~~~
semantic.d:730:45: error: no member 'isCrossScopeOverloadSet' for type 'Declaration'
				if(auto cso=sym.meaning.isCrossScopeOverloadSet()){
                                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
expression.d:60:47: error: cannot cast expression 'dependee' of type 'Dependee' to 'bool'
		bool isIndependent(){ return !dependee; }
                                              ^~~~~~~~
semantic.d:9878:15: note: instantiated here
	final Dependent!FunctionDecl findOverrider(FunctionDecl fun)in{
              ^~~~~~~~~~~~~~~~~~~~~~
semantic.d:10140:17: error: undefined identifier 'size_t'
		size_t c=0;
                ^~~~~~
<mixin@module_.d:93>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:10168:32: error: undefined identifier 'size_t'
	public final @property size_t count(){ return decls.length + tdecls.length; }
                               ^~~~~~
semantic.d:10141:37: error: cannot cast expression 'x' of type 'TemplateInstanceDecl[]' to 'bool'
		foreach(x;insts) if(x) c++;
                                    ^
semantic.d:6262:35: error: undefined identifier 'STCstatic'
			dg.stc |= STCstatic;
                                  ^~~~~~~~~
module_.d:94:44: error: default parameters not implemented yet
		if(sstate == SemState.pre) presemantic();
                                           ^~~~~~~~~~~~~
semantic.d:10144:34: error: undefined identifier 'format'
			sc.error(format("no matching template for instantiation '%s!(%s)'",name,join(map!"a.toString()"(args.args),",")),loc);
                                 ^~~~~~
semantic.d:8407:30: error: undefined identifier 'STCstatic'
		return !(stc&STCstatic) && check == AccessCheck.all;
                             ^~~~~~~~~
module_.d:83:62: error: undefined identifier 'STCstatic'
				if(!x.isImportDecl()) x.stc|=STCstatic;
                                                             ^~~~~~~~~
<mixin@<mixin@semantic.d:8399>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:10118:34: error: undefined identifier 'format'
			sc.error(format("no matching function for call to '%s(%s)'",name,join(map!"a.type.toString()"(args),",")), loc);
                                 ^~~~~~
module_.d:96:25: error: no member 'semantic' for type 'Declaration[]'
			x.semantic(sc);
                        ^~~~~~~~~~
semantic.d:3200:29: error: undefined identifier 'inst'
			if(!inst||inst.sstate==SemState.error) mixin(ErrEplg);
                            ^~~~
semantic.d:3200:35: error: undefined identifier 'inst'
			if(!inst||inst.sstate==SemState.error) mixin(ErrEplg);
                                  ^~~~
<mixin@<mixin@semantic.d:3200>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:3200>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:3202:26: error: undefined identifier 'inst'
		assert(!!inst);
                         ^~~~
module_.d:84:33: error: no member 'presemantic' for type 'Declaration[]'
				x.presemantic(sc); // add all to symbol table
                                ^~~~~~~~~~~~~
module_.d:85:33: error: type 'Scheduler' is not callable
				Scheduler().add(x, sc);
                                ^~~~~~~~~~~
semantic.d:6274:20: error: cannot cast expression 'auto enc=sc.getDeclaration()' of type 'Declaration' to 'bool'
		if(auto enc=sc.getDeclaration()) if(auto fd=enc.isFunctionDef()){
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:9801:23: error: undefined identifier 'util'
		alias util.any any;
                      ^~~~
module_.d:100:74: error: no member 'sstate' for type 'Declaration[]'
		assert(sstate==SemState.error||{foreach(x; decls) assert(x.sstate == SemState.completed && !x.needRetry, text(x," ", x.sstate, " ", x.needRetry));return 1;}());
                                                                         ^~~~~~~~
semantic.d:10118:90: error: undefined identifier 'join'
			sc.error(format("no matching function for call to '%s(%s)'",name,join(map!"a.type.toString()"(args),",")), loc);
                                                                                         ^~~~
semantic.d:10144:97: error: undefined identifier 'join'
			sc.error(format("no matching template for instantiation '%s!(%s)'",name,join(map!"a.toString()"(args.args),",")),loc);
                                                                                                ^~~~
<mixin@semantic.d:8399>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:9793:28: error: no member 'isTemplateDecl' for type 'OverloadableDecl'
		if(auto td=decl.isTemplateDecl()) tdecls~=td;
                           ^~~~~~~~~~~~~~~~~~~
module_.d:100:109: error: no member 'needRetry' for type 'Declaration[]'
		assert(sstate==SemState.error||{foreach(x; decls) assert(x.sstate == SemState.completed && !x.needRetry, text(x," ", x.sstate, " ", x.needRetry));return 1;}());
                                                                                                            ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8394>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8394>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:10118:95: error: undefined identifier 'map'
			sc.error(format("no matching function for call to '%s(%s)'",name,join(map!"a.type.toString()"(args),",")), loc);
                                                                                              ^~~
semantic.d:10144:102: error: undefined identifier 'map'
			sc.error(format("no matching template for instantiation '%s!(%s)'",name,join(map!"a.toString()"(args.args),",")),loc);
                                                                                                     ^~~
semantic.d:10146:36: error: no member 'sstate' for type 'TemplateDecl[]'
				if(tdecl.sstate == SemState.error) continue;
                                   ^~~~~~~~~~~~
semantic.d:10147:74: error: no member 'loc' for type 'TemplateDecl[]'
				sc.note("candidate template not viable", tdecl.loc); // TODO: say why
                                                                         ^~~~~~~~~
semantic.d:10120:48: error: no member 'isFunctionDecl' for type 'OverloadableDecl[]'
				if(auto fdef = decl.isFunctionDecl())
                                               ^~~~~~~~~~~~~~~~~~~
semantic.d:10122:41: error: undefined identifier 'format'
				sc.note(format("candidate %s not viable", decl.kind), decl.loc); // TODO: say why
                                        ^~~~~~
semantic.d:10150:34: error: undefined identifier 'format'
			sc.error(format("instantiation of template '%s' is ambiguous", name), loc);
                                 ^~~~~~
<mixin@<mixin@semantic.d:8400>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8400>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:10152:37: error: cannot cast expression 'insts[i]' of type 'TemplateInstanceDecl' to 'bool'
				if(!insts[i]||tdecl.sstate == SemState.error) continue;
                                    ^~~~~~~~
semantic.d:10152:47: error: no member 'sstate' for type 'TemplateDecl[]'
				if(!insts[i]||tdecl.sstate == SemState.error) continue;
                                              ^~~~~~~~~~~~
semantic.d:10153:62: error: no member 'loc' for type 'TemplateDecl[]'
				sc.note("candidate template",tdecl.loc);
                                                             ^~~~~~~~~
semantic.d:10122:75: error: no member 'kind' for type 'OverloadableDecl[]'
				sc.note(format("candidate %s not viable", decl.kind), decl.loc); // TODO: say why
                                                                          ^~~~~~~~~
semantic.d:10122:87: error: no member 'loc' for type 'OverloadableDecl[]'
				sc.note(format("candidate %s not viable", decl.kind), decl.loc); // TODO: say why
                                                                                      ^~~~~~~~
semantic.d:10127:34: error: undefined identifier 'format'
			sc.error(format("call to '%s' is ambiguous",name), loc);
                                 ^~~~~~
module_.d:100:122: error: undefined identifier 'text'
		assert(sstate==SemState.error||{foreach(x; decls) assert(x.sstate == SemState.completed && !x.needRetry, text(x," ", x.sstate, " ", x.needRetry));return 1;}());
                                                                                                                         ^~~~
module_.d:100:134: error: no member 'sstate' for type 'Declaration[]'
		assert(sstate==SemState.error||{foreach(x; decls) assert(x.sstate == SemState.completed && !x.needRetry, text(x," ", x.sstate, " ", x.needRetry));return 1;}());
                                                                                                                                     ^~~~~~~~
module_.d:100:149: error: no member 'needRetry' for type 'Declaration[]'
		assert(sstate==SemState.error||{foreach(x; decls) assert(x.sstate == SemState.completed && !x.needRetry, text(x," ", x.sstate, " ", x.needRetry));return 1;}());
                                                                                                                                                    ^~~~~~~~~~~
semantic.d:6274:61: error: no member 'isFunctionDef' for type 'Declaration'
		if(auto enc=sc.getDeclaration()) if(auto fd=enc.isFunctionDef()){
                                                            ^~~~~~~~~~~~~~~~~
semantic.d:9797:29: error: undefined identifier 'STCproperty'
		if(decl.stc&STCproperty) stc|=STCproperty;
                            ^~~~~~~~~~~
semantic.d:9797:47: error: undefined identifier 'STCproperty'
		if(decl.stc&STCproperty) stc|=STCproperty;
                                              ^~~~~~~~~~~
<mixin@<mixin@module_.d:101>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@module_.d:101>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
expression.d:229:18: error: undefined identifier 'string'
	override string toString(){return _brk((which==Kind.function_?"function"~(fty&&fty.rret?" ":""):which==Kind.delegate_?fty&&fty.rret?"delegate ":"":"")~(fty?fty.toString():"")~bdy.toString());}
                 ^~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
util.d:305:27: error: no member 'stringof' for type 'MixinDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'MixinDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'AliasDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'AliasDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
declaration.d:185:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'TemplateMixinDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'TemplateMixinDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'EnumDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'EnumDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
declaration.d:113:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'TemplateInstanceDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'TemplateInstanceDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'ImportDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'ImportDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
declaration.d:94:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
semantic.d:2353:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
declaration.d:176:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'SymbolMatcher'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'SymbolMatcher'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
declaration.d:267:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'CrossScopeOverloadSet'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'CrossScopeOverloadSet'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'GenerativeDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'GenerativeDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
declaration.d:120:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
semantic.d:10328:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
semantic.d:10311:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'AggregateDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'ReferenceAggregateDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'InterfaceDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'ValueAggregateDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
semantic.d:10303:28: error: undefined identifier 'string'
	override @property string kind(){
                           ^~~~~~
semantic.d:10309:18: error: undefined identifier 'string'
	override string toString(){ return join(map!(to!string)(decls)); }	
                 ^~~~~~
util.d:305:27: error: no member 'stringof' for type 'ClassDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
semantic.d:10219:39: error: undefined identifier 'string'
	static class OverloadResolver(string op,TT...) : Declaration{
                                      ^~~~~~
util.d:305:27: error: no member 'stringof' for type 'TemplateDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'InterfaceDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'ValueAggregateDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'AggregateDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'ReferenceAggregateDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'TemplateDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'ClassDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
semantic.d:10181:22: error: type 'Declaration' is not an expression
		bool[Declaration] has;
                     ^~~~~~~~~~~
declaration.d:277:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
declaration.d:283:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
declaration.d:334:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
declaration.d:293:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
declaration.d:258:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
declaration.d:322:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
semantic.d:10386:9: error: undefined identifier 'size_t'
	size_t[] positions;
        ^~~~~~
semantic.d:10395:17: error: current object 'super' of type 'SymbolMatcher' is not callable
		super(set, loc, func);
                ^~~~~~~~~~~~~~~~~~~~~
semantic.d:10432:17: error: current object 'this' of type 'FunctionOverloadMatcher' is not callable
		this(set, loc, this_, func, args);
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:10322:17: error: current object 'super' of type 'Declaration' is not callable
		super(set.stc,set.name);
                ^~~~~~~~~~~~~~~~~~~~~~~
semantic.d:10214:23: error: no member 'init' for type 'long'
		super(STC.init, decls[0].name);
                      ^~~~~~~~
semantic.d:10336:17: error: current object 'super' of type 'SymbolMatcher' is not callable
		super(set, loc, func);
                ^~~~~~~~~~~~~~~~~~~~~
semantic.d:10195:23: error: undefined identifier 'util'
		alias util.all all;
                      ^~~~
semantic.d:10203:36: error: no member 'isCrossScopeOverloadSet' for type 'Declaration[]'
			if(auto ov=d.isCrossScopeOverloadSet())
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:10285:28: error: no member 'dup' for type 'Declaration[]'
		auto iftis=decls.dup;
                           ^~~~~~~~~
semantic.d:10270:28: error: no member 'dup' for type 'Declaration[]'
		auto insts=decls.dup;
                           ^~~~~~~~~
<mixin@semantic.d:10439>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@semantic.d:10344>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:10344>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:10439>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:44:19: error: feature expression.TraitsExp not implemented
	static if(__traits(hasMember,T,"manualPropagate") && T.manualPropagate)
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:10439>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:10344>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:10346:29: error: cannot cast expression 'x' of type 'Declaration[]' to 'bool'
			if(!x) continue;
                            ^
semantic.d:10440:20: error: cannot cast expression 'waitFor' of type 'TemplateInstanceDecl' to 'bool'
		if(waitFor){
                   ^~~~~~~
analyze.d:48:26: error: feature expression.TraitsExp not implemented
	alias TypeTuple!(__traits(getOverloads,T,"perform")) overloads;
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:52:28: error: undefined identifier 'manualPropagate'
		static if(!manualPropagate) node._doAnalyze(&runIt);
                           ^~~~~~~~~~~~~~~
semantic.d:10184:33: error: undefined identifier 'swap'
				swap(d,decls[$-1]);
                                ^~~~
analyze.d:61:20: error: undefined identifier 'manualPropagate'
	static if(!manualPropagate) return result;
                   ^~~~~~~~~~~~~~~
interpret.d:3386:43: note: instantiated here
				auto sc = runAnalysis!FindScope(x).result;
                                          ^~~~~~~~~~~~~~~~~~~~~
interpret.d:3387:46: error: no member 'toString' for type 'Statement[]'
				assert(!!sc, x.toString());
                                             ^~~~~~~~~~
interpret.d:3388:60: error: no member 'sizeof' for type 'void*'
				static assert(sc.sizeof <= (void*).sizeof && (void*).sizeof<=ulong.sizeof);
                                                           ^~~~~~~~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
semantic.d:10348:60: error: cannot cast expression 'x' of type 'Declaration[]' to 'TemplateInstanceDecl'
			assert(!!cast(TemplateInstanceDecl)x);
                                                           ^
semantic.d:10349:28: error: no member 'sstate' for type 'Declaration[]'
			if(x.sstate == SemState.error) x = null;
                           ^~~~~~~~
semantic.d:10350:33: error: cannot cast expression 'x' of type 'Declaration[]' to 'bool'
			assert(!x||(cast(TemplateInstanceDecl)x).completedMatching);
                                ^
semantic.d:10350:63: error: cannot cast expression 'x' of type 'Declaration[]' to 'TemplateInstanceDecl'
			assert(!x||(cast(TemplateInstanceDecl)x).completedMatching);
                                                              ^
semantic.d:10353:17: error: undefined identifier 'size_t'
		size_t c = 0;
                ^~~~~~
semantic.d:10354:38: error: cannot cast expression 'x' of type 'Declaration[]' to 'bool'
		foreach(x; insts) if(x) c++;
                                     ^
semantic.d:10355:47: error: cannot cast expression 'r' of type 'Declaration[]' to 'bool'
		if(c==1) foreach(r; insts) if(r) mixin(RewEplg!q{r});
                                              ^
semantic.d:10356:20: error: cannot cast expression 'sc_' of type 'Scope' to 'bool'
		if(sc_) set.instantiationError(sc_, loc, cast(TemplateInstanceDecl[])insts, args);
                   ^~~
<mixin@<mixin@semantic.d:10357>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:10357>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:200:20: error: cannot cast expression 'this_' of type 'Expression' to 'bool'
		if(this_&&this_.isConstant()) return true;
                   ^~~~~
visitors.d:17:78: note: instantiated here
	static if(is(typeof(this):Expression)&&!is(typeof(this):Type)) mixin Interpret!(typeof(this));// TODO: minimize and report bug
                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~
expression.d:449:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
interpret.d:178:30: error: no member 'isVarDecl' for type 'Declaration'
		if(auto vd = meaning.isVarDecl()){
                             ^~~~~~~~~~~~~~~~~
<mixin@semantic.d:4063>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:4063>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:4063>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:4064:21: error: undefined identifier 'gscope'
		if(!gscope) gscope = New!GaggingScope(sc);
                    ^~~~~~
semantic.d:4064:29: error: undefined identifier 'gscope'
		if(!gscope) gscope = New!GaggingScope(sc);
                            ^~~~~~
semantic.d:4065:42: error: undefined identifier 'gscope'
		auto f = ty.typeSemantic(gscope);
                                         ^~~~~~
<mixin@<mixin@semantic.d:4070>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:4070>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:4073:17: error: unimplemented feature SwitchStm
		switch(which){
                ^~~~~~~~~~~~~~
semantic.d:4101:20: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
		if(rewrite) return;
                   ^~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
expression.d:499:18: error: undefined identifier 'string'
	override string toString(){
                 ^~~~~~
expression.d:492:9: error: undefined identifier 'TokenType'
	TokenType tySpec2;
        ^~~~~~~~~
expression.d:494:71: error: undefined identifier 'TokenType'
	this(WhichIsExp w, Expression t, Identifier i, Expression ts, TokenType ts2, TemplateParameter[] tp)
                                                                      ^~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
util.d:305:27: error: no member 'stringof' for type 'UnionDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'UnionDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'StructDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'StructDecl'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
declaration.d:310:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
declaration.d:302:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
interpret.d:180:41: error: undefined identifier 'text'
			assert(vd.init, text(this," ",loc));
                                        ^~~~
visitors.d:17:78: note: instantiated here
	static if(is(typeof(this):Expression)&&!is(typeof(this):Type)) mixin Interpret!(typeof(this));// TODO: minimize and report bug
                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:4651:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
semantic.d:521:81: error: undefined identifier 'text'
			assert(this.inContext.among(InContext.none, inContext), text(this," ",this.inContext," ",inContext));
                                                                                ^~~~
semantic.d:4162:15: note: instantiated here
	mixin ContextSensitive;
              ^~~~~~~~~~~~~~~~
semantic.d:4510:62: error: undefined identifier 'text'
	invariant(){ assert(!meaning||meaning.name !is this, text(typeid(this.meaning)," ",meaning.loc)); }
                                                             ^~~~
semantic.d:4510:67: error: feature TypeidExp not implemented
	invariant(){ assert(!meaning||meaning.name !is this, text(typeid(this.meaning)," ",meaning.loc)); }
                                                                  ^~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'LookupIdentifier'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:27: error: no member 'stringof' for type 'Identifier'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'Identifier'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'LookupIdentifier'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
expression.d:250:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
semantic.d:5688:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
semantic.d:527:25: error: unimplemented feature SwitchStm
			final switch(inContext) with(InContext){
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:521:81: error: undefined identifier 'text'
			assert(this.inContext.among(InContext.none, inContext), text(this," ",this.inContext," ",inContext));
                                                                                ^~~~
semantic.d:11097:23: note: instantiated here
		mixin ContextSensitive;
                      ^~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
expression.d:327:18: error: undefined identifier 'string'
	override string toString(){return _brk("mixin("~join(map!(to!string)(a),",")~")");}
                 ^~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
semantic.d:600:60: error: undefined identifier 'min'
					self.accessCheck = min(self.accessCheck, check);
                                                           ^~~
<mixin@semantic.d:11100>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:11100>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:11100>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:11106>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:11106>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:11109>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:11109>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(TemplateDecl)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(ConditionalDecl)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(MixinDecl)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(GenerativeDecl)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(EnumDecl)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(ImportDecl)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(TemplateInstanceDecl)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(AliasDecl)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(TemplateMixinDecl)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(AggregateDecl)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(InterfaceDecl)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(ReferenceAggregateDecl)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(ClassDecl)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
interpret.d:3839:24: error: cannot cast expression 'e2.meaning' of type 'Declaration' to 'bool'
		assert(e2.meaning);
                       ^~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
interpret.d:3841:35: error: undefined identifier 'STCstatic'
		if(e2.meaning.stc&STCstatic){
                                  ^~~~~~~~~
interpret.d:3842:28: error: cannot cast expression 'this_' of type 'Expression' to 'bool'
			if(this_) ExpressionStm.byteCompileIgnoreResult(bld, this_);
                           ^~~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(StructDecl)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(UnionDecl)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
interpret.d:3842:35: error: need 'this' to access member function 'ExpressionStm.byteCompileIgnoreResult'
			if(this_) ExpressionStm.byteCompileIgnoreResult(bld, this_);
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3412:9: note: member function was declared here
	static void byteCompileIgnoreResult(ref ByteCodeBuilder bld, Expression e){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2751:28: error: undefined identifier 'exprs'
		foreach(x; exprs) x.byteCompile(bld);
                           ^~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
semantic.d:2560:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
semantic.d:2573:18: error: undefined identifier 'size_t'
	override size_t tmplArgToHash(){
                 ^~~~~~
semantic.d:2500:19: error: undefined identifier 'size_t'
	@property size_t length(){ return exprs.length;}
                  ^~~~~~
semantic.d:2439:14: error: undefined identifier 'size_t'
	this(size_t len, Expression exp)in{
             ^~~~~~
semantic.d:2544:28: error: undefined identifier 'string'
	override @property string kind(){return "sequence";}
                           ^~~~~~
semantic.d:2552:23: error: undefined identifier 'util'
		alias util.all all;
                      ^~~~
semantic.d:2543:18: error: undefined identifier 'string'
	override string toString(){return "("~join(map!(to!string)(exprs),",")~")";}
                 ^~~~~~
semantic.d:2563:23: error: undefined identifier 'util'
		alias util.all all;
                      ^~~~
semantic.d:2547:23: error: undefined identifier 'util'
		alias util.all all;
                      ^~~~
semantic.d:2537:39: error: undefined identifier 'exprs'
		auto r = New!ExpTuple(exprs, type);
                                      ^~~~~
semantic.d:2565:30: error: no member 'isExpTuple' for type 'Expression'
		if(auto et = rhs.isExpTuple()){
                             ^~~~~~~~~~~~~~
semantic.d:2472:45: error: no member 'exprs' for type 'ExpTuple'
				foreach(exp;this.tp.exprs)
                                            ^~~~~~~~~~~~~
semantic.d:2478:24: error: too many arguments to struct literal (expected zero)
		return AllIndices(sc,inContext,loc,this);
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:2484:27: error: no member 'isSymbol' for type 'Expression'
		if(auto s=r.isSymbol()){
                          ^~~~~~~~~~
semantic.d:2496:39: error: cannot cast expression 'type' of type 'Type' to 'TypeTuple'
		assert(cast(TypeTuple)type);
                                      ^~~~
semantic.d:2497:57: error: cannot cast expression 'type' of type 'Type' to 'void*'
		auto types = (cast(TypeTuple)cast(void*)type).types;
                                                        ^~~~
semantic.d:2498:37: error: undefined identifier 'exprs'
		return New!ExpTuple(exprs[cast(size_t)a..cast(size_t)b],New!TypeTuple(types[cast(size_t)a..cast(size_t)b]));
                                    ^~~~~
semantic.d:2459:51: error: undefined identifier 'exprs'
		return indexImpl(sc,inContext,loc,exprs[cast(size_t)index]);
                                                  ^~~~~
semantic.d:2498:48: error: undefined identifier 'size_t'
		return New!ExpTuple(exprs[cast(size_t)a..cast(size_t)b],New!TypeTuple(types[cast(size_t)a..cast(size_t)b]));
                                               ^~~~~~
semantic.d:2459:62: error: undefined identifier 'size_t'
		return indexImpl(sc,inContext,loc,exprs[cast(size_t)index]);
                                                             ^~~~~~
<mixin@semantic.d:2508>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
semantic.d:2498:63: error: undefined identifier 'size_t'
		return New!ExpTuple(exprs[cast(size_t)a..cast(size_t)b],New!TypeTuple(types[cast(size_t)a..cast(size_t)b]));
                                                              ^~~~~~
semantic.d:2498:98: error: undefined identifier 'size_t'
		return New!ExpTuple(exprs[cast(size_t)a..cast(size_t)b],New!TypeTuple(types[cast(size_t)a..cast(size_t)b]));
                                                                                                 ^~~~~~
semantic.d:2498:113: error: undefined identifier 'size_t'
		return New!ExpTuple(exprs[cast(size_t)a..cast(size_t)b],New!TypeTuple(types[cast(size_t)a..cast(size_t)b]));
                                                                                                                ^~~~~~
<mixin@<mixin@semantic.d:2508>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
semantic.d:2567:66: error: undefined identifier 'zip'
			return all!(_=>_[0].tmplArgEquals(_[1]))(zip(exprs,et.exprs));
                                                                 ^~~
semantic.d:2567:70: error: undefined identifier 'exprs'
			return all!(_=>_[0].tmplArgEquals(_[1]))(zip(exprs,et.exprs));
                                                                     ^~~~~
<mixin@semantic.d:2508>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:2509:23: error: undefined identifier 'util'
		alias util.all all;
                      ^~~~
semantic.d:2512:20: error: undefined identifier 'exprs'
		if(exprs.length && exprs.value.typeOnly){
                   ^~~~~
semantic.d:2512:36: error: undefined identifier 'exprs'
		if(exprs.length && exprs.value.typeOnly){
                                   ^~~~~
semantic.d:2513:65: error: undefined identifier 'exprs'
			auto r=New!TypeTuple(cast(TypeTemplArgs)exprs); // TODO: ok?
                                                                ^~~~~
semantic.d:2518:21: error: cannot cast expression 'type' of type 'Type' to 'bool'
		if(!type){
                    ^~~~
semantic.d:2519:45: error: undefined identifier 'exprs'
			auto tta = new Type[exprs.length];
                                            ^~~~~
<mixin@<mixin@semantic.d:2528>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:2528>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
<mixin@semantic.d:8090>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@semantic.d:8109>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@semantic.d:8072>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:8090>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8109>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8072>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:8090>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:8109>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:8072>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:8073:21: error: undefined identifier 'lsc'
		if(!lsc){lsc = New!BlockScope(sc); lsc.setLoopingStm(this);}
                    ^~~
semantic.d:8091:21: error: undefined identifier 'lsc'
		if(!lsc){lsc = New!BlockScope(sc); lsc.setLoopingStm(this);}
                    ^~~
semantic.d:8091:26: error: undefined identifier 'lsc'
		if(!lsc){lsc = New!BlockScope(sc); lsc.setLoopingStm(this);}
                         ^~~
semantic.d:8073:26: error: undefined identifier 'lsc'
		if(!lsc){lsc = New!BlockScope(sc); lsc.setLoopingStm(this);}
                         ^~~
semantic.d:8091:52: error: undefined identifier 'lsc'
		if(!lsc){lsc = New!BlockScope(sc); lsc.setLoopingStm(this);}
                                                   ^~~
semantic.d:8073:52: error: undefined identifier 'lsc'
		if(!lsc){lsc = New!BlockScope(sc); lsc.setLoopingStm(this);}
                                                   ^~~
semantic.d:8110:21: error: undefined identifier 'lscs1'
		if(!lscs1){lscs1 = New!BlockScope(sc);}
                    ^~~~~
semantic.d:8110:28: error: undefined identifier 'lscs1'
		if(!lscs1){lscs1 = New!BlockScope(sc);}
                           ^~~~~
semantic.d:8111:20: error: cannot cast expression 's1' of type 'Statement' to 'bool'
		if(s1) mixin(SemChldPar!q{sc=lscs1;s1});
                   ^~
semantic.d:8112:21: error: undefined identifier 'lsc'
		if(!lsc){ lsc = New!BlockScope(lscs1); lsc.setLoopingStm(this); }
                    ^~~
semantic.d:8112:27: error: undefined identifier 'lsc'
		if(!lsc){ lsc = New!BlockScope(lscs1); lsc.setLoopingStm(this); }
                          ^~~
semantic.d:8112:48: error: undefined identifier 'lscs1'
		if(!lsc){ lsc = New!BlockScope(lscs1); lsc.setLoopingStm(this); }
                                               ^~~~~
semantic.d:8112:56: error: undefined identifier 'lsc'
		if(!lsc){ lsc = New!BlockScope(lscs1); lsc.setLoopingStm(this); }
                                                       ^~~
semantic.d:8113:20: error: cannot cast expression 'e1' of type 'Expression' to 'bool'
		if(e1){
                   ^~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
declaration.d:198:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
interpret.d:4930:38: error: no member 'byteCompile' for type 'Declaration[]'
		foreach(decl; decls) decl.byteCompile(bld);
                                     ^~~~~~~~~~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:6558:42: error: cannot cast expression 'rhs' of type 'Expression' to 'Type'
		if(auto type = cast(Type)rhs) return equals(type);
                                         ^~~
interpret.d:3786:30: error: no member 'isVarDecl' for type 'Declaration'
		if(auto vd = meaning.isVarDecl()) return vd.byteCompileSymbol(bld, this, scope_);
                             ^~~~~~~~~~~~~~~~~
interpret.d:3787:33: error: no member 'isFunctionDef' for type 'Declaration'
		else if(auto fd=meaning.isFunctionDef()){
                                ^~~~~~~~~~~~~~~~~~~~~
interpret.d:3813:30: error: no member 'isVarDecl' for type 'Declaration'
		if(auto vd = meaning.isVarDecl()) return vd.byteCompileSymbolLV(bld, this, scope_);
                             ^~~~~~~~~~~~~~~~~
interpret.d:3788:39: error: no member 'sizeof' for type 'Symbol'
			static assert(this.sizeof<=(void*).sizeof&&(void*).sizeof<=ulong.sizeof);
                                      ^~~~~~~~~~~
interpret.d:3788:52: error: no member 'sizeof' for type 'void*'
			static assert(this.sizeof<=(void*).sizeof&&(void*).sizeof<=ulong.sizeof);
                                                   ^~~~~~~~~~~~~~
interpret.d:3814:27: error: undefined identifier 'format'
		bld.error(format("cannot interpret symbol '%s' at compile time", toString()), loc);
                          ^~~~~~
interpret.d:3789:42: error: undefined identifier 'STCstatic'
			if(!(meaning.stc&STCstatic) && !fd.isConstructor()){
                                         ^~~~~~~~~
interpret.d:3846:21: error: cannot cast expression 'this_' of type 'Expression' to 'bool'
		if(!this_){
                    ^~~~~
semantic.d:6331:47: error: undefined identifier 'string'
	private static auto __funcliteralTQ(){string r;
                                              ^~~~~~
interpret.d:3853:25: error: cannot cast expression 'this_' of type 'Expression' to 'bool'
		assert(!this_ || cast(AggregateTy)this_.type.getHeadUnqual());
                        ^~~~~
interpret.d:3853:51: error: cannot cast expression 'this_.type.getHeadUnqual()' of type 'Type' to 'AggregateTy'
		assert(!this_ || cast(AggregateTy)this_.type.getHeadUnqual());
                                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3854:58: error: cannot cast expression 'this_.type.getHeadUnqual()' of type 'Type' to 'void*'
		auto aggrt = cast(AggregateTy)cast(void*)this_.type.getHeadUnqual();
                                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3856:28: error: no member 'isVarDecl' for type 'Declaration'
		if(auto vd=e2.meaning.isVarDecl()){
                           ^~~~~~~~~~~~~~~~~~~~
interpret.d:3857:25: error: undefined identifier 'size_t'
			size_t len, off = aggrt.getBCLocOf(vd, len);
                        ^~~~~~
interpret.d:3857:25: error: undefined identifier 'size_t'
			size_t len, off = aggrt.getBCLocOf(vd, len);
                        ^~~~~~
semantic.d:9761:45: error: no member 'traverseInOrder' for type 'VarDecl[]'
		foreach(x; decls) if(auto r=x.traverseInOrder(dg)) return r;
                                            ^~~~~~~~~~~~~~~~~
semantic.d:10703:28: error: cannot cast expression 'auto decl=scope_.getDeclaration()' of type 'Declaration' to 'bool'
			if(auto decl=scope_.getDeclaration()) return !!decl.isAggregateDecl();
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:10703:72: error: no member 'isAggregateDecl' for type 'Declaration'
			if(auto decl=scope_.getDeclaration()) return !!decl.isAggregateDecl();
                                                                       ^~~~~~~~~~~~~~~~~~~~
semantic.d:10707:29: error: cannot cast expression 'decl' of type 'Declaration' to 'bool'
			if(!decl||!decl.isAggregateDecl()) return false;
                            ^~~~
semantic.d:10707:36: error: no member 'isAggregateDecl' for type 'Declaration'
			if(!decl||!decl.isAggregateDecl()) return false;
                                   ^~~~~~~~~~~~~~~~~~~~
semantic.d:10708:28: error: cannot cast expression 'auto decl2=decl.scope_.getDeclaration' of type 'Declaration' to 'bool'
			if(auto decl2=decl.scope_.getDeclaration)
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:10709:42: error: no member 'isAggregateDecl' for type 'Declaration'
				return !!decl2.isAggregateDecl();
                                         ^~~~~~~~~~~~~~~~~~~~~
semantic.d:10759:23: error: undefined identifier 'util'
		alias util.any any; // TODO: file bug
                      ^~~~
semantic.d:10843:25: error: undefined identifier 'string'
			string stcstr(STC stc){
                        ^~~~~~
semantic.d:10846:34: error: undefined identifier 'string'
			string n(string stcstr){
                                 ^~~~~~
semantic.d:10846:25: error: undefined identifier 'string'
			string n(string stcstr){
                        ^~~~~~
semantic.d:11013:27: error: no member 'isDeclaration' for type 'Statement'
		if(auto b=bdy.isDeclaration()) b.presemantic(sc);
                          ^~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
declaration.d:485:18: error: undefined identifier 'string'
	override string toString(){return (stc?STCtoString(astStc)~" ":"")~"pragma("~join(map!(to!string)(args),",")~")"~bdy.toString();}
                 ^~~~~~
<mixin@semantic.d:9755>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@semantic.d:11018>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@semantic.d:9040>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
declaration.d:484:87: error: current object 'super' of type 'Declaration' is not callable
	this(STC stc,Expression[] a, Statement b)in{assert(b&&1);}body{args=a; bdy=b; super(stc,null);}
                                                                                      ^~~~~~~~~~~~~~~
semantic.d:9751:39: error: no member 'presemantic' for type 'VarDecl[]'
		foreach(ref x; decls) x.presemantic(sc);
                                      ^~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
declaration.d:399:18: error: undefined identifier 'string'
	override string toString(){
                 ^~~~~~
declaration.d:397:42: error: no member 'init' for type 'long'
		decls=declarations;super(STC.init,null);
                                         ^~~~~~~~
semantic.d:10852:34: error: undefined identifier 'format'
			sc.error(format("cannot construct a%s %s object using a%s %s constructor",n1,hstcstr,n2,fstcstr), loc);
                                 ^~~~~~
semantic.d:10667:43: error: cannot cast expression 'scope_' of type 'Scope' to 'NestedScope'
		assert(!!cast(NestedScope)scope_);
                                          ^~~~~~
semantic.d:10668:63: error: cannot cast expression 'scope_' of type 'Scope' to 'NestedScope'
		assert(!!cast(TemplateScope)(cast(NestedScope)scope_).parent);
                                                              ^~~~~~
semantic.d:10669:87: error: cannot cast expression 'scope_' of type 'Scope' to 'void*'
		auto tsc = cast(TemplateScope)cast(void*)(cast(NestedScope)cast(void*)scope_).parent;
                                                                                      ^~~~~~
<mixin@<mixin@semantic.d:9755>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:11018>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:9040>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8783>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@semantic.d:9755>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:11018>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:9040>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:10691>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:8783>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
declaration.d:59:18: error: undefined identifier 'string'
	override string toString(){return ";";}
                 ^~~~~~
declaration.d:58:22: error: no member 'init' for type 'long'
	this(){super(STC.init,null);}
                     ^~~~~~~~
<mixin@<mixin@semantic.d:10691>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:10857:34: error: undefined identifier 'format'
			sc.error(format("receiver for %s '%s' is %s, but %s is required", fd.kind, fd.name, hstcstr, fstcstr), loc);
                                 ^~~~~~
declaration.d:449:28: error: undefined identifier 'string'
	override @property string kind(){
                           ^~~~~~
<mixin@semantic.d:10691>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:9757>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:9757>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:11019>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:11019>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
util.d:30:51: error: undefined identifier 'TypeTuple'
	static if(a.length){enum val = a[0];alias TypeTuple!(val,ToTuple!(a[1..$])) ToTuple;}
                                                  ^~~~~~~~~
semantic.d:10681:35: note: instantiated here
			foreach(x;ToTuple!(functionSTC~attributeSTC))
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:11020:28: error: no member 'isIdentifier' for type 'Expression'
		if(auto id=args[0].isIdentifier()){
                           ^~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:9049>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:9049>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:11022:25: error: unimplemented feature SwitchStm
			switch(id.name){
                        ^~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:9052>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:9052>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:11068:26: error: undefined identifier 'format'
		sc.error(format("unrecognized pragma '%s'",args[0].loc.rep),args[0].loc); // TODO: option to ignore
                         ^~~~~~
<mixin@<mixin@semantic.d:11070>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:11070>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:6369:21: error: cannot cast expression 'aggr' of type 'AggregateDecl' to 'bool'
		if(!aggr) return this;
                    ^~~~
semantic.d:6376:28: error: no member 'isFunctionDecl' for type 'Declaration'
		if(auto fd=fl.isFunctionDecl()){
                           ^~~~~~~~~~~~~~~~~
semantic.d:6365:34: error: no member 'init' for type 'long'
	STC getHeadSTC(){ return STC.init;}
                                 ^~~~~~~~
semantic.d:6546:51: error: undefined identifier 'to'
		assert(0, "no size yet for type "~to!string(this));
                                                  ^~
semantic.d:6561:18: error: undefined identifier 'size_t'
	override size_t tmplArgToHash(){
                 ^~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
type.d:19:18: error: undefined identifier 'string'
	override string toString(){return "Type";}
                 ^~~~~~
type.d:20:28: error: undefined identifier 'string'
	override @property string kind(){return "type";}
                           ^~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
type.d:354:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
<mixin@interpret.d:5034>:2:17: error: unimplemented feature SwitchStm
		switch(op){
                ^~~~~~~~~~~
<mixin@interpret.d:5040>:2:17: error: unimplemented feature SwitchStm
		switch(op){
                ^~~~~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
type.d:248:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
type.d:165:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
interpret.d:3966:24: error: type 'LVlength' is not callable
		return LVlength(e.byteCompileLV(bld),e.type.getElementType());
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:667:39: error: undefined identifier 'format'
			else sc.error(format("%s '%s' of type '%s' is read-only",kind,loc.rep,type),l);
                                      ^~~~~~
variant.d:488:27: error: unimplemented feature SwitchStm
		theswitch:switch(occupies){
                          ^~~~~~~~~~~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
type.d:324:15: note: instantiated here
	mixin Visitors;	
              ^~~~~~~~
type.d:308:15: note: instantiated here
	mixin Visitors;	
              ^~~~~~~~
type.d:316:15: note: instantiated here
	mixin Visitors;	
              ^~~~~~~~
type.d:332:15: note: instantiated here
	mixin Visitors;	
              ^~~~~~~~
semantic.d:6183:28: error: undefined identifier 'string'
	override @property string kind(){return "array length";}
                           ^~~~~~
semantic.d:6182:18: error: undefined identifier 'string'
	override string toString(){return e.toString()~".length";}
                 ^~~~~~
semantic.d:6326:26: error: undefined identifier 'format'
		sc.error(format("%s '%s' is not callable",kind,toString()),loc);
                         ^~~~~~
interpret.d:3948:20: error: no member 'isDynArrTy' for type 'Type'
		if(e.type.getHeadUnqual().isDynArrTy()){
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4236:28: error: no member 'isDynArrTy' for type 'Type'
		if(auto da=tu.isDynArrTy()){
                           ^~~~~~~~~~~~~
interpret.d:1483:35: error: no member 'isDynArrTy' for type 'Type'
		isarr = cast(bool)elty.getHeadUnqual().isDynArrTy();
                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3867:28: error: no member 'isFunctionDecl' for type 'Declaration'
		auto fun = e2.meaning.isFunctionDecl();
                           ^~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5153:30: error: no member 'getDynArr' for type 'Type'
	auto tag=q(cast(Type)el.getUnqual().getDynArr(),mem.ptr);
                             ^~~~~~~~~~~~~~~~~~~~~~~~
variant.d:700:90: error: no member 'getDynArr' for type 'Type'
			return Variant(arr[cast(size_t)l.int64..cast(size_t)r.int64],cnt,type.getElementType().getDynArr()); // aliasing ok?
                                                                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
variant.d:496:36: error: no member 'getDynArr' for type 'Type'
		return Variant(r,r,elt.getDynArr());
                                   ^~~~~~~~~~~~~
variant.d:701:23: error: unimplemented feature SwitchStm
		}else switch(occupies){
                      ^~~~~~~~~~~~~~~~~
semantic.d:6417:20: error: no member 'isPointerTy' for type 'Type'
		if(tu1.isPointerTy() && tu2.isPointerTy()
                   ^~~~~~~~~~~~~~~
semantic.d:6417:41: error: no member 'isPointerTy' for type 'Type'
		if(tu1.isPointerTy() && tu2.isPointerTy()
                                        ^~~~~~~~~~~~~~~
semantic.d:6418:23: error: no member 'isDynArrTy' for type 'Type'
		   || tu1.isDynArrTy() && tu2.isDynArrTy())
                      ^~~~~~~~~~~~~~
semantic.d:6418:43: error: no member 'isDynArrTy' for type 'Type'
		   || tu1.isDynArrTy() && tu2.isDynArrTy())
                                          ^~~~~~~~~~~~~~
semantic.d:6318:27: error: undefined identifier 'arrType'
		if(auto r=arrType.get(size,null)) return r;
                          ^~~~~~~
semantic.d:6358:24: error: undefined identifier 'STCimmutable'
		if(stc&STCimmutable)        r = r.getImmutable();
                       ^~~~~~~~~~~~
semantic.d:6393:15: error: undefined identifier 'isImmutableTy'
	alias isImmutableTy isImmutable;
              ^~~~~~~~~~~~~
semantic.d:6404:31: error: undefined identifier 'isFunctionTy'
		if(auto fty = isFunctionTy()) return fty;
                              ^~~~~~~~~~~~
<mixin@semantic.d:7994>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
semantic.d:6319:24: error: undefined identifier 'arrType'
		return arrType[size]=ArrayTy.create(this,size);
                       ^~~~~~~
interpret.d:5163:9: error: unimplemented feature ForeachRangeStm
	foreach(i;0..len) res[i]=el.variantFromMemory(mem[i*ctsize..(i+1)*ctsize], el);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8149:30: error: no member 'isArrayTy' for type 'Type'
		if(auto tt = ty.isArrayTy()) et = tt.ty;
                             ^~~~~~~~~~~~
type.d:43:34: error: undefined identifier 'U'
	static Type get(T: const(U),U)()if(!is(T==U)){
                                 ^
interpret.d:3952:32: error: no member 'isArrayTy' for type 'Type'
			assert(e.type.getHeadUnqual().isArrayTy());
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:6185>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
semantic.d:8150:30: error: no member 'isDynArrTy' for type 'Type'
		if(auto tt = ty.isDynArrTy()) et = tt.ty;
                             ^~~~~~~~~~~~~
semantic.d:8151:20: error: cannot cast expression 'et' of type 'Type' to 'bool'
		if(et){
                   ^~
variant.d:139:20: error: no member 'isAggregateTy' for type 'Type'
		if(tu.isAggregateTy()) return Occupies.vars;
                   ^~~~~~~~~~~~~~~~
interpret.d:3539:25: error: no member 'isEnumTy' for type 'Type'
		assert(!tu.isEnumTy());
                        ^~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
type.d:38:30: error: undefined identifier 'N'
	static Type get(T: T[N], ulong N)(){
                             ^
semantic.d:6159:18: error: undefined identifier 'string'
	override string toString(){return e.toString()~".ptr";}
                 ^~~~~~
semantic.d:6160:28: error: undefined identifier 'string'
	override @property string kind(){return "array base pointer";}
                           ^~~~~~
<mixin@<mixin@semantic.d:7994>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
variant.d:647:69: error: no member 'getPointer' for type 'Type'
		return Variant([FieldAccess(arr.ptr-cnt.ptr)], cnt, type.getElementType().getPointer());
                                                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
variant.d:403:28: error: cannot cast expression 'tou.getElementType()' of type 'Type' to 'bool'
			if(tou.getElementType()) return Variant((Variant[]).init,(Variant[]).init,to);
                           ^~~~~~~~~~~~~~~~~~~~
variant.d:403:65: error: no member 'init' for type 'Variant[]'
			if(tou.getElementType()) return Variant((Variant[]).init,(Variant[]).init,to);
                                                                ^~~~~~~~~~~~~~~~
variant.d:403:82: error: no member 'init' for type 'Variant[]'
			if(tou.getElementType()) return Variant((Variant[]).init,(Variant[]).init,to);
                                                                                 ^~~~~~~~~~~~~~~~
variant.d:404:28: error: no member 'isAggregateTy' for type 'Type'
			if(tou.isAggregateTy()) return Variant((Variant[VarDecl]).init, to);
                           ^~~~~~~~~~~~~~~~~
interpret.d:2601:29: error: no member 'sizeof' for type 'uint'
	if(s_t.getSizeof()==uint.sizeof) tmp[0] = cast(uint)tmp[0];
                            ^~~~~~~~~~~
interpret.d:2602:38: error: no member 'sizeof' for type 'ulong'
	else assert(s_t.getSizeof()==ulong.sizeof);
                                     ^~~~~~~~~~~~
interpret.d:2603:23: error: undefined identifier 'format'
	handler.error(format("array index %s%s is out of bounds [0%s..%d%s)",tmp[0],Size_t.suffix,Size_t.suffix,tmp[1],Size_t.suffix),info1.loc);
                      ^~~~~~
semantic.d:3160:21: error: undefined identifier 'inst'
		if(!inst) mixin(SemEplg);
                    ^~~~
variant.d:143:20: error: cannot cast expression 'tu.getElementType()' of type 'Type' to 'bool'
		if(tu.getElementType()) return Occupies.arr;
                   ^~~~~~~~~~~~~~~~~~~
variant.d:144:29: error: no member 'isPointerTy' for type 'Type'
		if(auto ptr=tu.isPointerTy())
                            ^~~~~~~~~~~~~~
visitors.d:17:78: note: instantiated here
	static if(is(typeof(this):Expression)&&!is(typeof(this):Type)) mixin Interpret!(typeof(this));// TODO: minimize and report bug
                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~
expression.d:341:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
variant.d:404:73: error: type 'VarDecl' is not an expression
			if(tou.isAggregateTy()) return Variant((Variant[VarDecl]).init, to);
                                                                        ^~~~~~~
<mixin@<mixin@semantic.d:6185>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3868:20: error: no member 'isSuperExp' for type 'Expression'
		if(this_.isSuperExp()) nonvirtual = true;
                   ^~~~~~~~~~~~~~~~
semantic.d:6155:22: error: no member 'getPointer' for type 'Type'
		type=e.type.getElementType().getPointer();
                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3641:45: error: no member 'getDynArr' for type 'Type'
			if(lit.length) tt = lit[0].type.getDynArr();
                                            ^~~~~~~~~~~~~~~~~~~~~
semantic.d:8096:81: error: undefined identifier 'lsc'
		if(e.sstate == SemState.completed){e=e.convertTo(bl);e.semantic(lsc);} // TODO: get rid of direct call
                                                                                ^~~
semantic.d:8049:82: error: undefined identifier 'tsc'
		if(e.sstate == SemState.completed){e=e.convertTo(bl); e.semantic(tsc);} // TODO: get rid of direct call
                                                                                 ^~~
<mixin@semantic.d:6185>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:8004:58: error: undefined identifier 'current'
	invariant(){assert(sstate!=SemState.completed || current == s.length);}
                                                         ^~~~~~~
variant.d:407:26: error: cannot cast expression 'type.isSomeString()' of type 'Type' to 'bool'
		}else if(type.isSomeString()){
                         ^~~~~~~~~~~~~~~~~~~
interpret.d:2611:36: error: undefined identifier 'format'
	if(isSigned) handler.error(format("shift amount of %d is outside the range 0..%d", cast(long)tmp[0], tmp[1]),info2.loc);
                                   ^~~~~~
interpret.d:2612:28: error: undefined identifier 'format'
	else handler.error(format("shift amount of %d is outside the range 0..%d", tmp[0], tmp[1]),info2.loc);
                           ^~~~~~
interpret.d:2618:42: error: cannot cast expression 'info3' of type 'Node' to 'Expression'
		auto exp=cast(Expression)info3;
                                         ^~~~~
interpret.d:2622:23: error: undefined identifier 'format'
	handler.error(format("%s pointer dereference%s",tmp[0]?"null":"invalid",offby1?" (off by one)":""), info3.loc);
                      ^~~~~~
interpret.d:2627:30: error: no member 'sizeof' for type 'uint'
	if(s_t2.getSizeof()==uint.sizeof) tmp[0]=cast(uint)tmp[0], tmp[1]=cast(uint)tmp[1];
                             ^~~~~~~~~~~
interpret.d:2628:39: error: no member 'sizeof' for type 'ulong'
	else assert(s_t2.getSizeof()==ulong.sizeof);
                                      ^~~~~~~~~~~~
interpret.d:2630:31: error: undefined identifier 'format'
		handler.error(format("slice indices [%dU..%dU] are out of bounds [0U..%dU]",tmp[0],tmp[1],tmp[2]),info4.loc);
                              ^~~~~~
interpret.d:2633:31: error: undefined identifier 'format'
		handler.error(format("lower slice index %dU exceeds upper slice index %dU",tmp[0],tmp[1]),info4.loc);
                              ^~~~~~
interpret.d:2638:31: error: cannot cast expression 'info5' of type 'Node' to 'CallExp'
	assert(!!cast(CallExp)info5);
                              ^~~~~
interpret.d:2639:43: error: cannot cast expression 'info5' of type 'Node' to 'void*'
	auto ce = cast(CallExp)cast(void*)info5;
                                          ^~~~~
interpret.d:2640:23: error: undefined identifier 'format'
	handler.error(format("null %s dereference", ce.e.type.isDelegateTy?"delegate":"function pointer"),ce.loc);
                      ^~~~~~
interpret.d:2644:31: error: cannot cast expression 'castinfo' of type 'Node' to 'CastExp'
	assert(!!cast(CastExp)castinfo);
                              ^~~~~~~~
interpret.d:2645:44: error: cannot cast expression 'castinfo' of type 'Node' to 'void*'
	auto cae = cast(CastExp)cast(void*)castinfo;
                                           ^~~~~~~~
interpret.d:2646:40: error: cannot cast expression 'tmp[0]' of type 'ulong' to 'void*'
	auto t1 = cast(Type)cast(void*)tmp[0];
                                       ^~~~~~
interpret.d:2647:23: error: undefined identifier 'format'
	handler.error(format("cannot interpret cast from '%s' aliasing a '%s' to '%s' at compile time", cae.e.type,t1,cae.type), cae.loc); // TODO: 'an'
                      ^~~~~~
interpret.d:2654:53: error: cannot cast expression 'obtainErrorInfo()' of type 'Node' to 'void*'
	auto hltinfo = cast(HltErrorInfo)cast(void*)obtainErrorInfo();
                                                    ^~~~~~~~~~~~~~~~~
interpret.d:2659:9: error: undefined identifier 'string'
	string err = cast(string)stack.pop!BCSlice().slice;
        ^~~~~~
variant.d:408:40: error: undefined identifier 'string'
			foreach(T;Seq!(string,wstring,dstring)){
                                       ^~~~~~
<mixin@semantic.d:7994>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:8118:93: error: undefined identifier 'lsc'
			if(e1.sstate == SemState.completed){e1=e1.convertTo(bl);e1.semantic(lsc);}// TODO: ditto
                                                                                            ^~~
semantic.d:6405:31: error: undefined identifier 'isDelegateTy'
		if(auto dgt = isDelegateTy()) return dgt.ft;
                              ^~~~~~~~~~~~
variant.d:146:20: error: no member 'isDelegateTy' for type 'Type'
		if(tu.isDelegateTy()) return Occupies.dg;
                   ^~~~~~~~~~~~~~~
semantic.d:6358:49: error: no member 'getImmutable' for type 'Type'
		if(stc&STCimmutable)        r = r.getImmutable();
                                                ^~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:3160>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:3160>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:6162>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
semantic.d:6406:31: error: undefined identifier 'isPointerTy'
		if(auto fpt = isPointerTy())  return fpt.ty.isFunctionTy();
                              ^~~~~~~~~~~
interpret.d:986:28: error: no member 'sizeof' for type 'ulong'
		enum sz = (ulong.sizeof-1+T.sizeof)/ulong.sizeof;
                           ^~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
interpret.d:986:43: error: no member 'sizeof' for type 'BCSlice'
		enum sz = (ulong.sizeof-1+T.sizeof)/ulong.sizeof;
                                          ^~~~~~~~
interpret.d:986:53: error: no member 'sizeof' for type 'ulong'
		enum sz = (ulong.sizeof-1+T.sizeof)/ulong.sizeof;
                                                    ^~~~~~~~~~~~
variant.d:408:47: error: undefined identifier 'wstring'
			foreach(T;Seq!(string,wstring,dstring)){
                                              ^~~~~~~
interpret.d:988:27: error: no member 'alignof' for type 'BCSlice'
		static if(T.alignof<=ulong.alignof)
                          ^~~~~~~~~
variant.d:148:28: error: template 'isBasicType' is not callable
		if(auto bt=tu.isBasicType()){
                           ^~~~~~~~~~~~~~~~
interpret.d:988:38: error: no member 'alignof' for type 'ulong'
		static if(T.alignof<=ulong.alignof)
                                     ^~~~~~~~~~~~~
<mixin@<mixin@semantic.d:6162>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3540:30: error: template 'isBasicType' is not callable
		if(auto bt = tu.isBasicType()){
                             ^~~~~~~~~~~~~~~~
variant.d:149:25: error: unimplemented feature SwitchStm
			switch(bt.op){
                        ^~~~~~~~~~~~~~
interpret.d:2659:34: note: instantiated here
	string err = cast(string)stack.pop!BCSlice().slice;
                                 ^~~~~~~~~~~~~~~~~
interpret.d:2662:9: error: feature not implemented
	throw new UnwindException();
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:7996:17: error: undefined identifier 'size_t'
		size_t initial = current;
                ^~~~~~
semantic.d:7996:34: error: undefined identifier 'current'
		size_t initial = current;
                                 ^~~~~~~
semantic.d:11118:31: error: undefined identifier 'ImplConvertsTo'
			mixin(ImplConvertsTo!q{bool icd; a[0], t});
                              ^~~~~~~~~~~~~~
semantic.d:11118:31: error: undefined identifier 'ImplConvertsTo'
			mixin(ImplConvertsTo!q{bool icd; a[0], t});
                              ^~~~~~~~~~~~~~
semantic.d:8077:81: error: undefined identifier 'lsc'
		if(e.sstate == SemState.completed){e=e.convertTo(bl);e.semantic(lsc);} // TODO: ditto
                                                                                ^~~
<mixin@semantic.d:6162>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
variant.d:161:55: error: no member 'text' for type 'Type'
		assert(tu is Type.get!(typeof(null)), tu.text);
                                                      ^~~~~~~
variant.d:408:55: error: undefined identifier 'dstring'
			foreach(T;Seq!(string,wstring,dstring)){
                                                      ^~~~~~~
variant.d:425:35: error: template 'isBasicType' is not callable
		}else if(auto tbt=type.isBasicType()){
                                  ^~~~~~~~~~~~~~~~~~
variant.d:426:38: error: template 'isBasicType' is not callable
			if(auto bt = tou.isBasicType()){
                                     ^~~~~~~~~~~~~~~~~
variant.d:427:33: error: unimplemented feature SwitchStm
				switch(tbt.op){
                                ^~~~~~~~~~~~~~~
variant.d:447:26: error: no member 'isDynArrTy' for type 'Type'
		}else if(type.isDynArrTy()){
                         ^~~~~~~~~~~~~~~
variant.d:450:33: error: undefined identifier 'string'
				string s;
                                ^~~~~~
variant.d:451:44: error: no member 'arr' for type 'Variant'
				foreach(x; this.arr) s~=cast(char)x.int64;
                                           ^~~~~~~~
variant.d:454:33: error: undefined identifier 'wstring'
				wstring s;
                                ^~~~~~~
variant.d:455:44: error: no member 'arr' for type 'Variant'
				foreach(x; this.arr) s~=cast(wchar)x.int64;
                                           ^~~~~~~~
variant.d:458:33: error: undefined identifier 'dstring'
				dstring s;
                                ^~~~~~~
variant.d:459:44: error: no member 'arr' for type 'Variant'
				foreach(x; this.arr) s~=cast(wchar)x.int64;
                                           ^~~~~~~~
variant.d:464:40: error: undefined identifier 'arr'
			return Variant(arr,cnt,to);
                                       ^~~
variant.d:464:44: error: undefined identifier 'cnt'
			return Variant(arr,cnt,to);
                                           ^~~
variant.d:466:32: error: no member 'isDynArrTy' for type 'Type'
			assert(tou.isDynArrTy()||tou.isArrayTy()&&tou.isArrayTy().length==0);
                               ^~~~~~~~~~~~~~
variant.d:466:50: error: no member 'isArrayTy' for type 'Type'
			assert(tou.isDynArrTy()||tou.isArrayTy()&&tou.isArrayTy().length==0);
                                                 ^~~~~~~~~~~~~
variant.d:466:67: error: no member 'isArrayTy' for type 'Type'
			assert(tou.isDynArrTy()||tou.isArrayTy()&&tou.isArrayTy().length==0);
                                                                  ^~~~~~~~~~~~~
variant.d:467:28: error: cannot cast expression 'tou.isSomeString()' of type 'Type' to 'bool'
			if(tou.isSomeString()){
                           ^~~~~~~~~~~~~~~~~~
variant.d:468:48: error: undefined identifier 'string'
				foreach(T;Seq!(string,wstring,dstring))
                                               ^~~~~~
variant.d:468:55: error: undefined identifier 'wstring'
				foreach(T;Seq!(string,wstring,dstring))
                                                      ^~~~~~~
variant.d:468:63: error: undefined identifier 'dstring'
				foreach(T;Seq!(string,wstring,dstring))
                                                              ^~~~~~~
variant.d:471:40: error: no member 'init' for type 'Variant[]'
			return Variant((Variant[]).init,(Variant[]).init,to);
                                       ^~~~~~~~~~~~~~~~
variant.d:471:57: error: no member 'init' for type 'Variant[]'
			return Variant((Variant[]).init,(Variant[]).init,to);
                                                        ^~~~~~~~~~~~~~~~
variant.d:472:26: error: no member 'isPointerTy' for type 'Type'
		}else if(type.isPointerTy()){
                         ^~~~~~~~~~~~~~~~
variant.d:473:67: error: undefined identifier 'cnt'
			if(tou is Type.get!bool()) return Variant(cnt !is null,to); // TODO: fix?
                                                                  ^~~
semantic.d:6359:24: error: undefined identifier 'STCconst'
		if(stc&STCconst||stc&STCin) r = r.getConst();
                       ^~~~~~~~
<mixin@<mixin@semantic.d:4125>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:4125>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
semantic.d:11119:28: error: undefined identifier 'icd'
			if(icd) which=cast(int)i+1;
                           ^~~
semantic.d:11119:28: error: undefined identifier 'icd'
			if(icd) which=cast(int)i+1;
                           ^~~
expression.d:529:18: error: undefined identifier 'string'
	override string toString(){return "void";}
                 ^~~~~~
<mixin@<mixin@semantic.d:11123>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:11123>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:11123>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:11123>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8122:20: error: cannot cast expression 'e2' of type 'Expression' to 'bool'
		if(e2){
                   ^~
semantic.d:8123:37: error: undefined identifier 'lsc'
			e2.semantic(lsc); // TODO: ditto
                                    ^~~
semantic.d:8129:20: error: cannot cast expression 's1' of type 'Statement' to 'bool'
		if(s1) mixin(PropErr!q{s1});
                   ^~
semantic.d:9064:21: error: cannot cast expression 'a[0].interpretV()' of type 'Variant' to 'bool'
		if(!a[0].interpretV()){
                    ^~~~~~~~~~~~~~~~~
semantic.d:8054:20: error: cannot cast expression 's2' of type 'Statement' to 'bool'
		if(s2){
                   ^~
semantic.d:6359:38: error: undefined identifier 'STCin'
		if(stc&STCconst||stc&STCin) r = r.getConst();
                                     ^~~~~
semantic.d:11127:45: error: no member 'getImmutable' for type 'Type[3]'
			a[0]=a[0].convertTo(t.getImmutable());
                                            ^~~~~~~~~~~~~~
semantic.d:11127:45: error: no member 'getImmutable' for type 'Type[3]'
			a[0]=a[0].convertTo(t.getImmutable());
                                            ^~~~~~~~~~~~~~
semantic.d:9067:42: error: undefined identifier 'format'
				sc.error(format("static assertion failure: '%s' is false",a[0].loc.rep), loc);
                                         ^~~~~~
<mixin@<mixin@semantic.d:8002>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8002>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:9070:30: error: unimplemented feature TryStm
			else try{
                             ^~~~
<mixin@<mixin@semantic.d:9077>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:9077>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
parser.d:1303:24: error: undefined identifier 'res'
		return res=New!FunctionLiteralExp(New!FunctionTy(stc,ret,params,vararg),bdy,kind);
                       ^~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
parser.d:182:21: error: no member 'stringof' for type 'CompoundStm'
	enum SetLoc=T.stringof~q{
                    ^~~~~~~~~~
statement.d:39:18: error: undefined identifier 'string'
	override string toString(){return "{\n"~indent(join(map!(to!string)(s),"\n"))~"\n}";}
                 ^~~~~~
parser.d:1076:23: note: instantiated here
		mixin(SetLoc!CompoundStm);
                      ^~~~~~~~~~~~~~~~~~
parser.d:1077:24: error: undefined identifier 'res'
		return res=New!CompoundStm(parseCompoundStmHelper());
                       ^~~
semantic.d:8130:20: error: cannot cast expression 'e1' of type 'Expression' to 'bool'
		if(e1) mixin(PropErr!q{e1});
                   ^~
semantic.d:8131:20: error: cannot cast expression 'e2' of type 'Expression' to 'bool'
		if(e2) mixin(PropErr!q{e2});
                   ^~
<mixin@<mixin@semantic.d:9079>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:9079>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
declaration.d:164:18: error: undefined identifier 'string'
	override string toString(){return (stc?STCtoString(astStc)~" ":"")~"static assert("~join(map!(to!string)(a),",")~");";}
                 ^~~~~~
declaration.d:163:51: error: current object 'super' of type 'Declaration' is not callable
	this(STC stc,Expression[] args){a = args; super(stc,null);}
                                                  ^~~~~~~~~~~~~~~
semantic.d:11133:50: error: undefined identifier 'string'
		auto str = a[0].interpretV().get!string();
                                                 ^~~~~~
semantic.d:6359:49: error: no member 'getConst' for type 'Type'
		if(stc&STCconst||stc&STCin) r = r.getConst();
                                                ^~~~~~~~~~
semantic.d:11133:50: error: undefined identifier 'string'
		auto str = a[0].interpretV().get!string();
                                                 ^~~~~~
semantic.d:8055:29: error: undefined identifier 'esc'
			if(!esc) esc = New!BlockScope(sc);
                            ^~~
semantic.d:8055:34: error: undefined identifier 'esc'
			if(!esc) esc = New!BlockScope(sc);
                                 ^~~
<mixin@<mixin@semantic.d:8082>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8082>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8100>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8100>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
semantic.d:6360:24: error: undefined identifier 'STCinout'
		if(stc&STCinout)            r = r.getInout();
                       ^~~~~~~~
<mixin@<mixin@semantic.d:8133>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8133>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
statement.d:87:18: error: undefined identifier 'string'
	override string toString(){return "while(" ~ e.toString() ~ ") "~s.toString();}
                 ^~~~~~
statement.d:94:18: error: undefined identifier 'string'
	override string toString(){return "do "~s.toString()~"while("~e.toString()~");";}
                 ^~~~~~
statement.d:102:18: error: undefined identifier 'string'
	override string toString(){return "for("~s1.toString()~(e1?e1.toString():"")~";"~(e2?e2.toString():"")~") "~s2.toString();}
                 ^~~~~~
semantic.d:11136:41: error: undefined identifier 'format'
		Source src = New!Source(format("<mixin@%s:%d>",loc.source.name,loc.line), str); // TODO: column?
                                        ^~~~~~
semantic.d:11136:41: error: undefined identifier 'format'
		Source src = New!Source(format("<mixin@%s:%d>",loc.source.name,loc.line), str); // TODO: column?
                                        ^~~~~~
<mixin@<mixin@semantic.d:11153>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:11153>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
statement.d:262:18: error: undefined identifier 'string'
	override string toString(){return "mixin("~join(map!(to!string)(a),",")~");";}
                 ^~~~~~
semantic.d:6360:49: error: no member 'getInout' for type 'Type'
		if(stc&STCinout)            r = r.getInout();
                                                ^~~~~~~~~~
<mixin@<mixin@semantic.d:8060>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8060>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:11153>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:11153>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
statement.d:70:18: error: undefined identifier 'string'
	override string toString(){return "if(" ~ e.toString() ~ ") "~s1.toString()~(s2!is null?(cast(BlockStm)s1?"":"\n")~"else "~s2.toString():"");}
                 ^~~~~~
semantic.d:6361:24: error: undefined identifier 'STCshared'
		if(stc&STCshared)           r = r.getShared();
                       ^~~~~~~~~
semantic.d:6361:49: error: no member 'getShared' for type 'Type'
		if(stc&STCshared)           r = r.getShared();
                                                ^~~~~~~~~~~
interpret.d:5365:52: error: type 'VarDecl' is not an expression
	private static void[] buildContext(Variant[VarDecl] vars, FunctionDef fd){
                                                   ^~~~~~~
interpret.d:5423:32: error: type 'VarDecl' is not an expression
	private static Variant[VarDecl] parseContext(void[] mem, FunctionDef fd, bool remember=true){
                               ^~~~~~~
interpret.d:4240:32: error: no member 'isAggregateTy' for type 'Type'
		if(auto aggrty=tu.isAggregateTy()){
                               ^~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
type.d:195:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
type.d:115:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
type.d:190:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
interpret.d:575:56: error: undefined identifier 'to'
		assert(r.getType() is Type.get!bool(), to!string(r.getType()));
                                                       ^~
interpret.d:576:24: error: cannot cast expression 'r' of type 'Variant' to 'bool'
		return r ? e2.interpretV() : e3.interpretV();
                       ^
interpret.d:143:20: error: no member 'isPointerTy' for type 'Type'
		if(type.getHeadUnqual().isPointerTy()){
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:17:78: note: instantiated here
	static if(is(typeof(this):Expression)&&!is(typeof(this):Type)) mixin Interpret!(typeof(this));// TODO: minimize and report bug
                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~
expression.d:479:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
semantic.d:1737:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
interpret.d:5171:38: error: no member 'sizeof' for type 'BCSlice'
		assert(mem.length == BCSlice.sizeof);
                                     ^~~~~~~~~~~~~~
interpret.d:5011:36: error: no member 'sizeof' for type 'BCSlice'
		assert(mem.length==BCSlice.sizeof);
                                   ^~~~~~~~~~~~~~
interpret.d:5005:36: error: no member 'sizeof' for type 'BCSlice'
		assert(mem.length==BCSlice.sizeof);
                                   ^~~~~~~~~~~~~~
interpret.d:5173:20: error: cannot cast expression 'value.getType().getHeadUnqual().isSomeString()' of type 'Type' to 'bool'
		if(value.getType().getHeadUnqual().isSomeString()){
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5012:24: error: incompatible types 'BCSlice' and 'BCSlice' for binary ==
		assert(*(cast(BCSlice*)mem.ptr)==BCSlice([],[]));
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4996:36: error: no member 'sizeof' for type 'BCPointer'
		assert(mem.length==BCPointer.sizeof);
                                   ^~~~~~~~~~~~~~~~
interpret.d:4990:36: error: no member 'sizeof' for type 'BCPointer'
		assert(mem.length==BCPointer.sizeof);
                                   ^~~~~~~~~~~~~~~~
interpret.d:5013:32: error: no member 'init' for type 'Variant[]'
		return Variant((Variant[]).init,(Variant[]).init,type);
                               ^~~~~~~~~~~~~~~~
interpret.d:5013:49: error: no member 'init' for type 'Variant[]'
		return Variant((Variant[]).init,(Variant[]).init,type);
                                                ^~~~~~~~~~~~~~~~
interpret.d:4991:44: error: too many arguments to struct literal (expected zero)
		*(cast(BCPointer*)mem.ptr)=BCPointer([],null);
                                           ^~~~~~~~~~~~~~~~~~
interpret.d:4997:52: error: too many arguments to struct literal (expected zero)
		assert(*(cast(BCPointer*)mem.ptr)==BCPointer([],null));
                                                   ^~~~~~~~~~~~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
type.d:143:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
type.d:136:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
interpret.d:3644:39: error: no member 'sizeof' for type 'Type'
			static assert(Type.sizeof<=ulong.sizeof);
                                      ^~~~~~~~~~~
interpret.d:3644:52: error: no member 'sizeof' for type 'ulong'
			static assert(Type.sizeof<=ulong.sizeof);
                                                   ^~~~~~~~~~~~
interpret.d:3645:64: error: cannot cast expression 'tt' of type 'Type' to 'void*'
			bld.emitConstant(cast(ulong)cast(void*)tt);
                                                               ^~
interpret.d:3647:33: error: no member 'byteCompile' for type 'Expression[]'
		foreach(x; lit) x.byteCompile(bld);
                                ^~~~~~~~~~~~~
interpret.d:5353:56: error: no member 'sizeof' for type 'ulong'
		assert(mem.length==(bcPointerBCSize+1)*ulong.sizeof);
                                                       ^~~~~~~~~~~~
interpret.d:5463:56: error: no member 'sizeof' for type 'ulong'
		assert(mem.length==(bcPointerBCSize+1)*ulong.sizeof);
                                                       ^~~~~~~~~~~~
interpret.d:5465:49: error: cannot cast expression 'ul[$-1]' of type 'ulong' to 'void*'
		auto fun=cast(Symbol)cast(void*)ul[$-1];
                                                ^~~~~~~
interpret.d:5466:55: error: type 'VarDecl' is not an expression
		if(!fun) return Variant(fun, (Variant[VarDecl]).init, type);
                                                      ^~~~~~~
interpret.d:5355:21: error: cannot cast expression 'fun' of type 'Symbol' to 'bool'
		if(!fun){ (cast(byte[])mem)[]=0; return; }
                    ^~~
interpret.d:5355:47: error: cannot implicitly convert constant '0' of type 'int' to 'byte[]'
		if(!fun){ (cast(byte[])mem)[]=0; return; }
                                              ^
interpret.d:5356:41: error: cannot cast expression 'fun.meaning' of type 'Declaration' to 'FunctionDef'
		assert(cast(FunctionDef)fun.meaning);
                                        ^~~~~~~~~~~
interpret.d:5357:55: error: cannot cast expression 'fun.meaning' of type 'Declaration' to 'void*'
		auto fd = cast(FunctionDef)cast(void*)fun.meaning;
                                                      ^~~~~~~~~~~
interpret.d:5469:65: error: no member 'sizeof' for type 'ulong'
		auto vars = parseContext(mem[0..bcPointerBCSize*ulong.sizeof], fd, false);
                                                                ^~~~~~~~~~~~
interpret.d:5359:52: error: no member 'sizeof' for type 'ulong'
		assert(ctx.length==bcPointerBCSize*ulong.sizeof);
                                                   ^~~~~~~~~~~~
interpret.d:5064:20: error: undefined identifier 'ty'
		if(ty.isFunctionTy()){
                   ^~
interpret.d:5065:46: error: no member 'sizeof' for type 'Symbol'
			assert(mem.length == Symbol.sizeof);
                                             ^~~~~~~~~~~~~
variant.d:217:17: error: no member 'fptr' for type 'Variant'
		this.fptr=fptr;
                ^~~~~~~~~
(location missing): instantiated here
interpret.d:5099:20: error: undefined identifier 'ty'
		if(ty.isFunctionTy()){
                   ^~
interpret.d:5100:46: error: no member 'sizeof' for type 'Symbol'
			assert(mem.length == Symbol.sizeof);
                                             ^~~~~~~~~~~~~
interpret.d:5069:36: error: no member 'sizeof' for type 'BCPointer'
		assert(mem.length==BCPointer.sizeof);
                                   ^~~~~~~~~~~~~~~~
interpret.d:4244:46: error: no member 'sizeof' for type 'ulong'
			bld.emitConstant(els*ulong.sizeof);
                                             ^~~~~~~~~~~~
variant.d:260:33: error: undefined identifier 'string'
		static if(is(T==string)){
                                ^~~~~~
interpret.d:144:34: error: undefined identifier 'format'
			sc.error(format("cannot interpret cast from '%s' to '%s' at compile time",e.type,type),loc);
                                 ^~~~~~
interpret.d:5361:24: error: no member 'sizeof' for type 'BCPointer'
		mem[0..BCPointer.sizeof]=(cast(void*)&ptr)[0..BCPointer.sizeof];
                       ^~~~~~~~~~~~~~~~
interpret.d:3801:33: error: need 'this' to access member function 'FieldExp.byteCompileVirtualCall'
				FieldExp.byteCompileVirtualCall(bld, raggr, fd, this);
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3887:9: note: member function was declared here
	static void byteCompileVirtualCall(ref ByteCodeBuilder bld, ReferenceAggregateDecl raggr, FunctionDecl fun, Expression loader){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5071:28: error: undefined identifier 'ty'
		auto slt = ty.getDynArr();
                           ^~
interpret.d:3543:78: note: instantiated here
				if(bt.isSigned()) bld.emitConstant(cast(long)value.get!ulong());
                                                                             ^~~~~~~~~~~~~~~
interpret.d:3805:64: error: cannot cast expression 'this' of type 'Symbol' to 'void*'
			bld.emitConstant(cast(ulong)cast(void*)this);
                                                               ^~~~
interpret.d:3808:27: error: undefined identifier 'format'
		bld.error(format("cannot interpret %s '%s' at compile time%s", kind, loc.rep,
                          ^~~~~~
interpret.d:3544:55: error: could not match call to function template
				else bld.emitConstant(value.get!ulong());
                                                      ^~~~~~~~~~~~~~~~~
interpret.d:5361:63: error: no member 'sizeof' for type 'BCPointer'
		mem[0..BCPointer.sizeof]=(cast(void*)&ptr)[0..BCPointer.sizeof];
                                                              ^~~~~~~~~~~~~~~~
interpret.d:5362:56: error: no member 'sizeof' for type 'ulong'
		*cast(Symbol*)(mem.ptr+bcPointerBCSize*ulong.sizeof)=fun;
                                                       ^~~~~~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
type.d:182:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
semantic.d:2709:31: error: undefined identifier 'types'
	mixin TupleImplConvTo!types;
                              ^~~~~
interpret.d:3649:20: error: no member 'isArrayTy' for type 'Type'
		if(type.getUnqual().isArrayTy()){ // static array literal (TODO: this is a horrible kludge)
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:2678:36: error: undefined identifier 'types'
	final allIndices(){ return types; }
                                   ^~~~~
util.d:305:27: error: no member 'stringof' for type 'TypeTuple'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'TypeTuple'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(AggregateTy)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
semantic.d:2726:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
semantic.d:4524:28: error: undefined identifier 'string'
	override @property string kind(){return meaning.kind;}
                           ^~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
type.d:342:15: note: instantiated here
	mixin DeepDup!AggregateTy; // workaround for DMD bug. Should actually be in visitors.d
              ^~~~~~~~~~~~~~~~~~~
interpret.d:3809:25: error: no member 'isFunctionDecl' for type 'Declaration'
			meaning.isFunctionDecl()?", because it has no available source code":""), loc);
                        ^~~~~~~~~~~~~~~~~~~~~~
semantic.d:4511:18: error: undefined identifier 'string'
	override string toString(){
                 ^~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:4556:37: error: undefined identifier 'STCstatic'
			if(decl.stc&STCstatic) return null;
                                    ^~~~~~~~~
semantic.d:4533:34: error: undefined identifier 'STCstatic'
		if(!(meaning.stc&STCstatic)||meaning.isOverloadSet())
                                 ^~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
semantic.d:4573:30: error: no member 'isVarDecl' for type 'Declaration'
		if(auto vd = meaning.isVarDecl())
                             ^~~~~~~~~~~~~~~~~
semantic.d:4533:46: error: no member 'isOverloadSet' for type 'Declaration'
		if(!(meaning.stc&STCstatic)||meaning.isOverloadSet())
                                             ^~~~~~~~~~~~~~~~~~~~~
semantic.d:4534:20: error: cannot cast expression 'meaning.scope_' of type 'Scope' to 'bool'
		if(meaning.scope_) // eg. parameters inside function types
                   ^~~~~~~~~~~~~~
semantic.d:4535:20: error: cannot cast expression 'auto decl=meaning.scope_.getDeclaration()' of type 'Declaration' to 'bool'
		if(auto decl=meaning.scope_.getDeclaration())
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:4536:30: error: no member 'isAggregateDecl' for type 'Declaration'
		if(auto aggr=decl.isAggregateDecl())
                             ^~~~~~~~~~~~~~~~~~~~
semantic.d:4559:21: error: cannot cast expression 'mfun' of type 'Declaration' to 'bool'
		if(!mfun||!mfun.isFunctionDecl()) return null;
                    ^~~~
semantic.d:4559:28: error: no member 'isFunctionDecl' for type 'Declaration'
		if(!mfun||!mfun.isFunctionDecl()) return null;
                           ^~~~~~~~~~~~~~~~~~~
semantic.d:4560:20: error: cannot cast expression 'auto aggr=scope_.getAggregate()' of type 'AggregateDecl' to 'bool'
		if(auto aggr=scope_.getAggregate())
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5175:40: error: undefined identifier 'string'
			foreach(T;Seq!(string,wstring,dstring)){
                                       ^~~~~~
semantic.d:4625:21: error: cannot cast expression 'this_' of type 'Type' to 'bool'
		if(!this_) this_ = maybeThisContext();
                    ^~~~~
semantic.d:4566:20: error: no member 'isTemplateInstanceDecl' for type 'Declaration'
		if(meaning.isTemplateInstanceDecl()) return accessCheck;
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:590:60: error: undefined identifier 'min'
					self.accessCheck = min(self.accessCheck, check);
                                                           ^~~
semantic.d:3231:20: error: undefined identifier 'matchOnly'
		if(matchOnly) sym.makeWeak(); // do not propagate errors
                   ^~~~~~~~~
semantic.d:4670:18: error: undefined identifier 'size_t'
	override size_t tmplArgToHash(){
                 ^~~~~~
variant.d:260:33: error: undefined identifier 'string'
		static if(is(T==string)){
                                ^~~~~~
semantic.d:4626:20: error: no member 'isVarDecl' for type 'Declaration'
		if(meaning.isVarDecl()) return super.matchError(sc, loc, this_, args);
                   ^~~~~~~~~~~~~~~~~
semantic.d:3236:20: error: cannot cast expression 'container' of type 'Expression' to 'bool'
		if(container && !isMixin){
                   ^~~~~~~~~
semantic.d:3239:25: error: no member 'res' for type 'TemplateInstanceExp'
			this.res = res;
                        ^~~~~~~~
semantic.d:3240:23: error: undefined identifier 'res'
		}else res = sym;
                      ^~~
semantic.d:3244:25: error: undefined identifier 'eponymous'
			eponymous=New!Identifier(decl.name.name);
                        ^~~~~~~~~
semantic.d:3245:25: error: undefined identifier 'eponymous'
			eponymous.loc=loc;
                        ^~~~~~~~~
semantic.d:3246:25: error: undefined identifier 'eponymous'
			eponymous.accessCheck=accessCheck;
                        ^~~~~~~~~
interpret.d:3883:31: error: no member 'sizeof' for type 'Symbol'
		static assert(e2.sizeof<=(void*).sizeof&&(void*).sizeof<=ulong.sizeof);
                              ^~~~~~~~~
interpret.d:3883:42: error: no member 'sizeof' for type 'void*'
		static assert(e2.sizeof<=(void*).sizeof&&(void*).sizeof<=ulong.sizeof);
                                         ^~~~~~~~~~~~~~
interpret.d:3884:56: error: cannot cast expression 'e2' of type 'Symbol' to 'void*'
		bld.emitConstant(cast(ulong)cast(void*)e2);
                                                       ^~
interpret.d:3548:50: note: instantiated here
				bld.emitConstant(value.get!float());
                                                 ^~~~~~~~~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:17:78: note: instantiated here
	static if(is(typeof(this):Expression)&&!is(typeof(this):Type)) mixin Interpret!(typeof(this));// TODO: minimize and report bug
                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
expression.d:293:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
semantic.d:4601:32: error: undefined identifier 'STCproperty'
		if(meaning.stc&STCproperty) return true;
                               ^~~~~~~~~~~
semantic.d:4488:88: error: undefined identifier 'STCproperty'
		return implcalldecl && (implicitCall || !ignoreProperty && meaning.stc&STCproperty);
                                                                                       ^~~~~~~~~~~
semantic.d:5269:26: error: undefined identifier 'format'
		sc.error(format("cannot implicitly convert function literal to '%s'",type.toString()),loc);
                         ^~~~~~
semantic.d:4574:39: error: undefined identifier 'STCenum'
			return vd.stc&STCenum
                                      ^~~~~~~
semantic.d:4582:68: error: undefined identifier 'STCenum'
		if(auto vd = meaning.isVarDecl()) return !!(vd.stc&STCenum);
                                                                   ^~~~~~~
semantic.d:4234:26: error: cannot implicitly convert function call result 'ddup()' of type 'Expression' to 'Symbol'
		Symbol r=ddup();
                         ^~~~~~
analyze.d:44:19: error: feature expression.TraitsExp not implemented
	static if(__traits(hasMember,T,"manualPropagate") && T.manualPropagate)
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:4575:44: error: undefined identifier 'STCimmutable'
				|| vd.stc&(STCimmutable|STCconst)
                                           ^~~~~~~~~~~~
analyze.d:48:26: error: feature expression.TraitsExp not implemented
	alias TypeTuple!(__traits(getOverloads,T,"perform")) overloads;
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:4575:57: error: undefined identifier 'STCconst'
				|| vd.stc&(STCimmutable|STCconst)
                                                        ^~~~~~~~
semantic.d:4577:30: error: no member 'isFunctionDecl' for type 'Declaration'
		if(auto vd = meaning.isFunctionDecl()) return true;
                             ^~~~~~~~~~~~~~~~~~~~~~
analyze.d:52:28: error: undefined identifier 'manualPropagate'
		static if(!manualPropagate) node._doAnalyze(&runIt);
                           ^~~~~~~~~~~~~~~
<mixin@semantic.d:4248>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
semantic.d:4594:48: error: no member 'isVarDecl' for type 'Declaration'
		if(!(meaning.stc&STCrvalue) && meaning.isVarDecl()) return true;
                                               ^~~~~~~~~~~~~~~~~
semantic.d:4595:31: error: no member 'isOverloadSet' for type 'Declaration'
		   if(auto ov=meaning.isOverloadSet())
                              ^~~~~~~~~~~~~~~~~~~~~
semantic.d:4597:29: error: no member 'isFunctionDecl' for type 'Declaration'
		   return !!meaning.isFunctionDecl();
                            ^~~~~~~~~~~~~~~~~~~~~~
analyze.d:61:20: error: undefined identifier 'manualPropagate'
	static if(!manualPropagate) return result;
                   ^~~~~~~~~~~~~~~
semantic.d:603:25: note: instantiated here
			runAnalysis!WeakenCheckM(this);
                        ^~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:4208:46: error: undefined identifier 'iota'
				auto first = iota(0,clist.length).reduce!((a,b)=>clist[a].sourcePriority<clist[b].sourcePriority?a:b);
                                             ^~~~
semantic.d:4496:23: error: undefined identifier 'IsDeclAccessible'
		mixin(IsDeclAccessible!q{auto b; Declaration, decl, meaning});
                      ^~~~~~~~~~~~~~~~
<mixin@interpret.d:2987>:2:12: error: undefined identifier 'dollar'
	if(dollar){
           ^~~~~~
<mixin@interpret.d:2987>:3:17: error: undefined identifier 'dollar'
		dollar.byteCompile(bld);
                ^~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
semantic.d:608:60: error: undefined identifier 'min'
					self.accessCheck = min(self.accessCheck, check);
                                                           ^~~
semantic.d:617:60: error: undefined identifier 'min'
					self.accessCheck = min(self.accessCheck, check);
                                                           ^~~
<mixin@<mixin@semantic.d:4248>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:4250:21: error: cannot cast expression 'scope_' of type 'Scope' to 'bool'
		if(!scope_) scope_=sc;
                    ^~~~~~
semantic.d:4251:24: error: cannot cast expression 'meaning' of type 'Declaration' to 'bool'
		assert(meaning && scope_);
                       ^~~~~~~
semantic.d:4251:35: error: cannot cast expression 'scope_' of type 'Scope' to 'bool'
		assert(meaning && scope_);
                                  ^~~~~~
semantic.d:4257:28: error: no member 'isTemplateInstanceDecl' for type 'Declaration'
			if(meaning.isTemplateInstanceDecl()){
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:4264:33: error: cannot cast expression 'circ' of type 'Symbol' to 'bool'
			assert(!circ,toString());
                                ^~~~
analyze.d:44:19: error: feature expression.TraitsExp not implemented
	static if(__traits(hasMember,T,"manualPropagate") && T.manualPropagate)
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:47:23: error: too many arguments to struct literal (expected zero)
	auto result = T(args);
                      ^~~~~~~
analyze.d:48:26: error: feature expression.TraitsExp not implemented
	alias TypeTuple!(__traits(getOverloads,T,"perform")) overloads;
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:52:28: error: undefined identifier 'manualPropagate'
		static if(!manualPropagate) node._doAnalyze(&runIt);
                           ^~~~~~~~~~~~~~~
analyze.d:61:20: error: undefined identifier 'manualPropagate'
	static if(!manualPropagate) return result;
                   ^~~~~~~~~~~~~~~
semantic.d:620:25: note: instantiated here
			runAnalysis!WeakenCheck(this,check);
                        ^~~~~~~~~~~~~~~~~~~~~~~
semantic.d:4497:62: error: undefined identifier 'b'
		if(meaning.needsAccessCheck(accessCheck) && !b){
                                                             ^
semantic.d:4209:41: error: undefined identifier 'chain'
				clist = chain(clist[first..$],clist[0..first]).array;
                                        ^~~~~
semantic.d:4499:28: error: no member 'isFunctionDef' for type 'Declaration'
			if(meaning.scope_.getDeclaration().isFunctionDef())
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:4500:46: error: undefined identifier 'format'
				scope_.error(format("cannot access the frame in which '%s' is stored", loc.rep),loc);
                                             ^~~~~~
semantic.d:4503:46: error: undefined identifier 'format'
				scope_.error(format("need 'this' to access %s '%s'",kind,loc.rep),loc);
                                             ^~~~~~
semantic.d:4505:37: error: undefined identifier 'format'
			scope_.note(format("%s was declared here",kind),meaning.loc);
                                    ^~~~~~
semantic.d:4277:28: error: no member 'isAliasDecl' for type 'Declaration'
		if(auto al=meaning.isAliasDecl()){
                           ^~~~~~~~~~~~~~~~~~~
variant.d:182:17: error: no member 'arr' for type 'Variant'
		this.arr=arr;
                ^~~~~~~~
variant.d:183:17: error: no member 'cnt' for type 'Variant'
		this.cnt=cnt;
                ^~~~~~~~
(location missing): instantiated here
semantic.d:4218:36: error: no member 'loc' for type 'Symbol[]'
				if(x.loc.line) errsc.note("part of dependency cycle",x.loc);
                                   ^~~~~
semantic.d:4218:86: error: no member 'loc' for type 'Symbol[]'
				if(x.loc.line) errsc.note("part of dependency cycle",x.loc);
                                                                                     ^~~~~
<mixin@<mixin@semantic.d:4506>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:4506>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:4279>:1:4: error: cannot cast expression 'circ' of type 'Symbol' to 'bool'
if(circ){circErrMsg(); mixin(SemCheck);}
   ^~~~
semantic.d:4291:23: error: undefined identifier 'util'
		alias util.any any;
                      ^~~~
semantic.d:4293:28: error: no member 'isFunctionDecl' for type 'Declaration'
		if(auto fd=meaning.isFunctionDecl()){
                           ^~~~~~~~~~~~~~~~~~~~~~
semantic.d:4299:28: error: no member 'isSymbolMatcher' for type 'Declaration'
			if(meaning.isSymbolMatcher()){
                           ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:4301>:1:4: error: cannot cast expression 'circ' of type 'Symbol' to 'bool'
if(circ){circErrMsg(); mixin(SemCheck);}
   ^~~~
semantic.d:4302:36: error: cannot cast expression 'meaning.rewrite' of type 'Node' to 'bool'
				if(meaning.rewrite)
                                   ^~~~~~~~~~~~~~~
semantic.d:4303:83: error: cannot cast expression 'meaning' of type 'Declaration' to 'void*'
					inoutRes = (cast(SymbolMatcher)cast(void*)meaning)
                                                                                  ^~~~~~~
<mixin@semantic.d:4313>:1:4: error: cannot cast expression 'circ' of type 'Symbol' to 'bool'
if(circ){circErrMsg(); mixin(SemCheck);}
   ^~~~
semantic.d:4320:28: error: no member 'isVarDecl' for type 'Declaration'
		if(auto vd=meaning.isVarDecl()){
                           ^~~~~~~~~~~~~~~~~
semantic.d:4321:37: error: undefined identifier 'STCenum'
			if(vd.stc & STCenum || (vd.init&&vd.stc&(STCimmutable|STCconst)&&vd.willInterpretInit())){
                                    ^~~~~~~
semantic.d:4321:66: error: undefined identifier 'STCimmutable'
			if(vd.stc & STCenum || (vd.init&&vd.stc&(STCimmutable|STCconst)&&vd.willInterpretInit())){
                                                                 ^~~~~~~~~~~~
semantic.d:4321:79: error: undefined identifier 'STCconst'
			if(vd.stc & STCenum || (vd.init&&vd.stc&(STCimmutable|STCconst)&&vd.willInterpretInit())){
                                                                              ^~~~~~~~
<mixin@semantic.d:4323>:1:4: error: cannot cast expression 'circ' of type 'Symbol' to 'bool'
if(circ){circErrMsg(); mixin(SemCheck);}
   ^~~~
<mixin@semantic.d:4327>:1:4: error: cannot cast expression 'circ' of type 'Symbol' to 'bool'
if(circ){circErrMsg(); mixin(SemCheck);}
   ^~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
type.d:286:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
semantic.d:2692:28: error: undefined identifier 'types'
		foreach(x; types) if(auto r = dg(x)) return r;
                           ^~~~~
semantic.d:2689:56: error: cannot cast expression 'dg' of type 'int delegate(Expression)' to 'int delegate(Type)'
		return opApply(cast(int delegate(Type))dg);
                                                       ^~
interpret.d:5074:17: error: undefined identifier 'size_t'
		size_t offset = parseFieldAccess(fa,slt);
                ^~~~~~
variant.d:260:33: error: undefined identifier 'string'
		static if(is(T==string)){
                                ^~~~~~
interpret.d:5077:17: error: undefined identifier 'size_t'
	private size_t parseFieldAccess(scope FieldAccess[] fa,Type type){
                ^~~~~~
interpret.d:3552:50: note: instantiated here
				bld.emitConstant(value.get!double());
                                                 ^~~~~~~~~~~~~~~~
interpret.d:4247:58: error: undefined identifier 'scope_'
			aggrty.decl.byteCompileInit(bld, scope_); // TODO: context is null
                                                         ^~~~~~
interpret.d:4252:28: error: undefined identifier 'consCall'
			if(consCall){
                           ^~~~~~~~
interpret.d:4254:33: error: undefined identifier 'consCall'
				consCall.byteCompile(bld);
                                ^~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
interpret.d:5175:47: error: undefined identifier 'wstring'
			foreach(T;Seq!(string,wstring,dstring)){
                                              ^~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(BlockStm)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
statement.d:46:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
variant.d:260:33: error: undefined identifier 'string'
		static if(is(T==string)){
                                ^~~~~~
visitors.d:26:65: error: instantiation of template 'DeepDup' is ambiguous
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:37:1: note: candidate template
mixin template DeepDup(T) if(is(T: Node) && !is(T: BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:96:1: note: candidate template
mixin template DeepDup(T: Symbol) {
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: error: instantiation of template 'DeepDup' is ambiguous
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:37:1: note: candidate template
mixin template DeepDup(T) if(is(T: Node) && !is(T: BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:96:1: note: candidate template
mixin template DeepDup(T: Symbol) {
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@interpret.d:2987>:10:30: error: undefined identifier 'dollar'
		auto strat = dollar.byteCompileSymbolLV(bld,this,ascope);
                             ^~~~~~
interpret.d:3556:50: note: instantiated here
				bld.emitConstant(value.get!real());
                                                 ^~~~~~~~~~~~~~
interpret.d:3559:35: error: no member 'isArrayTy' for type 'Type'
		}else if(auto arr=tu.isArrayTy()){
                                  ^~~~~~~~~~~~
visitors.d:26:65: error: instantiation of template 'DeepDup' is ambiguous
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:37:1: note: candidate template
mixin template DeepDup(T) if(is(T: Node) && !is(T: BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:96:1: note: candidate template
mixin template DeepDup(T: Symbol) {
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5175:55: error: undefined identifier 'dstring'
			foreach(T;Seq!(string,wstring,dstring)){
                                                      ^~~~~~~
interpret.d:5187:28: error: could not match call to function template
		auto arr = value.get!(Variant[])();
                           ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
type.d:260:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
interpret.d:3565:35: error: no member 'isDynArrTy' for type 'Type'
		}else if(auto dyn=tu.isDynArrTy()){
                                  ^~~~~~~~~~~~~
interpret.d:4355:28: error: undefined identifier 'type'
		if(auto tp=type.isTypeTuple()){
                           ^~~~
<mixin@interpret.d:2987>:10:66: error: undefined identifier 'ascope'
		auto strat = dollar.byteCompileSymbolLV(bld,this,ascope);
                                                                 ^~~~~~
interpret.d:5191:43: error: undefined identifier 'ty'
		auto ctsize = getCTSizeof(ty);
                                          ^~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(ErrorDecl)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
declaration.d:72:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
declaration.d:70:24: error: cannot cast expression 'err' of type 'ErrorDecl' to 'bool'
		return err?err:(err=New!ErrorDecl);
                       ^~~
interpret.d:2991:27: error: undefined identifier 'size_t'
		static if(size_t.sizeof>uint.sizeof){
                          ^~~~~~
interpret.d:2991:41: error: no member 'sizeof' for type 'uint'
		static if(size_t.sizeof>uint.sizeof){
                                        ^~~~~~~~~~~
interpret.d:2999:31: error: no member 'isPointerTy' for type 'Type'
		if(auto ptr = e.type.getHeadUnqual().isPointerTy()){
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3567:71: error: no member 'sizeof' for type 'BCSlice'
			dyn.variantToMemory(value, (cast(void*)&r)[0..BCSlice.sizeof]);
                                                                      ^~~~~~~~~~~~~~
interpret.d:3008:35: error: undefined identifier 'size_t'
			static if(size_t.sizeof>uint.sizeof){
                                  ^~~~~~
interpret.d:3008:49: error: no member 'sizeof' for type 'uint'
			static if(size_t.sizeof>uint.sizeof){
                                                ^~~~~~~~~~~
interpret.d:3018:35: error: undefined identifier 'size_t'
			static if(size_t.sizeof>uint.sizeof){
                                  ^~~~~~
interpret.d:3018:49: error: no member 'sizeof' for type 'uint'
			static if(size_t.sizeof>uint.sizeof){
                                                ^~~~~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:403:20: error: undefined identifier 'ascope'
		if(ascope.dollar){
                   ^~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
interpret.d:4356:32: error: undefined identifier 'tupleContext'
			assert(tupleContext && tupleContext.vds.length == tp.length);
                               ^~~~~~~~~~~~
interpret.d:4356:48: error: undefined identifier 'tupleContext'
			assert(tupleContext && tupleContext.vds.length == tp.length);
                                               ^~~~~~~~~~~~
interpret.d:4357:35: error: undefined identifier 'tupleContext'
			foreach(x;tupleContext.vds){
                                  ^~~~~~~~~~~~
interpret.d:4364:17: error: undefined identifier 'size_t'
		size_t off, len = getBCSizeof(type);
                ^~~~~~
interpret.d:3036:35: error: undefined identifier 'format'
			bld.error(format("assertion failure: %s is false", a[0].loc.rep),loc);
                                  ^~~~~~
interpret.d:4364:17: error: undefined identifier 'size_t'
		size_t off, len = getBCSizeof(type);
                ^~~~~~
interpret.d:3569:25: error: undefined identifier 'size_t'
			size_t size = getBCSizeof(tu.getElementType().getDynArr());
                        ^~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
type.d:269:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
type.d:266:18: error: undefined identifier 'string'
	override string toString(){return _brk(e.toString()~"[]");}
                 ^~~~~~
interpret.d:4528:29: error: undefined identifier 'size_t'
	final void setBCLoc(size_t off, size_t len){
                            ^~~~~~
interpret.d:4528:41: error: undefined identifier 'size_t'
	final void setBCLoc(size_t off, size_t len){
                                        ^~~~~~
interpret.d:4534:35: error: undefined identifier 'size_t'
	final size_t getBCLoc(ref size_t len){
                                  ^~~~~~
interpret.d:4534:15: error: undefined identifier 'size_t'
	final size_t getBCLoc(ref size_t len){
              ^~~~~~
interpret.d:3569:51: error: no member 'getDynArr' for type 'Type'
			size_t size = getBCSizeof(tu.getElementType().getDynArr());
                                                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3572:72: error: cannot cast expression 'value.getType()' of type 'Type' to 'void*'
				bld.emitConstant(cast(ulong)cast(void*)value.getType());
                                                                       ^~~~~~~~~~~~~~~
interpret.d:4364:47: error: undefined identifier 'type'
		size_t off, len = getBCSizeof(type);
                                              ^~~~
interpret.d:4367:29: error: cannot cast expression 'init' of type 'Expression' to 'bool'
		if(auto ini=init?init.isStructConsExp():null){
                            ^~~~
interpret.d:4367:34: error: no member 'isStructConsExp' for type 'Expression'
		if(auto ini=init?init.isStructConsExp():null){
                                 ^~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
interpret.d:3573:48: error: undefined identifier 'text'
			}else assert(!(size&1),text(tu));
                                               ^~~~
interpret.d:1177:94: error: no member 'sizeof' for type 'BCSlice'
	void emitPushConstant(T)(T v)if(!is(T==void[])){ emitPushConstant((cast(void*)&v)[0..T.sizeof]); }
                                                                                             ^~~~~~~~
interpret.d:3574:29: note: instantiated here
			bld.emitPushConstant(r);
                            ^~~~~~~~~~~~~~~~
interpret.d:3576:34: error: no member 'isPointerTy' for type 'Type'
		}else if(auto pt=tu.isPointerTy()){
                                 ^~~~~~~~~~~~~~
interpret.d:4380:20: error: cannot cast expression 'init' of type 'Expression' to 'bool'
		if(init) init.byteCompile(bld); // TODO: in semantic, add correct 'init's
                   ^~~~
interpret.d:4381:22: error: unimplemented feature ForeachRangeStm
		else foreach(i;0..len){bld.emit(Instruction.push); bld.emitConstant(0);}
                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3579:78: error: no member 'sizeof' for type 'Symbol'
				pt.variantToMemory(value, (cast(void*)&s)[0..Symbol.sizeof]);
                                                                             ^~~~~~~~~~~~~
interpret.d:4398:29: error: cannot cast expression 'init' of type 'Expression' to 'bool'
		if(auto ini=init?init.isStructConsExp():null){
                            ^~~~
interpret.d:4398:34: error: no member 'isStructConsExp' for type 'Expression'
		if(auto ini=init?init.isStructConsExp():null){
                                 ^~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
declaration.d:381:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
interpret.d:1177:94: error: no member 'sizeof' for type 'Symbol'
	void emitPushConstant(T)(T v)if(!is(T==void[])){ emitPushConstant((cast(void*)&v)[0..T.sizeof]); }
                                                                                             ^~~~~~~~
interpret.d:3580:37: note: instantiated here
				bld.emitPushConstant(s);
                                    ^~~~~~~~~~~~~~~~
interpret.d:3584:69: error: no member 'sizeof' for type 'BCPointer'
			pt.variantToMemory(value,(cast(void*)&r)[0..BCPointer.sizeof]);
                                                                    ^~~~~~~~~~~~~~~~
interpret.d:3585:25: error: undefined identifier 'size_t'
			size_t size = getBCSizeof(tu);
                        ^~~~~~
interpret.d:3588:72: error: cannot cast expression 'value.getType()' of type 'Type' to 'void*'
				bld.emitConstant(cast(ulong)cast(void*)value.getType());
                                                                       ^~~~~~~~~~~~~~~
interpret.d:3589:48: error: undefined identifier 'text'
			}else assert(!(size&1),text(tu));
                                               ^~~~
interpret.d:1177:94: error: no member 'sizeof' for type 'BCPointer'
	void emitPushConstant(T)(T v)if(!is(T==void[])){ emitPushConstant((cast(void*)&v)[0..T.sizeof]); }
                                                                                             ^~~~~~~~
interpret.d:3590:29: note: instantiated here
			bld.emitPushConstant(r);
                            ^~~~~~~~~~~~~~~~
interpret.d:3592:34: error: no member 'isAggregateTy' for type 'Type'
		}else if(auto at=tu.isAggregateTy()){
                                 ^~~~~~~~~~~~~~~~
interpret.d:3593:56: error: type 'VarDecl' is not an expression
			auto vars = value.get!(Variant[VarDecl])();
                                                       ^~~~~~~
interpret.d:1163:37: error: no member 'sizeof' for type 'ulong'
		auto len=mem.length/ulong.sizeof;
                                    ^~~~~~~~~~~~
interpret.d:1164:49: error: no member 'sizeof' for type 'ulong'
		auto ul=cast(ulong[])mem[0..len*ulong.sizeof];
                                                ^~~~~~~~~~~~
interpret.d:1169:31: error: no member 'sizeof' for type 'ulong'
		if(mem.length%ulong.sizeof){
                              ^~~~~~~~~~~~
interpret.d:1170:50: error: no member 'sizeof' for type 'ulong'
			auto diff=mem.length-len*ulong.sizeof;
                                                 ^~~~~~~~~~~~
interpret.d:3365:24: error: type 'LVconditional' is not callable
		return LVconditional(strat1, strat2);
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:1172:58: error: no member 'sizeof' for type 'ulong'
			(cast(void*)&x)[0..diff]=mem[len*ulong.sizeof..$];
                                                         ^~~~~~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
interpret.d:3574:29: note: instantiated here
			bld.emitPushConstant(r);
                            ^~~~~~~~~~~~~~~~
interpret.d:3599:35: error: no member 'isDelegateTy' for type 'Type'
		}else if(auto dgt=tu.isDelegateTy()){
                                  ^~~~~~~~~~~~~~~
interpret.d:3600:50: error: no member 'sizeof' for type 'ulong'
			void[(bcPointerBCSize+1)*ulong.sizeof] mem=void;
                                                 ^~~~~~~~~~~~
interpret.d:3605:77: error: no member 'isAggregateTy' for type 'Type'
			assert(tu.getUnqual() is Type.get!(typeof(null))()||tu.isAggregateTy());
                                                                            ^~~~~~~~~~~~~~~~
interpret.d:3607:25: error: unimplemented feature ForeachRangeStm
			foreach(i;0..getBCSizeof(Type.get!(typeof(null))())){
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
interpret.d:3677:20: error: cannot cast expression 'auto from=t1.isIntegral()' of type 'BasicType' to 'bool'
		if(auto from=t1.isIntegral()){
                   ^~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3678:28: error: cannot cast expression 'auto to=t2.isIntegral()' of type 'BasicType' to 'bool'
			if(auto to=t2.isIntegral()){
                           ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(GenerativeDecl)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(ImportDecl)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(MixinDecl)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(AliasDecl)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(TemplateMixinDecl)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(EnumDecl)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(ConditionalDecl)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
declaration.d:186:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
declaration.d:121:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
declaration.d:129:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
declaration.d:268:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
declaration.d:95:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
declaration.d:177:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
declaration.d:114:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(InterfaceDecl)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(ClassDecl)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
declaration.d:335:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
declaration.d:323:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
declaration.d:278:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
declaration.d:303:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
declaration.d:311:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(StructDecl)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(UnionDecl)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4912:28: error: undefined identifier 'store'
		foreach(x; store.instances) x.byteCompile(bld);
                           ^~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
declaration.d:259:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
semantic.d:9183:47: error: no member 'traverseInOrder' for type 'Declaration[]'
		foreach(x; decls) if(auto r = x.traverseInOrder(dg)) return r;
                                              ^~~~~~~~~~~~~~~~~
semantic.d:9146:35: error: no member 'potentialRemove' for type 'Declaration[]'
		foreach(x; decls) x.potentialRemove(sc, decl);
                                  ^~~~~~~~~~~~~~~~~
semantic.d:9143:35: error: no member 'potentialInsert' for type 'Declaration[]'
		foreach(x; decls) x.potentialInsert(sc, decl);
                                  ^~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
declaration.d:202:18: error: undefined identifier 'string'
	override string toString(){return STCtoString(astStc)~":\n"~join(map!(to!string)(decls),"\n");}
                 ^~~~~~
declaration.d:196:18: error: undefined identifier 'string'
	override string toString(){return STCtoString(astStc)~"{\n"~(stc?join(map!(to!string)(decls),"\n")~"\n}":indent(join(map!(to!string)(decls),"\n"))~"\n}");}
                 ^~~~~~
declaration.d:201:70: error: current object 'super' of type 'BlockDecl' is not callable
	this(STC stc,Declaration[] declarations){decls=declarations; super(stc,null);}
                                                                     ^~~~~~~~~~~~~~~
declaration.d:195:68: error: current object 'super' of type 'Declaration' is not callable
	this(STC s,Declaration[] declarations){decls=declarations; super(stc,null);}
                                                                   ^~~~~~~~~~~~~~~
semantic.d:9151:34: error: no member 'pickupSTC' for type 'Declaration[]'
		foreach(x;decls) x.pickupSTC(stc);
                                 ^~~~~~~~~~~
semantic.d:9158:25: error: no member 'pickupSTC' for type 'Declaration[]'
			x.pickupSTC(stc);
                        ^~~~~~~~~~~
semantic.d:9159:25: error: no member 'presemantic' for type 'Declaration[]'
			x.presemantic(sc);
                        ^~~~~~~~~~~~~
<mixin@semantic.d:9166>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:9166>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:9166>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:9167:21: error: undefined identifier 'addedToScheduler'
		if(!addedToScheduler){
                    ^~~~~~~~~~~~~~~~
semantic.d:9169:33: error: type 'Scheduler' is not callable
				Scheduler().add(x, sc);
                                ^~~~~~~~~~~
semantic.d:9170:25: error: undefined identifier 'addedToScheduler'
			addedToScheduler = true;
                        ^~~~~~~~~~~~~~~~
semantic.d:9173:25: error: no member 'semantic' for type 'Declaration[]'
			x.semantic(sc);
                        ^~~~~~~~~~
<mixin@<mixin@semantic.d:9179>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:9179>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:6037:24: error: function call result 'this.member()' of type 'Expression' is not callable
		return member.isLvalue();
                       ^~~~~~
semantic.d:5998:21: error: cannot cast expression 'this_' of type 'Expression' to 'bool'
		if(!this_){
                    ^~~~~
semantic.d:6000:28: error: cannot cast expression 'auto fd=sc.getFunction()' of type 'FunctionDef' to 'bool'
			if(auto fd=sc.getFunction())
                           ^~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:6001:28: error: cannot cast expression 'auto decl=sc.getAggregate()' of type 'AggregateDecl' to 'bool'
			if(auto decl=sc.getAggregate())
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5798:47: error: cannot cast expression 'res' of type 'Expression' to 'bool'
	@property Expression member(){ return res ? res : e2; }
                                              ^~~
semantic.d:6041:24: error: function call result 'this.member()' of type 'Expression' is not callable
		return member.getMemberScope();
                       ^~~~~~
semantic.d:6098:57: error: cannot cast expression 'e2' of type 'Symbol' to 'void*'
		auto name = (cast(Identifier)cast(void*)e2).name;
                                                        ^~
semantic.d:6099:27: error: no member 'isType' for type 'Expression'
		auto ty = e1.isType();
                          ^~~~~~~~~
semantic.d:6107:41: error: unimplemented feature SwitchStm
			if(!isType)	switch(name){
                                        ^~~~~~~~~~~~~
semantic.d:6115:31: error: unimplemented feature SwitchStm
			}else switch(name){
                              ^~~~~~~~~~~~~
semantic.d:6133:28: error: no member 'isTuple' for type 'Expression'
		if(auto tp=e1.isTuple()){
                           ^~~~~~~~~~
semantic.d:5985:27: error: no member 'isIdentifier' for type 'Symbol'
		if(auto i=e2.isIdentifier()){
                          ^~~~~~~~~~~~~~~
semantic.d:527:25: error: unimplemented feature SwitchStm
			final switch(inContext) with(InContext){
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:521:81: error: undefined identifier 'text'
			assert(this.inContext.among(InContext.none, inContext), text(this," ",this.inContext," ",inContext));
                                                                                ^~~~
semantic.d:5794:15: note: instantiated here
	mixin ContextSensitive;
              ^~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
expression.d:443:18: error: undefined identifier 'string'
	override string toString(){
                 ^~~~~~
semantic.d:6079:25: error: cannot cast expression 'th_' of type 'Type' to 'bool'
		assert(!th_);
                        ^~~
semantic.d:6081:20: error: cannot cast expression 'auto tt=e1.extractThis()' of type 'Expression' to 'bool'
		if(auto tt=e1.extractThis()) this_=tt.type;
                   ^~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:6082:20: error: function call result 'this.member()' of type 'Expression' is not callable
		if(member.isTuple()) super.matchError(sc,loc,this_,args);
                   ^~~~~~
semantic.d:6049:20: error: undefined identifier 'isTuple'
		if(isTuple()) return AccessCheck.all;
                   ^~~~~~~
semantic.d:6044:20: error: undefined identifier 'isTuple'
		if(isTuple()) return null;
                   ^~~~~~~
interpret.d:3918:24: error: cannot cast expression 'e2.meaning' of type 'Declaration' to 'bool'
		assert(e2.meaning);
                       ^~~~~~~~~~
interpret.d:3919:35: error: undefined identifier 'STCstatic'
		if(e2.meaning.stc&STCstatic){
                                  ^~~~~~~~~
interpret.d:3920:28: error: cannot cast expression 'auto this_=e1.extractThis()' of type 'Expression' to 'bool'
			if(auto this_=e1.extractThis()) ExpressionStm.byteCompileIgnoreResult(bld, this_);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3920:57: error: need 'this' to access member function 'ExpressionStm.byteCompileIgnoreResult'
			if(auto this_=e1.extractThis()) ExpressionStm.byteCompileIgnoreResult(bld, this_);
                                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3412:9: note: member function was declared here
	static void byteCompileIgnoreResult(ref ByteCodeBuilder bld, Expression e){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:6045:20: error: no member 'isTemplateInstanceDecl' for type 'Declaration'
		if(e2.meaning.isTemplateInstanceDecl()) return e1.extractThis();
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3924:21: error: cannot cast expression 'this_' of type 'Expression' to 'bool'
		if(!this_){
                    ^~~~~
interpret.d:3930:26: error: cannot cast expression 'this_' of type 'Expression' to 'bool'
		assert(!!this_ && cast(AggregateTy)this_.type.getHeadUnqual(), text(this_," ",this));
                         ^~~~~
interpret.d:3930:52: error: cannot cast expression 'this_.type.getHeadUnqual()' of type 'Type' to 'AggregateTy'
		assert(!!this_ && cast(AggregateTy)this_.type.getHeadUnqual(), text(this_," ",this));
                                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3930:80: error: undefined identifier 'text'
		assert(!!this_ && cast(AggregateTy)this_.type.getHeadUnqual(), text(this_," ",this));
                                                                               ^~~~
interpret.d:3931:58: error: cannot cast expression 'this_.type.getHeadUnqual()' of type 'Type' to 'void*'
		auto aggrt = cast(AggregateTy)cast(void*)this_.type.getHeadUnqual();
                                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3933:25: error: no member 'isVarDecl' for type 'Declaration'
		auto vd=e2.meaning.isVarDecl();
                        ^~~~~~~~~~~~~~~~~~~~
interpret.d:3935:17: error: undefined identifier 'size_t'
		size_t len, off = aggrt.getBCLocOf(vd, len);
                ^~~~~~
interpret.d:3935:17: error: undefined identifier 'size_t'
		size_t len, off = aggrt.getBCLocOf(vd, len);
                ^~~~~~
interpret.d:207:46: error: type 'VarDecl' is not an expression
		auto aggr=value.get!(Variant[VarDecl])();
                                             ^~~~~~~
interpret.d:209:37: error: cannot cast expression 'e2.meaning' of type 'Declaration' to 'VarDecl'
		assert(cast(VarDecl)e2.meaning);
                                    ^~~~~~~~~~
interpret.d:210:53: error: cannot cast expression 'e2.meaning' of type 'Declaration' to 'void*'
		return aggr[cast(VarDecl)cast(void*)e2.meaning];
                                                    ^~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
<mixin@semantic.d:5802>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:5989>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:5802>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:5802>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:5989>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5808:35: error: no member 'init' for type 'AccessCheck'
		if(accessCheck == AccessCheck.init){
                                  ^~~~~~~~~~~~~~~~
semantic.d:5810:29: error: no member 'isType' for type 'Expression'
			if(!e1.isType()) e2.accessCheck = e1.deferredAccessCheck();
                            ^~~~~~~~~
semantic.d:5816:21: error: cannot cast expression 'msc' of type 'Scope' to 'bool'
		if(!msc){
                    ^~~
semantic.d:5817:37: error: no member 'isPointerTy' for type 'Type'
			if(auto ptr=e1.type.getHeadUnqual().isPointerTy())
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5819:29: error: cannot cast expression 'msc' of type 'Scope' to 'bool'
			if(!msc){
                            ^~~
semantic.d:5828:21: error: cannot cast expression 'e2.meaning' of type 'Declaration' to 'bool'
		if(!e2.meaning){
                    ^~~~~~~~~~
semantic.d:5829:41: error: no member 'isIdentifier' for type 'Symbol'
			if(auto ident = e2.isIdentifier()){
                                        ^~~~~~~~~~~~~~~
semantic.d:5834:47: error: undefined identifier 'Lookup'
					mixin(Lookup!q{_;ident,sc,msc});
                                              ^~~~~~
semantic.d:5842:26: error: cannot cast expression 'e2.meaning' of type 'Declaration' to 'bool'
		assert(!!e2.meaning);
                         ^~~~~~~~~~
semantic.d:5844:20: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
		if(rewrite)
                   ^~~~~~~
semantic.d:5855:31: error: no member 'isSymbol' for type 'Expression'
		if(auto sym = res.isSymbol()){
                              ^~~~~~~~~~~~
semantic.d:5859:43: error: cannot cast expression 'thisType' of type 'Type' to 'bool'
			bool needThis = !!thisType;
                                          ^~~~~~~~
semantic.d:5862:36: error: cannot cast expression 'this_' of type 'Expression' to 'bool'
				if(this_)
                                   ^~~~~
semantic.d:5866:50: error: no member 'isAggregateTy' for type 'Type'
					assert(!!this_.type.getUnqual().isAggregateTy());
                                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5873:48: error: undefined identifier 'STCconst'
					if(stc&STCconst && !e2.type.implicitlyConvertsTo(type).force){
                                               ^~~~~~~~
semantic.d:5874:58: error: undefined identifier 'format'
						sc.error(format("cannot load field '%s' of type '%s' from const-qualified receiver",e2, e2.type), loc);
                                                         ^~~~~~
semantic.d:5875:57: error: undefined identifier 'format'
						sc.note(format("%s was declared here",kind),e2.meaning.loc);
                                                        ^~~~~~
<mixin@<mixin@semantic.d:5876>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:5876>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5891:26: error: cannot cast expression 'this_' of type 'Expression' to 'bool'
		}else if(this_){
                         ^~~~~
semantic.d:5893:28: error: no member 'isExpTuple' for type 'Expression'
			if(res.isExpTuple()){
                           ^~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:5895>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:5895>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5910:21: error: cannot cast expression 'this_' of type 'Expression' to 'bool'
		if(!this_){
                    ^~~~~
semantic.d:5914:37: error: no member 'isSymbol' for type 'Expression'
			if(auto sym=r.isSymbol()){
                                    ^~~~~~~~~~
semantic.d:5915:36: error: no member 'isType' for type 'Expression'
				if(e1.isType()) goto Lok;
                                   ^~~~~~~~~
semantic.d:5931:25: error: function call result 'this.e2.ignoreProperty()' is not an lvalue
			e2.ignoreProperty=true;
                        ^~~~~~~~~~~~~~~~~~~~~~
semantic.d:5932:49: error: no member 'init' for type 'Expression[]'
			auto r = New!CallExp(b, (Expression[]).init);
                                                ^~~~~~~~~~~~~~~~~~~
semantic.d:5937:26: error: cannot cast expression 'type' of type 'Type' to 'bool'
		assert(!!type);
                         ^~~~
<mixin@<mixin@semantic.d:5938>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:5938>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5945:34: error: cannot cast expression 'ufcs' of type 'Expression' to 'bool'
		if(e1 is this_&&!ufcs)
                                 ^~~~
semantic.d:5946:36: error: no member 'isIdentifier' for type 'Symbol'
			if(auto id=e2.isIdentifier()){
                                   ^~~~~~~~~~~~~~~
semantic.d:5955:20: error: cannot cast expression 'ufcs' of type 'Expression' to 'bool'
		if(ufcs){
                   ^~~~
semantic.d:5958:28: error: no member 'isSymbol' for type 'Expression'
			if(ufcs.isSymbol()||ufcs.isType())
                           ^~~~~~~~~~~~~
semantic.d:5958:45: error: no member 'isType' for type 'Expression'
			if(ufcs.isSymbol()||ufcs.isType())
                                            ^~~~~~~~~~~
semantic.d:5961:47: error: no member 'isSymbol' for type 'Expression'
				incomplete&=!(ufcs.isSymbol()&&ufcs.isSymbol().meaning.stc&STCproperty);
                                              ^~~~~~~~~~~~~
semantic.d:5961:64: error: no member 'isSymbol' for type 'Expression'
				incomplete&=!(ufcs.isSymbol()&&ufcs.isSymbol().meaning.stc&STCproperty);
                                                               ^~~~~~~~~~~~~
semantic.d:5961:92: error: undefined identifier 'STCproperty'
				incomplete&=!(ufcs.isSymbol()&&ufcs.isSymbol().meaning.stc&STCproperty);
                                                                                           ^~~~~~~~~~~
semantic.d:5970:28: error: no member 'isFieldExp' for type 'Expression'
		if(auto fe=e1.isFieldExp()) if(auto t=fe.e2.meaning.isTemplateInstanceDecl()) tmpl=t;
                           ^~~~~~~~~~~~~
semantic.d:5971:21: error: cannot cast expression 'tmpl' of type 'TemplateInstanceDecl' to 'bool'
		if(!tmpl)
                    ^~~~
semantic.d:5972:30: error: no member 'isSymbol' for type 'Expression'
		if(auto symb=e1.isSymbol())
                             ^~~~~~~~~~~
semantic.d:5976:20: error: cannot cast expression 'tmpl' of type 'TemplateInstanceDecl' to 'bool'
		if(tmpl)
                   ^~~~
semantic.d:5977:34: error: undefined identifier 'format'
			sc.error(format("no member '%s' for %s '%s'",member.toString(),e1.kind,e1),loc);
                                 ^~~~~~
semantic.d:5977:70: error: function call result 'this.member()' of type 'Expression' is not callable
			sc.error(format("no member '%s' for %s '%s'",member.toString(),e1.kind,e1),loc);
                                                                     ^~~~~~
semantic.d:5979:34: error: undefined identifier 'format'
			sc.error(format("no member '%s' for type '%s'",member.toString(),e1.isType()?e1:e1.type),loc);
                                 ^~~~~~
semantic.d:5979:72: error: function call result 'this.member()' of type 'Expression' is not callable
			sc.error(format("no member '%s' for type '%s'",member.toString(),e1.isType()?e1:e1.type),loc);
                                                                       ^~~~~~
semantic.d:5979:90: error: no member 'isType' for type 'Expression'
			sc.error(format("no member '%s' for type '%s'",member.toString(),e1.isType()?e1:e1.type),loc);
                                                                                         ^~~~~~~~~
<mixin@<mixin@semantic.d:5980>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:5980>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:7628:14: error: declaration of 'ty' smells suspicously fishy
	Type ty;
             ^~
interpret.d:5071:28: note: this lookup should have succeeded if it was valid
		auto slt = ty.getDynArr();
                           ^~
type.d:254:18: error: undefined identifier 'string'
	override string toString(){
                 ^~~~~~
semantic.d:1308:21: error: declaration of 'ascope' smells suspicously fishy
	DollarScope ascope;
                    ^~~~~~
interpret.d:403:20: note: this lookup should have succeeded if it was valid
		if(ascope.dollar){
                   ^~~~~~
semantic.d:7628:14: error: declaration of 'ty' smells suspicously fishy
	Type ty;
             ^~
interpret.d:5191:43: note: this lookup should have succeeded if it was valid
		auto ctsize = getCTSizeof(ty);
                                          ^~
expression.d:382:18: error: undefined identifier 'string'
	override string toString(){return _brk(e.toString()~'['~l.toString()~".."~r.toString()~']');}
                 ^~~~~~
semantic.d:1033:18: error: undefined identifier 'size_t'
	override size_t tmplArgToHash(){
                 ^~~~~~
semantic.d:7662:42: error: no member 'stringof' for type 'PointerTy'
		if(auto c=mixin(`rhs.is`~T.stringof)()){
                                         ^~~~~~~~~~
semantic.d:7764:70: error: no member 'stringof' for type 'PointerTy'
	private enum puthead = "get"~(is(T==ArrayTy)?"Array(length)":typeof(this).stringof[0..$-2]~"()");
                                                                     ^~~~~~~~~~~~~~~~~~~~~
semantic.d:7641:62: error: no member 'stringof' for type 'PointerTy'
		if(auto tt = mixin(`from.getHeadUnqual().is`~T.stringof)()){
                                                             ^~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:965>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
interpret.d:5105:64: error: no member 'sizeof' for type 'BCPointer'
			return voidPointerOrArrayToVariant(mem,BCPointer.sizeof);
                                                               ^~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:965>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:7630>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@semantic.d:965>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
interpret.d:5109:31: error: incompatible types 'void*' and 'void*' for binary -
		auto offset = ptr.ptr-ptr.container.ptr;
                              ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:7630>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5111:26: error: default parameters not implemented yet
		auto cnt=variantArrayFromContainer(ptr.container, ty);
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:7630>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:7635:41: error: no member 'stringof' for type 'PointerTy'
		else r = mixin("ty.get"~T.stringof[0..$-2]~"()");
                                        ^~~~~~~~~~
<mixin@<mixin@semantic.d:967>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:967>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:970:31: error: undefined identifier 'ImplConvertsTo'
			mixin(ImplConvertsTo!q{bool xtoty; x, ty}); // TODO: ditto?
                              ^~~~~~~~~~~~~~
semantic.d:971:31: error: undefined identifier 'ImplConvertsTo'
			mixin(ImplConvertsTo!q{bool tytox; ty, x.type}); // TODO: ditto?
                              ^~~~~~~~~~~~~~
semantic.d:972:29: error: undefined identifier 'tytox'
			if(!tytox){
                            ^~~~~
semantic.d:973:33: error: undefined identifier 'tytox'
				tytox = true;
                                ^~~~~
semantic.d:975:47: error: undefined identifier 'ImplConvertsTo'
					mixin(ImplConvertsTo!q{bool ytox; y, x.type});
                                              ^~~~~~~~~~~~~~
semantic.d:976:46: error: undefined identifier 'tytox'
					if(!(tytox &= ytox)) break;
                                             ^~~~~
semantic.d:976:55: error: undefined identifier 'ytox'
					if(!(tytox &= ytox)) break;
                                                      ^~~~
semantic.d:979:28: error: undefined identifier 'xtoty'
			if(xtoty^tytox){
                           ^~~~~
semantic.d:979:34: error: undefined identifier 'tytox'
			if(xtoty^tytox){
                                 ^~~~~
semantic.d:980:38: error: undefined identifier 'tytox'
				ty = tytox ? x.type : ty;
                                     ^~~~~
semantic.d:983:31: error: undefined identifier 'Combine'
			mixin(Combine!q{Type newty; ty, x.type}); // TODO: keep state?
                              ^~~~~~~
semantic.d:984:28: error: undefined identifier 'newty'
			if(newty){
                           ^~~~~
semantic.d:985:36: error: undefined identifier 'newty'
				ty=newty;
                                   ^~~~~
semantic.d:988:29: error: no member 'isAddressExp' for type 'Expression[]'
			if((x.isAddressExp()||x.isArrayLiteralExp()) && x.type is Type.get!void())
                            ^~~~~~~~~~~~~~
semantic.d:988:47: error: no member 'isArrayLiteralExp' for type 'Expression[]'
			if((x.isAddressExp()||x.isArrayLiteralExp()) && x.type is Type.get!void())
                                              ^~~~~~~~~~~~~~~~~~~
semantic.d:988:73: error: no member 'type' for type 'Expression[]'
			if((x.isAddressExp()||x.isArrayLiteralExp()) && x.type is Type.get!void())
                                                                        ^~~~~~
semantic.d:990:34: error: undefined identifier 'format'
			sc.error(format("incompatible type '%s' in array of '%s'",x.type,ty),x.loc);
                                 ^~~~~~
semantic.d:990:83: error: no member 'type' for type 'Expression[]'
			sc.error(format("incompatible type '%s' in array of '%s'",x.type,ty),x.loc);
                                                                                  ^~~~~~
semantic.d:990:94: error: no member 'loc' for type 'Expression[]'
			sc.error(format("incompatible type '%s' in array of '%s'",x.type,ty),x.loc);
                                                                                             ^~~~~
<mixin@<mixin@semantic.d:991>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:991>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:997:28: error: no member 'isAddressExp' for type 'Expression[]'
			if(x.isAddressExp()||x.isArrayLiteralExp())
                           ^~~~~~~~~~~~~~
semantic.d:997:46: error: no member 'isArrayLiteralExp' for type 'Expression[]'
			if(x.isAddressExp()||x.isArrayLiteralExp())
                                             ^~~~~~~~~~~~~~~~~~~
semantic.d:998:36: error: no member 'type' for type 'Expression[]'
				if(x.type is ty){
                                   ^~~~~~
<mixin@<mixin@semantic.d:1000>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:1000>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:1004:40: error: no member 'implicitlyConvertTo' for type 'Expression[]'
		foreach(ref x; lit)  x=x.implicitlyConvertTo(ty);
                                       ^~~~~~~~~~~~~~~~~~~~~
semantic.d:1006:23: error: undefined identifier 'util'
		alias util.all all; // TODO: file bug
                      ^~~~
semantic.d:1008:22: error: no member 'getDynArr' for type 'Type'
		type=ty.getDynArr();
                     ^~~~~~~~~~~~
<mixin@<mixin@semantic.d:1009>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:1009>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
expression.d:213:18: error: undefined identifier 'string'
	override string toString(){ return _brk("["~join(map!(to!string)(lit),",")~"]"); }
                 ^~~~~~
interpret.d:3658:24: error: no member 'isArrayTy' for type 'Type'
		assert(type.isArrayTy()); // static array literal, also kludgy
                       ^~~~~~~~~~~~~~
interpret.d:3659:33: error: no member 'byteCompile' for type 'Expression[]'
		foreach(x; lit) x.byteCompile(bld);
                                ^~~~~~~~~~~~~
semantic.d:1030:24: error: incompatible types 'Variant' and 'Variant' for binary ==
		return interpretV()==rhs.interpretV();
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:332:44: error: cannot implicitly convert function call result 'lit[i].interpretV()' of type 'Variant' to 'Variant[]'
		foreach(i, ref x; res) x = lit[i].interpretV();
                                           ^~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(CArrayParam)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(CArrayDecl)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(Parameter)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(EnumVarDecl)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(TmpVarDecl)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
semantic.d:5466:17: error: declaration of 'consCall' smells suspicously fishy
	CallExp consCall;
                ^~~~~~~~
interpret.d:4254:33: note: this lookup should have succeeded if it was valid
				consCall.byteCompile(bld);
                                ^~~~~~~~
semantic.d:5467:15: error: declaration of 'scope_' smells suspicously fishy
	Scope scope_;
              ^~~~~~
interpret.d:4247:58: note: this lookup should have succeeded if it was valid
			aggrty.decl.byteCompileInit(bld, scope_); // TODO: context is null
                                                         ^~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
declaration.d:103:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
declaration.d:424:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
declaration.d:414:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
semantic.d:5307:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
declaration.d:391:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
expression.d:300:18: error: undefined identifier 'string'
	override string toString(){
                 ^~~~~~
expression.d:304:28: error: undefined identifier 'string'
	override @property string kind(){ return "new expression"; }
                           ^~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:7290:57: error: cannot cast expression 'ty' of type 'Type' to 'bool'
	invariant(){assert(sstate < SemState.started || ty); mixin(_restOfInvariant);}
                                                        ^~
semantic.d:7290:57: error: cannot cast expression 'ty' of type 'Type' to 'bool'
	invariant(){assert(sstate < SemState.started || ty); mixin(_restOfInvariant);}
                                                        ^~
semantic.d:7290:57: error: cannot cast expression 'ty' of type 'Type' to 'bool'
	invariant(){assert(sstate < SemState.started || ty); mixin(_restOfInvariant);}
                                                        ^~
semantic.d:7290:57: error: cannot cast expression 'ty' of type 'Type' to 'bool'
	invariant(){assert(sstate < SemState.started || ty); mixin(_restOfInvariant);}
                                                        ^~
<mixin@semantic.d:7290>:3:23: error: can only instantiate templates, not types
		alias TypeTuple!("ImmutableTy","SharedTy","InoutTy","ConstTy") Order;
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4259:26: error: cannot cast expression 'type' of type 'Type' to 'bool'
		assert(!!type);
                         ^~~~
<mixin@semantic.d:7290>:3:23: error: can only instantiate templates, not types
		alias TypeTuple!("ImmutableTy","SharedTy","InoutTy","ConstTy") Order;
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:7290>:3:23: error: can only instantiate templates, not types
		alias TypeTuple!("ImmutableTy","SharedTy","InoutTy","ConstTy") Order;
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:7290>:3:23: error: can only instantiate templates, not types
		alias TypeTuple!("ImmutableTy","SharedTy","InoutTy","ConstTy") Order;
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5531:34: error: no member 'isAggregateTy' for type 'Type'
		if(constructor&&!type.isAggregateTy().decl.asc.inexistent(sc,constructor))
                                 ^~~~~~~~~~~~~~~~~~
interpret.d:4261:29: error: no member 'isPointerTy' for type 'Type'
		if(auto ptr=type.isPointerTy()) tt=ptr.ty;
                            ^~~~~~~~~~~~~~~~
semantic.d:7764:70: error: no member 'stringof' for type 'DynArrTy'
	private enum puthead = "get"~(is(T==ArrayTy)?"Array(length)":typeof(this).stringof[0..$-2]~"()");
                                                                     ^~~~~~~~~~~~~~~~~~~~~
semantic.d:7662:42: error: no member 'stringof' for type 'DynArrTy'
		if(auto c=mixin(`rhs.is`~T.stringof)()){
                                         ^~~~~~~~~~
interpret.d:5198:64: error: no member 'sizeof' for type 'BCSlice'
			return voidPointerOrArrayToVariant(mem,BCSlice.sizeof);
                                                               ^~~~~~~~~~~~~~
semantic.d:7641:62: error: no member 'stringof' for type 'DynArrTy'
		if(auto tt = mixin(`from.getHeadUnqual().is`~T.stringof)()){
                                                             ^~~~~~~~~~
interpret.d:5201:38: error: no member 'sizeof' for type 'BCSlice'
		assert(mem.length == BCSlice.sizeof);
                                     ^~~~~~~~~~~~~~
interpret.d:5203:20: error: cannot cast expression 'type.getHeadUnqual().isSomeString()' of type 'Type' to 'bool'
		if(type.getHeadUnqual().isSomeString()){
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5205:40: error: undefined identifier 'string'
			foreach(T;Seq!(string,wstring,dstring)){
                                       ^~~~~~
interpret.d:5205:47: error: undefined identifier 'wstring'
			foreach(T;Seq!(string,wstring,dstring)){
                                              ^~~~~~~
interpret.d:5205:55: error: undefined identifier 'dstring'
			foreach(T;Seq!(string,wstring,dstring)){
                                                      ^~~~~~~
semantic.d:7562:24: error: no member 'inImmutableContext' for type 'Type'
		return ty.inImmutableContext();
                       ^~~~~~~~~~~~~~~~~~~~~
semantic.d:7562:24: error: no member 'inImmutableContext' for type 'Type'
		return ty.inImmutableContext();
                       ^~~~~~~~~~~~~~~~~~~~~
semantic.d:7562:24: error: no member 'inImmutableContext' for type 'Type'
		return ty.inImmutableContext();
                       ^~~~~~~~~~~~~~~~~~~~~
semantic.d:7562:24: error: no member 'inImmutableContext' for type 'Type'
		return ty.inImmutableContext();
                       ^~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
interpret.d:5211:28: error: default parameters not implemented yet
		auto cnt = variantArrayFromContainer(slc.container,ty);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5213:17: error: undefined identifier 'size_t'
		size_t start = slc.slice.ptr-slc.container.ptr;
                ^~~~~~
interpret.d:5213:32: error: incompatible types 'void*' and 'void*' for binary -
		size_t start = slc.slice.ptr-slc.container.ptr;
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5214:17: error: undefined identifier 'size_t'
		size_t end = start+slc.slice.length;
                ^~~~~~
<mixin@semantic.d:7630>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@semantic.d:5470>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:7630>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:5532>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:5532>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:5470>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:5470>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:7630>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:5474>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:5474>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:7635:41: error: no member 'stringof' for type 'DynArrTy'
		else r = mixin("ty.get"~T.stringof[0..$-2]~"()");
                                        ^~~~~~~~~~
semantic.d:5477:28: error: no member 'isIndexExp' for type 'Expression'
		if(auto ie=rty.isIndexExp()){
                           ^~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:5480>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:5480>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:5485>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:5485>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5487:33: error: undefined identifier 'swap'
				swap(ie.a, a2);
                                ^~~~
semantic.d:5494:28: error: no member 'isDynArrTy' for type 'Type'
		if(auto da=tyu.isDynArrTy()){
                           ^~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:5497>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:5497>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5501:25: error: unimplemented feature ForeachRangeStm
			foreach(x;1..a2.length){
                        ^~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5508:42: error: undefined identifier 'format'
				sc.error(format("too many arguments to new expression (expected at most %s)",toEngNum(actual)),loc);
                                         ^~~~~~
<mixin@<mixin@semantic.d:5509>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:5509>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5511:36: error: no member 'isAggregateTy' for type 'Type'
		}else if(auto aggr=tyu.isAggregateTy()){
                                   ^~~~~~~~~~~~~~~~~
semantic.d:5513:40: error: no member 'getPointer' for type 'Type'
				type = type.getPointer();
                                       ^~~~~~~~~~~~~~~
semantic.d:5515:42: error: undefined identifier 'format'
				sc.error(format("cannot create instance of interface '%s'",iface.name), loc);
                                         ^~~~~~
<mixin@<mixin@semantic.d:5516>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:5516>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:5518>:8:15: error: undefined identifier 'IsDeclAccessible'
	mixin(IsDeclAccessible!q{bool b; Declaration, sc.getDeclaration, caggr});
              ^~~~~~~~~~~~~~~~
<mixin@semantic.d:5518>:10:13: error: undefined identifier 'b'
	if(!b){
            ^
<mixin@semantic.d:5518>:17:42: error: undefined identifier 'format'
				sc.error(format("cannot construct local %s '%s' outside of its frame", caggr.kind, caggr.name), loc);
                                         ^~~~~~
<mixin@semantic.d:5518>:19:42: error: undefined identifier 'format'
				sc.error(format("need 'this' pointer of type '%s' to construct nested class '%s'",parent.name, caggr.name), loc);
                                         ^~~~~~
<mixin@<mixin@<mixin@semantic.d:5518>:21>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@<mixin@semantic.d:5518>:21>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:5518>:29:21: error: cannot cast expression 'constructor' of type 'Identifier' to 'bool'
		if(!constructor){
                    ^~~~~~~~~~~
semantic.d:7106:18: error: unimplemented feature ArrayInitAssocExp
		[Tok!"bool":1,Tok!"char":2,Tok!"byte":2,Tok!"ubyte":2,Tok!"wchar":3,Tok!"short":3,Tok!"ushort":3,
                 ^~~~~~~~~~~~
semantic.d:7106:31: error: unimplemented feature ArrayInitAssocExp
		[Tok!"bool":1,Tok!"char":2,Tok!"byte":2,Tok!"ubyte":2,Tok!"wchar":3,Tok!"short":3,Tok!"ushort":3,
                              ^~~~~~~~~~~~
semantic.d:7106:44: error: unimplemented feature ArrayInitAssocExp
		[Tok!"bool":1,Tok!"char":2,Tok!"byte":2,Tok!"ubyte":2,Tok!"wchar":3,Tok!"short":3,Tok!"ushort":3,
                                           ^~~~~~~~~~~~
semantic.d:7106:57: error: unimplemented feature ArrayInitAssocExp
		[Tok!"bool":1,Tok!"char":2,Tok!"byte":2,Tok!"ubyte":2,Tok!"wchar":3,Tok!"short":3,Tok!"ushort":3,
                                                        ^~~~~~~~~~~~~
semantic.d:7106:71: error: unimplemented feature ArrayInitAssocExp
		[Tok!"bool":1,Tok!"char":2,Tok!"byte":2,Tok!"ubyte":2,Tok!"wchar":3,Tok!"short":3,Tok!"ushort":3,
                                                                      ^~~~~~~~~~~~~
semantic.d:7106:85: error: unimplemented feature ArrayInitAssocExp
		[Tok!"bool":1,Tok!"char":2,Tok!"byte":2,Tok!"ubyte":2,Tok!"wchar":3,Tok!"short":3,Tok!"ushort":3,
                                                                                    ^~~~~~~~~~~~~
semantic.d:7106:99: error: unimplemented feature ArrayInitAssocExp
		[Tok!"bool":1,Tok!"char":2,Tok!"byte":2,Tok!"ubyte":2,Tok!"wchar":3,Tok!"short":3,Tok!"ushort":3,
                                                                                                  ^~~~~~~~~~~~~~
semantic.d:7107:18: error: unimplemented feature ArrayInitAssocExp
		 Tok!"dchar":4,Tok!"int":4,Tok!"uint":4,Tok!"long":5,Tok!"ulong":5,Tok!"float":6,Tok!"double":6,Tok!"real":6,
                 ^~~~~~~~~~~~~
semantic.d:7107:32: error: unimplemented feature ArrayInitAssocExp
		 Tok!"dchar":4,Tok!"int":4,Tok!"uint":4,Tok!"long":5,Tok!"ulong":5,Tok!"float":6,Tok!"double":6,Tok!"real":6,
                               ^~~~~~~~~~~
semantic.d:7107:44: error: unimplemented feature ArrayInitAssocExp
		 Tok!"dchar":4,Tok!"int":4,Tok!"uint":4,Tok!"long":5,Tok!"ulong":5,Tok!"float":6,Tok!"double":6,Tok!"real":6,
                                           ^~~~~~~~~~~~
semantic.d:7107:57: error: unimplemented feature ArrayInitAssocExp
		 Tok!"dchar":4,Tok!"int":4,Tok!"uint":4,Tok!"long":5,Tok!"ulong":5,Tok!"float":6,Tok!"double":6,Tok!"real":6,
                                                        ^~~~~~~~~~~~
semantic.d:7107:70: error: unimplemented feature ArrayInitAssocExp
		 Tok!"dchar":4,Tok!"int":4,Tok!"uint":4,Tok!"long":5,Tok!"ulong":5,Tok!"float":6,Tok!"double":6,Tok!"real":6,
                                                                     ^~~~~~~~~~~~~
semantic.d:7107:84: error: unimplemented feature ArrayInitAssocExp
		 Tok!"dchar":4,Tok!"int":4,Tok!"uint":4,Tok!"long":5,Tok!"ulong":5,Tok!"float":6,Tok!"double":6,Tok!"real":6,
                                                                                   ^~~~~~~~~~~~~
semantic.d:7107:98: error: unimplemented feature ArrayInitAssocExp
		 Tok!"dchar":4,Tok!"int":4,Tok!"uint":4,Tok!"long":5,Tok!"ulong":5,Tok!"float":6,Tok!"double":6,Tok!"real":6,
                                                                                                 ^~~~~~~~~~~~~~
semantic.d:7107:113: error: unimplemented feature ArrayInitAssocExp
		 Tok!"dchar":4,Tok!"int":4,Tok!"uint":4,Tok!"long":5,Tok!"ulong":5,Tok!"float":6,Tok!"double":6,Tok!"real":6,
                                                                                                                ^~~~~~~~~~~~
semantic.d:7108:18: error: unimplemented feature ArrayInitAssocExp
		 Tok!"ifloat":-1,Tok!"idouble":-1,Tok!"ireal":-1,Tok!"cfloat":-2,Tok!"cdouble":-2,Tok!"creal":-2, Tok!"void":0];
                 ^~~~~~~~~~~~~~~
semantic.d:7108:34: error: unimplemented feature ArrayInitAssocExp
		 Tok!"ifloat":-1,Tok!"idouble":-1,Tok!"ireal":-1,Tok!"cfloat":-2,Tok!"cdouble":-2,Tok!"creal":-2, Tok!"void":0];
                                 ^~~~~~~~~~~~~~~~
semantic.d:7108:51: error: unimplemented feature ArrayInitAssocExp
		 Tok!"ifloat":-1,Tok!"idouble":-1,Tok!"ireal":-1,Tok!"cfloat":-2,Tok!"cdouble":-2,Tok!"creal":-2, Tok!"void":0];
                                                  ^~~~~~~~~~~~~~
semantic.d:7108:66: error: unimplemented feature ArrayInitAssocExp
		 Tok!"ifloat":-1,Tok!"idouble":-1,Tok!"ireal":-1,Tok!"cfloat":-2,Tok!"cdouble":-2,Tok!"creal":-2, Tok!"void":0];
                                                                 ^~~~~~~~~~~~~~~
semantic.d:7108:82: error: unimplemented feature ArrayInitAssocExp
		 Tok!"ifloat":-1,Tok!"idouble":-1,Tok!"ireal":-1,Tok!"cfloat":-2,Tok!"cdouble":-2,Tok!"creal":-2, Tok!"void":0];
                                                                                 ^~~~~~~~~~~~~~~~
semantic.d:7108:99: error: unimplemented feature ArrayInitAssocExp
		 Tok!"ifloat":-1,Tok!"idouble":-1,Tok!"ireal":-1,Tok!"cfloat":-2,Tok!"cdouble":-2,Tok!"creal":-2, Tok!"void":0];
                                                                                                  ^~~~~~~~~~~~~~
semantic.d:7108:115: error: unimplemented feature ArrayInitAssocExp
		 Tok!"ifloat":-1,Tok!"idouble":-1,Tok!"ireal":-1,Tok!"cfloat":-2,Tok!"cdouble":-2,Tok!"creal":-2, Tok!"void":0];
                                                                                                                  ^~~~~~~~~~~~
semantic.d:6581:31: error: no member 'isDelegateTy' for type 'Type'
		if(auto dgt = rhs.isDelegateTy()) return ft.equals(dgt.ft);
                              ^~~~~~~~~~~~~~~~
semantic.d:7094:17: error: unimplemented feature SwitchStm
		switch(op){
                ^~~~~~~~~~~
semantic.d:7116:17: error: unimplemented feature SwitchStm
		switch(op){
                ^~~~~~~~~~~
semantic.d:6803:20: error: cannot cast expression 'ret' of type 'Type' to 'bool'
		if(ret && ret.hasPseudoTypes()) ret = null;
                   ^~~
semantic.d:6704:21: error: cannot cast expression 'ret' of type 'Type' to 'bool'
		if(!ret){ret = rhs.ret; r=!!ret;}
                    ^~~
semantic.d:6795:20: error: cannot cast expression 'ret' of type 'Type' to 'bool'
		if(ret && ret.hasPseudoTypes()) return true;
                   ^~~
semantic.d:6704:45: error: cannot cast expression 'ret' of type 'Type' to 'bool'
		if(!ret){ret = rhs.ret; r=!!ret;}
                                            ^~~
semantic.d:6797:28: error: no member 'type' for type 'Parameter[]'
			if(p.type && p.type.hasPseudoTypes())
                           ^~~~~~
semantic.d:6797:38: error: no member 'type' for type 'Parameter[]'
			if(p.type && p.type.hasPseudoTypes())
                                     ^~~~~~
semantic.d:6805:28: error: no member 'type' for type 'Parameter[]'
			if(p.type && p.type.hasPseudoTypes())
                           ^~~~~~
semantic.d:6805:38: error: no member 'type' for type 'Parameter[]'
			if(p.type && p.type.hasPseudoTypes())
                                     ^~~~~~
semantic.d:6806:33: error: no member 'type' for type 'Parameter[]'
				p.type = null;
                                ^~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
type.d:134:18: error: undefined identifier 'string'
	override string toString(){return "typeof(null)";}
                 ^~~~~~
semantic.d:10762:34: error: undefined identifier 'format'
			sc.error(format("too %s arguments to %s '%s'",args.length<type.params.length?"few":"many", kind, signatureString()[0..$-1]),loc);
                                 ^~~~~~
semantic.d:6924:30: error: no member 'isFunctionTy' for type 'Type'
		if(auto ft = rhs.isFunctionTy()){
                             ^~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
semantic.d:6690:38: error: no member 'mustBeTypeDeduced' for type 'Parameter[]'
		foreach(x;params) if(x.mustBeTypeDeduced()) return true;
                                     ^~~~~~~~~~~~~~~~~~~
type.d:141:18: error: undefined identifier 'string'
	override string toString(){return "typeof([])";}
                 ^~~~~~
semantic.d:6696:38: error: no member 'sstate' for type 'Parameter[]'
		foreach(x;params) if(x.sstate == SemState.error) return true;
                                     ^~~~~~~~
semantic.d:6659:35: error: no member 'sstate' for type 'Parameter[]'
		foreach(x;params) x.sstate = SemState.begin;
                                  ^~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
type.d:160:9: error: undefined identifier 'string'
	string pListToString(){
        ^~~~~~
semantic.d:6720:40: error: undefined identifier 'min'
		foreach(i,p; params[0..min($,args.length)])
                                       ^~~
type.d:159:18: error: undefined identifier 'string'
	override string toString(){return (rret&&!ret?rret.toString():ret?ret.toString():"auto")~pListToString();}
                 ^~~~~~
semantic.d:6705:40: error: undefined identifier 'min'
		foreach(i,p; params[0..min($,rhs.params.length)]){
                                       ^~~
semantic.d:6998:41: error: undefined identifier 'STCinout'
		return removeQualifiers(STCinout);
                                        ^~~~~~~~
semantic.d:6989:41: error: undefined identifier 'STCconst'
		return removeQualifiers(STCconst);
                                        ^~~~~~~~
semantic.d:6995:41: error: undefined identifier 'STCshared'
		return removeQualifiers(STCshared);
                                        ^~~~~~~~~
semantic.d:6992:41: error: undefined identifier 'STCimmutable'
		return removeQualifiers(STCimmutable|STCconst|STCinout|STCshared);
                                        ^~~~~~~~~~~~
semantic.d:6992:54: error: undefined identifier 'STCconst'
		return removeQualifiers(STCimmutable|STCconst|STCinout|STCshared);
                                                     ^~~~~~~~
semantic.d:6992:63: error: undefined identifier 'STCinout'
		return removeQualifiers(STCimmutable|STCconst|STCinout|STCshared);
                                                              ^~~~~~~~
semantic.d:6992:72: error: undefined identifier 'STCshared'
		return removeQualifiers(STCimmutable|STCconst|STCinout|STCshared);
                                                                       ^~~~~~~~~
semantic.d:6941:47: error: cannot cast expression 'ret' of type 'Type' to 'bool'
			if(!((stc1==stc2 && (!ret||ret.equals(ft.ret)) &&
                                              ^~~
semantic.d:7005:24: error: undefined identifier 'modifyQualifiers'
		return modifyQualifiers!true(qual);
                       ^~~~~~~~~~~~~~~~
semantic.d:7009:24: error: undefined identifier 'modifyQualifiers'
		return modifyQualifiers!false(qual);
                       ^~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
semantic.d:6946:36: error: no member 'type' for type 'Parameter[]'
				if(x.type && !x.type.equals(ft.params[i].type)||
                                   ^~~~~~
semantic.d:6946:47: error: no member 'type' for type 'Parameter[]'
				if(x.type && !x.type.equals(ft.params[i].type)||
                                              ^~~~~~
declaration.d:442:15: error: undefined identifier 'string'
	final string signatureString(){
              ^~~~~~
<mixin@semantic.d:6663>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
semantic.d:6947:37: error: no member 'stc' for type 'Parameter[]'
				   (x.stc&(STCbyref|STClazy))!=(ft.params[i].stc&(STCbyref|STClazy)))
                                    ^~~~~
semantic.d:6733:23: error: undefined identifier 'util'
		alias util.TypeTuple!(__traits(allMembers,InoutRes)) M;
                      ^~~~
semantic.d:10870:17: error: undefined identifier 'size_t'
		size_t nump = 0;
                ^~~~~~
semantic.d:10871:43: error: no member 'mustBeTypeDeduced' for type 'Parameter[]'
		foreach(x;type.params) if(x.mustBeTypeDeduced()) nump++;
                                          ^~~~~~~~~~~~~~~~~~~
semantic.d:6736:17: error: unimplemented feature SwitchStm
		final switch(res){
                ^~~~~~~~~~~~~~~~~~
semantic.d:10874:34: error: undefined identifier 'string'
		immutable static string namebase = "__T";
                                 ^~~~~~
semantic.d:10875:17: error: undefined identifier 'size_t'
		size_t j=-1;
                ^~~~~~
semantic.d:10879:25: error: undefined identifier 'string'
			string name = namebase~to!string(i+1);
                        ^~~~~~
semantic.d:6970:20: error: undefined identifier 'dgtype'
		if(dgtype) return dgtype;
                   ^~~~~~
semantic.d:6970:35: error: undefined identifier 'dgtype'
		if(dgtype) return dgtype;
                                  ^~~~~~
semantic.d:6971:17: error: undefined identifier 'dgtype'
		dgtype = New!DelegateTy(this);
                ^~~~~~
semantic.d:6972:17: error: undefined identifier 'dgtype'
		dgtype.semantic(scope_);
                ^~~~~~
<mixin@<mixin@semantic.d:6663>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:10685:37: error: undefined identifier 'STCauto'
		type.stc|=mask&stc&~(STCauto);
                                    ^~~~~~~~~
type.d:158:83: error: undefined identifier 'STCauto'
	this(STC stc, Expression retn,Parameter[] plist,VarArgs va){this.stc=stc&~STCauto; rret=retn; params=plist; vararg=va;}
                                                                                  ^~~~~~~
semantic.d:10879:48: error: undefined identifier 'to'
			string name = namebase~to!string(i+1);
                                               ^~
semantic.d:6974:24: error: undefined identifier 'dgtype'
		assert(dgtype.sstate == SemState.completed);
                       ^~~~~~
semantic.d:6975:24: error: undefined identifier 'dgtype'
		return dgtype;
                       ^~~~~~
<mixin@semantic.d:6663>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:6664:26: error: cannot cast expression 'sc' of type 'Scope' to 'bool'
		assert(!!sc);
                         ^~
semantic.d:6666:20: error: cannot cast expression 'rret' of type 'Expression' to 'bool'
		if(rret){
                   ^~~~
<mixin@semantic.d:7077>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:10696>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:10696>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:7077>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:6670:20: error: cannot cast expression 'ret' of type 'Type' to 'bool'
		if(ret) mixin(SemChldPar!q{ret});
                   ^~~
semantic.d:10768:31: error: undefined identifier 'STCinout'
		if(this_&&stc&STCinout) inoutRes = irFromSTC(this_.getHeadSTC());
                              ^~~~~~~~
semantic.d:10881:58: error: no member 'init' for type 'Expression'
			x = New!TemplateParameter(which, Expression.init,
                                                         ^~~~~~~~~~~~~~~
<mixin@semantic.d:7077>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:10883:51: error: no member 'init' for type 'Expression'
			                          Expression.init, Expression.init);
                                                  ^~~~~~~~~~~~~~~
semantic.d:10883:68: error: no member 'init' for type 'Expression'
			                          Expression.init, Expression.init);
                                                                   ^~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:10699>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:10699>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:6672:28: error: no member 'sstate' for type 'Parameter[]'
			if(p.sstate==SemState.pre) p.sstate = SemState.begin; // never insert into scope
                           ^~~~~~~~
semantic.d:6672:52: error: no member 'sstate' for type 'Parameter[]'
			if(p.sstate==SemState.pre) p.sstate = SemState.begin; // never insert into scope
                                                   ^~~~~~~~
semantic.d:7079:25: error: undefined identifier 'string'
			string r=`Type r;switch(op){`;
                        ^~~~~~
semantic.d:6673:29: error: no member 'rtype' for type 'Parameter[]'
			if(!p.rtype && !p.init) continue; // parameter type needs to be deduced
                            ^~~~~~~
semantic.d:6947:53: error: undefined identifier 'STClazy'
				   (x.stc&(STCbyref|STClazy))!=(ft.params[i].stc&(STCbyref|STClazy)))
                                                    ^~~~~~~
semantic.d:6947:92: error: undefined identifier 'STClazy'
				   (x.stc&(STCbyref|STClazy))!=(ft.params[i].stc&(STCbyref|STClazy)))
                                                                                           ^~~~~~~
semantic.d:6919:24: note: instantiated here
		return compareImpl(rhs);
                       ^~~~~~~~~~~
semantic.d:6673:41: error: no member 'init' for type 'Parameter[]'
			if(!p.rtype && !p.init) continue; // parameter type needs to be deduced
                                        ^~~~~~
semantic.d:6674:25: error: no member 'semantic' for type 'Parameter[]'
			p.semantic(sc); // TODO: rewriting parameters ever needed?
                        ^~~~~~~~~~
semantic.d:6675:33: error: no member 'rewrite' for type 'Parameter[]'
			assert(!p.rewrite);
                                ^~~~~~~~~
semantic.d:6678:20: error: cannot cast expression 'rret' of type 'Expression' to 'bool'
		if(rret) mixin(PropErr!q{rret});
                   ^~~~
semantic.d:10772:33: error: no member 'type' for type 'Parameter[]'
			at[i] = p.type.adaptTo(args[i].type, inoutRes);
                                ^~~~~~
semantic.d:10774:39: error: no member 'resolveInout' for type 'Type[]'
		foreach(ref x;at) x = x.resolveInout(inoutRes);
                                      ^~~~~~~~~~~~~~
semantic.d:10776:31: error: cannot cast expression 'this_' of type 'Type' to 'bool'
		auto compatd=!this_?true.independent:
                              ^~~~~
semantic.d:6679:20: error: cannot cast expression 'ret' of type 'Type' to 'bool'
		if(ret) mixin(PropErr!q{ret});
                   ^~~
semantic.d:10790:34: error: undefined identifier 'format'
			sc.error(format("incompatible argument types (%s)%s to %s '%s'", join(map!"a.type.toString()"(args),","),this_?STCtoString(this_.getHeadSTC()):"",kind,signatureString()[0..$-1]),loc);
                                 ^~~~~~
semantic.d:10790:90: error: undefined identifier 'join'
			sc.error(format("incompatible argument types (%s)%s to %s '%s'", join(map!"a.type.toString()"(args),","),this_?STCtoString(this_.getHeadSTC()):"",kind,signatureString()[0..$-1]),loc);
                                                                                         ^~~~
semantic.d:10790:95: error: undefined identifier 'map'
			sc.error(format("incompatible argument types (%s)%s to %s '%s'", join(map!"a.type.toString()"(args),","),this_?STCtoString(this_.getHeadSTC()):"",kind,signatureString()[0..$-1]),loc);
                                                                                              ^~~
semantic.d:10790:130: error: cannot cast expression 'this_' of type 'Type' to 'bool'
			sc.error(format("incompatible argument types (%s)%s to %s '%s'", join(map!"a.type.toString()"(args),","),this_?STCtoString(this_.getHeadSTC()):"",kind,signatureString()[0..$-1]),loc);
                                                                                                                                 ^~~~~
semantic.d:10798:44: error: no member 'name' for type 'Parameter[]'
					if(p.name) sc.note(format("while matching function parameter '%s'",p.name),p.loc);
                                           ^~~~~~
semantic.d:10798:60: error: undefined identifier 'format'
					if(p.name) sc.note(format("while matching function parameter '%s'",p.name),p.loc);
                                                           ^~~~~~
semantic.d:10798:108: error: no member 'name' for type 'Parameter[]'
					if(p.name) sc.note(format("while matching function parameter '%s'",p.name),p.loc);
                                                                                                           ^~~~~~
semantic.d:10798:116: error: no member 'loc' for type 'Parameter[]'
					if(p.name) sc.note(format("while matching function parameter '%s'",p.name),p.loc);
                                                                                                                   ^~~~~
semantic.d:10799:90: error: no member 'loc' for type 'Parameter[]'
					else sc.note("while matching function parameter",p.loc);
                                                                                         ^~~~~
semantic.d:10801:38: error: no member 'stc' for type 'Parameter[]'
				if(!(p.stc & STCbyref)){
                                     ^~~~~
<mixin@<mixin@semantic.d:6682>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:6682>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:10810:42: error: no member 'stc' for type 'Parameter[]'
				}else if(p.stc&STCref){
                                         ^~~~~
semantic.d:10810:48: error: undefined identifier 'STCref'
				}else if(p.stc&STCref){
                                               ^~~~~~
semantic.d:10816:83: error: no member 'type' for type 'Parameter[]'
					auto irconvd = args[i].type.refConvertsTo(p.type,1);
                                                                                  ^~~~~~
semantic.d:10818:58: error: undefined identifier 'format'
						sc.error(format("incompatible argument type '%s' for 'ref' parameter of type '%s'",args[i].type.toString(),p.type.toString()),args[i].loc);
                                                         ^~~~~~
semantic.d:10818:156: error: no member 'type' for type 'Parameter[]'
						sc.error(format("incompatible argument type '%s' for 'ref' parameter of type '%s'",args[i].type.toString(),p.type.toString()),args[i].loc);
                                                                                                                                                           ^~~~~~
semantic.d:10823:48: error: no member 'stc' for type 'Parameter[]'
					assert(p.stc&STCout);
                                               ^~~~~
semantic.d:10823:54: error: undefined identifier 'STCout'
					assert(p.stc&STCout);
                                                     ^~~~~~
semantic.d:10828:56: error: no member 'type' for type 'Parameter[]'
					auto irconvd = p.type.refConvertsTo(args[i].type,1);
                                                       ^~~~~~
semantic.d:10830:58: error: undefined identifier 'format'
						sc.error(format("incompatible argument type '%s' for 'out' parameter of type '%s'", args[i].type, p.type),args[i].loc);
                                                         ^~~~~~
semantic.d:10830:147: error: no member 'type' for type 'Parameter[]'
						sc.error(format("incompatible argument type '%s' for 'out' parameter of type '%s'", args[i].type, p.type),args[i].loc);
                                                                                                                                                  ^~~~~~
semantic.d:7538:24: error: undefined identifier 'string'
	private static string __dgliteralTail(){ // TODO: maybe memoize this?
                       ^~~~~~
semantic.d:7538:24: error: undefined identifier 'string'
	private static string __dgliteralTail(){ // TODO: maybe memoize this?
                       ^~~~~~
semantic.d:7538:24: error: undefined identifier 'string'
	private static string __dgliteralTail(){ // TODO: maybe memoize this?
                       ^~~~~~
semantic.d:7538:24: error: undefined identifier 'string'
	private static string __dgliteralTail(){ // TODO: maybe memoize this?
                       ^~~~~~
semantic.d:7501:29: error: no member 'getImmutable' for type 'Type'
		else return ty.getImmutable();
                            ^~~~~~~~~~~~~~~
semantic.d:7496:55: error: no member 'getConst' for type 'Type'
		else static if(is(T==InoutTy)) return ty.getConst().getInout();
                                                      ^~~~~~~~~~~
semantic.d:7501:29: error: no member 'getImmutable' for type 'Type'
		else return ty.getImmutable();
                            ^~~~~~~~~~~~~~~
semantic.d:7495:56: error: no member 'getConst' for type 'Type'
		else static if(is(T==SharedTy)) return ty.getConst().getShared();
                                                       ^~~~~~~~~~~
semantic.d:7405:42: error: no member 'stringof' for type 'InoutTy'
		if(auto d=mixin(`rhs.is`~T.stringof)()) return ty.equals(d.ty);
                                         ^~~~~~~~~~
semantic.d:7405:42: error: no member 'stringof' for type 'ImmutableTy'
		if(auto d=mixin(`rhs.is`~T.stringof)()) return ty.equals(d.ty);
                                         ^~~~~~~~~~
semantic.d:7405:42: error: no member 'stringof' for type 'SharedTy'
		if(auto d=mixin(`rhs.is`~T.stringof)()) return ty.equals(d.ty);
                                         ^~~~~~~~~~
semantic.d:7405:42: error: no member 'stringof' for type 'ConstTy'
		if(auto d=mixin(`rhs.is`~T.stringof)()) return ty.equals(d.ty);
                                         ^~~~~~~~~~
semantic.d:7273:29: error: no member 'stringof' for type 'InoutTy'
	private enum qual = T.stringof[0..$-2];
                            ^~~~~~~~~~
semantic.d:7273:29: error: no member 'stringof' for type 'ImmutableTy'
	private enum qual = T.stringof[0..$-2];
                            ^~~~~~~~~~
type.d:193:18: error: undefined identifier 'string'
	override string toString(){return _brk("typeof(return)");}
                 ^~~~~~
semantic.d:7273:29: error: no member 'stringof' for type 'SharedTy'
	private enum qual = T.stringof[0..$-2];
                            ^~~~~~~~~~
semantic.d:7273:29: error: no member 'stringof' for type 'ConstTy'
	private enum qual = T.stringof[0..$-2];
                            ^~~~~~~~~~
semantic.d:7511:64: error: no member 'getInout' for type 'Type'
			else static if(is(T==SharedTy)) return ty.getInout().getShared();
                                                               ^~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
type.d:305:18: error: undefined identifier 'string'
	override string toString(){return _brk("const("~e.toString()~')');}
                 ^~~~~~
type.d:329:18: error: undefined identifier 'string'
	override string toString(){return _brk("inout("~e.toString()~')');}
                 ^~~~~~
type.d:321:18: error: undefined identifier 'string'
	override string toString(){return _brk("shared("~e.toString()~')');}
                 ^~~~~~
type.d:313:18: error: undefined identifier 'string'
	override string toString(){return _brk("immutable("~e.toString()~')');}
                 ^~~~~~
semantic.d:1732:18: error: undefined identifier 'string'
	override string toString(){return "<<MT("~adapted.to!string()~")>>";}
                 ^~~~~~
semantic.d:7501:29: error: no member 'getImmutable' for type 'Type'
		else return ty.getImmutable();
                            ^~~~~~~~~~~~~~~
semantic.d:7335:39: error: no member 'isImmutableTy' for type 'Type'
			if(auto imm = from.isImmutableTy()){
                                      ^~~~~~~~~~~~~~~~~~
semantic.d:7356:25: error: unimplemented feature SwitchStm
			final switch(res){
                        ^~~~~~~~~~~~~~~~~~
semantic.d:7519:20: error: undefined identifier 'hunqualType'
		if(hunqualType) return hunqualType;
                   ^~~~~~~~~~~
semantic.d:7524:20: error: undefined identifier 'unqualType'
		if(unqualType) return unqualType;
                   ^~~~~~~~~~
semantic.d:7519:20: error: undefined identifier 'hunqualType'
		if(hunqualType) return hunqualType;
                   ^~~~~~~~~~~
semantic.d:7524:20: error: undefined identifier 'unqualType'
		if(unqualType) return unqualType;
                   ^~~~~~~~~~
semantic.d:7524:20: error: undefined identifier 'unqualType'
		if(unqualType) return unqualType;
                   ^~~~~~~~~~
semantic.d:7519:20: error: undefined identifier 'hunqualType'
		if(hunqualType) return hunqualType;
                   ^~~~~~~~~~~
semantic.d:7519:20: error: undefined identifier 'hunqualType'
		if(hunqualType) return hunqualType;
                   ^~~~~~~~~~~
type.d:113:18: error: undefined identifier 'string'
	override string toString(){return _brk("__error");}
                 ^~~~~~
semantic.d:7524:20: error: undefined identifier 'unqualType'
		if(unqualType) return unqualType;
                   ^~~~~~~~~~
semantic.d:7524:39: error: undefined identifier 'unqualType'
		if(unqualType) return unqualType;
                                      ^~~~~~~~~~
semantic.d:7519:40: error: undefined identifier 'hunqualType'
		if(hunqualType) return hunqualType;
                                       ^~~~~~~~~~~
semantic.d:7519:40: error: undefined identifier 'hunqualType'
		if(hunqualType) return hunqualType;
                                       ^~~~~~~~~~~
semantic.d:7519:40: error: undefined identifier 'hunqualType'
		if(hunqualType) return hunqualType;
                                       ^~~~~~~~~~~
semantic.d:7519:40: error: undefined identifier 'hunqualType'
		if(hunqualType) return hunqualType;
                                       ^~~~~~~~~~~
semantic.d:7524:39: error: undefined identifier 'unqualType'
		if(unqualType) return unqualType;
                                      ^~~~~~~~~~
semantic.d:7525:24: error: undefined identifier 'unqualType'
		return unqualType=ty.getUnqual();
                       ^~~~~~~~~~
semantic.d:7524:39: error: undefined identifier 'unqualType'
		if(unqualType) return unqualType;
                                      ^~~~~~~~~~
semantic.d:7524:39: error: undefined identifier 'unqualType'
		if(unqualType) return unqualType;
                                      ^~~~~~~~~~
semantic.d:7520:24: error: undefined identifier 'hunqualType'
		return hunqualType=mixin(`ty.getHeadUnqual().getTail`~qual)();
                       ^~~~~~~~~~~
semantic.d:7520:24: error: undefined identifier 'hunqualType'
		return hunqualType=mixin(`ty.getHeadUnqual().getTail`~qual)();
                       ^~~~~~~~~~~
semantic.d:7520:24: error: undefined identifier 'hunqualType'
		return hunqualType=mixin(`ty.getHeadUnqual().getTail`~qual)();
                       ^~~~~~~~~~~
semantic.d:7520:24: error: undefined identifier 'hunqualType'
		return hunqualType=mixin(`ty.getHeadUnqual().getTail`~qual)();
                       ^~~~~~~~~~~
semantic.d:7525:24: error: undefined identifier 'unqualType'
		return unqualType=ty.getUnqual();
                       ^~~~~~~~~~
semantic.d:7525:24: error: undefined identifier 'unqualType'
		return unqualType=ty.getUnqual();
                       ^~~~~~~~~~
semantic.d:7525:24: error: undefined identifier 'unqualType'
		return unqualType=ty.getUnqual();
                       ^~~~~~~~~~
semantic.d:7084:24: error: undefined identifier 'r'
		assert(r !is this);
                       ^
semantic.d:7505:29: error: no member 'getSharedImpl' for type 'QualifiedTy'
		else return super.getSharedImpl();
                            ^~~~~~~~~~~~~~~~~~~
semantic.d:7505:29: error: no member 'getSharedImpl' for type 'QualifiedTy'
		else return super.getSharedImpl();
                            ^~~~~~~~~~~~~~~~~~~
semantic.d:7565:51: error: no member 'inSharedContext' for type 'Type'
		static if(is(T==SharedTy)) return ty.inSharedContext();
                                                  ^~~~~~~~~~~~~~~~~~
semantic.d:7569:50: error: no member 'inInoutContext' for type 'Type'
		static if(is(T==InoutTy)) return ty.inInoutContext();
                                                 ^~~~~~~~~~~~~~~~~
semantic.d:7558:50: error: no member 'inConstContext' for type 'Type'
		static if(is(T==ConstTy)) return ty.inConstContext();
                                                 ^~~~~~~~~~~~~~~~~
<mixin@semantic.d:7293>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@semantic.d:7293>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@semantic.d:7293>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@semantic.d:7293>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
type.d:245:18: error: undefined identifier 'string'
	override string toString(){return _brk(TokenTypeToString(op));}
                 ^~~~~~
type.d:240:14: error: undefined identifier 'TokenType'
	this(TokenType op)in{assert(strength[op]||op==Tok!"void");}body{
             ^~~~~~~~~
type.d:239:9: error: undefined identifier 'TokenType'
	TokenType op;
        ^~~~~~~~~
<mixin@semantic.d:7840>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
interpret.d:3687:42: error: can only instantiate templates, not types
			}else foreach(T; TypeTuple!(float, double, real)){ // TODO: imaginary/complex
                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3694:34: error: can only instantiate templates, not types
		}else foreach(T; TypeTuple!(float, double, real)){
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:7293>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:7293>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:7293>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:7293>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3729:64: error: cannot cast expression 'tt' of type 'Type' to 'void*'
			bld.emitConstant(cast(ulong)cast(void*)tt);
                                                               ^~
interpret.d:3742:39: error: no member 'sizeof' for type 'Type'
			static assert(Type.sizeof<=ulong.sizeof);
                                      ^~~~~~~~~~~
interpret.d:3742:52: error: no member 'sizeof' for type 'ulong'
			static assert(Type.sizeof<=ulong.sizeof);
                                                   ^~~~~~~~~~~~
interpret.d:3743:64: error: cannot cast expression 't2' of type 'Type' to 'void*'
			bld.emitConstant(cast(ulong)cast(void*)t2);
                                                               ^~
interpret.d:3753:29: error: no member 'isDynArrTy' for type 'Type'
		if(auto dyn=t1.isDynArrTy()){
                            ^~~~~~~~~~~~~
interpret.d:3754:37: error: no member 'isPointerTy' for type 'Type'
			if(auto ptr=t2.isPointerTy()){
                                    ^~~~~~~~~~~~~~
interpret.d:3757:62: error: no member 'getPointer' for type 'Type'
					castToVoidPtrOrArray(t1.getElementType().getPointer());
                                                             ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3770:27: error: undefined identifier 'format'
		bld.error(format("cannot interpret cast from '%s' to '%s' at compile time", e.type,type),loc);
                          ^~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:7840>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
<mixin@semantic.d:7293>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:7293>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:7293>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:7293>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:7840>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:7337:45: error: no member 'isConstTy' for type 'Type'
			}else if(auto con = from.isConstTy()){
                                            ^~~~~~~~~~~~~~
semantic.d:7300:50: error: no member 'getInout' for type 'Type'
		else static if(is(T==InoutTy)) r=ty.getInout();
                                                 ^~~~~~~~~~~
semantic.d:7297:45: error: no member 'getConst' for type 'Type'
		static if(is(T==ConstTy)) r=ty.getConst();
                                            ^~~~~~~~~~~
semantic.d:7299:51: error: no member 'getShared' for type 'Type'
		else static if(is(T==SharedTy)) r=ty.getShared();
                                                  ^~~~~~~~~~~~
semantic.d:7298:54: error: no member 'getImmutable' for type 'Type'
		else static if(is(T==ImmutableTy)) r=ty.getImmutable();
                                                     ^~~~~~~~~~~~~~~
semantic.d:7340:45: error: no member 'isSharedTy' for type 'Type'
			}else if(auto sha = from.isSharedTy()){
                                            ^~~~~~~~~~~~~~~
semantic.d:7841:21: error: undefined identifier 'f'
		if(!f) f = e;
                    ^
semantic.d:7841:24: error: undefined identifier 'f'
		if(!f) f = e;
                       ^
semantic.d:7842:17: error: undefined identifier 'f'
		f.weakenAccessCheck(AccessCheck.none);
                ^
semantic.d:7343:45: error: no member 'isInoutTy' for type 'Type'
			}else if(auto ino = from.isInoutTy()){
                                            ^~~~~~~~~~~~~~
semantic.d:7349:32: error: no member 'getTailInout' for type 'Type'
			return ty.getTailInout().adaptToImpl(from.getHeadUnqual(), res).getInout();
                               ^~~~~~~~~~~~~~~
semantic.d:7846:20: error: undefined identifier 'f'
		if(f.isType()){
                   ^
semantic.d:7847:34: error: undefined identifier 'format'
			sc.error(format("typeof argument '%s' is not an expression",e.loc.rep),e.loc);
                                 ^~~~~~
<mixin@<mixin@semantic.d:7848>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:7848>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:7849:17: error: undefined identifier 'f'
        }else e=f;
                ^
semantic.d:7856:26: error: undefined identifier 'f'
		assert(!!f.type && f.type.sstate == SemState.completed,to!string(e)~" : "~to!string(f.type));
                         ^
semantic.d:7856:36: error: undefined identifier 'f'
		assert(!!f.type && f.type.sstate == SemState.completed,to!string(e)~" : "~to!string(f.type));
                                   ^
semantic.d:7856:72: error: undefined identifier 'to'
		assert(!!f.type && f.type.sstate == SemState.completed,to!string(e)~" : "~to!string(f.type));
                                                                       ^~
semantic.d:7856:91: error: undefined identifier 'to'
		assert(!!f.type && f.type.sstate == SemState.completed,to!string(e)~" : "~to!string(f.type));
                                                                                          ^~
semantic.d:7856:101: error: undefined identifier 'f'
		assert(!!f.type && f.type.sstate == SemState.completed,to!string(e)~" : "~to!string(f.type));
                                                                                                    ^
semantic.d:7858:24: error: undefined identifier 'f'
		auto r=f.type;
                       ^
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
type.d:188:18: error: undefined identifier 'string'
	override string toString(){return _brk("typeof("~e.toString()~")");}
                 ^~~~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(TypeTuple)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
semantic.d:6636:24: error: undefined identifier 'string'
	private static string __dgliteralQual(){
                       ^~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
semantic.d:956:18: error: undefined identifier 'size_t'
	override size_t tmplArgToHash(){
                 ^~~~~~
semantic.d:7662:42: error: no member 'stringof' for type 'ArrayTy'
		if(auto c=mixin(`rhs.is`~T.stringof)()){
                                         ^~~~~~~~~~
semantic.d:7764:70: error: no member 'stringof' for type 'ArrayTy'
	private enum puthead = "get"~(is(T==ArrayTy)?"Array(length)":typeof(this).stringof[0..$-2]~"()");
                                                                     ^~~~~~~~~~~~~~~~~~~~~
semantic.d:7641:62: error: no member 'stringof' for type 'ArrayTy'
		if(auto tt = mixin(`from.getHeadUnqual().is`~T.stringof)()){
                                                             ^~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
semantic.d:890:45: error: undefined identifier 'string'
	static Expression polyStringFactory(string value){
                                            ^~~~~~
type.d:283:18: error: undefined identifier 'string'
	override string toString(){return _brk(e.toString()~'['~to!string(length)~']');}
                 ^~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
expression.d:192:18: error: undefined identifier 'string'
	override string toString(){
                 ^~~~~~
semantic.d:6135:35: error: need 'this' to access member function 'LiteralExp.factory'
				r=LiteralExp.factory(Variant(tp.length, Type.get!Size_t()));
                                  ^~~~~~~~~~~~~~~~~~
semantic.d:879:9: note: member function was declared here
	static Expression factory(Variant value)in{
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
variant.d:323:34: error: need 'this' to access member function 'LiteralExp.factory'
			auto r = LiteralExp.factory(this);
                                 ^~~~~~~~~~~~~~~~~~
semantic.d:879:9: note: member function was declared here
	static Expression factory(Variant value)in{
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:6144>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:6144>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:953:24: error: incompatible types 'Variant' and 'Variant' for binary ==
		return interpretV()==rhs.interpretV();
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:7630>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@semantic.d:6569>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
interpret.d:3618:35: error: no member 'getDynArr' for type 'Type'
		emitMakeArray(bld,type.getDynArr(), 1);
                                  ^~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:7630>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:6569>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:7630>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:6569>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:898>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:898>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:898>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:6571>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:6571>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
type.d:179:18: error: undefined identifier 'string'
	override string toString(){return (ft.rret&&!ft.ret?ft.rret.toString():ft.ret?ft.ret.toString:"auto")~" delegate"~ft.pListToString();}
                 ^~~~~~
interpret.d:5419:55: error: no member 'init' for type 'long'
		if(outer is null) outer = new VarDecl(STC.init, null, new Identifier("$__outerContext"), null);
                                                      ^~~~~~~~
<mixin@<mixin@semantic.d:900>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:900>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8500:14: error: declaration of 'type' smells suspicously fishy
	Type type;
             ^~~~
interpret.d:4364:47: note: this lookup should have succeeded if it was valid
		size_t off, len = getBCSizeof(type);
                                              ^~~~
semantic.d:8502:22: error: declaration of 'tupleContext' smells suspicously fishy
	TupleContext tupleContext;
                     ^~~~~~~~~~~~
interpret.d:4357:35: note: this lookup should have succeeded if it was valid
			foreach(x;tupleContext.vds){
                                  ^~~~~~~~~~~~
semantic.d:8546:21: error: cannot cast expression 'init' of type 'Expression' to 'bool'
		if(!init && type && type.sstate == SemState.completed){
                    ^~~~
semantic.d:8721:43: error: no member 'isArrayLiteralExp' for type 'Expression'
		assert(init.isConstant()||init.isArrayLiteralExp());
                                          ^~~~~~~~~~~~~~~~~~~~~~
semantic.d:8723:20: error: no member 'isDynArrTy' for type 'Type'
		if(init.type.isDynArrTy()&&init.type.getElementType().isMutable()){
                   ^~~~~~~~~~~~~~~~~~~~
declaration.d:377:18: error: undefined identifier 'string'
	override string toString(){return (stc?STCtoString(astStc)~" ":"")~(rtype?rtype.toString()~" ":type?type.toString()~" ":"")~(name?name.toString():"")~(init?"="~init.toString():"")~";";}
                 ^~~~~~
semantic.d:6309:20: error: cannot cast expression 'me.name' of type 'Identifier' to 'bool'
		if(me.name)
                   ^~~~~~~
semantic.d:6310:34: error: undefined identifier 'format'
			sc.error(format("%s '%s' has invalid type '%s'", me.kind, me.name, this), me.loc);
                                 ^~~~~~
<mixin@<mixin@semantic.d:4333>:7>:1:4: error: cannot cast expression 'circ' of type 'Symbol' to 'bool'
if(circ){circErrMsg(); mixin(SemCheck);}
   ^~~~
semantic.d:4339:46: error: undefined identifier 'STCstatic'
				   !(vd.stc&(STCstatic|STCenum)))
                                             ^~~~~~~~~
semantic.d:4339:56: error: undefined identifier 'STCenum'
				   !(vd.stc&(STCstatic|STCenum)))
                                                       ^~~~~~~
semantic.d:8732:28: error: undefined identifier 'string'
	override @property string kind(){
                           ^~~~~~
interpret.d:4407:27: error: undefined identifier 'format'
		bld.error(format("cannot interpret local variable of type '%s' at compile time yet.",type.toString()),loc);		
                          ^~~~~~
interpret.d:4416:28: error: cannot cast expression 'name' of type 'Identifier' to 'bool'
			if(name)
                           ^~~~
interpret.d:4417:43: error: undefined identifier 'format'
				bld.error(format("cannot access variable '%s' at compile time", name.toString()), loader.loc);
                                          ^~~~~~
declaration.d:375:67: error: current object 'super' of type 'Declaration' is not callable
		this.stc=stc; this.rtype=rtype; init=initializer; super(stc,name);
                                                                  ^~~~~~~~~~~~~~~
semantic.d:4343:35: error: undefined identifier 'STCenum'
			if(vd.stc&STCenum){
                                  ^~~~~~~
semantic.d:4350:34: error: no member 'isFunctionDecl' for type 'Declaration'
		}else if(auto fd=meaning.isFunctionDecl()){
                                 ^~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:4356>:1:4: error: cannot cast expression 'circ' of type 'Symbol' to 'bool'
if(circ){circErrMsg(); mixin(SemCheck);}
   ^~~~
semantic.d:4364:34: error: no member 'isTemplateDecl' for type 'Declaration'
		}else if(auto tm=meaning.isTemplateDecl()){
                                 ^~~~~~~~~~~~~~~~~~~~~~
interpret.d:4485:17: error: undefined identifier 'size_t'
		size_t len, off = getBCLoc(len);
                ^~~~~~
interpret.d:4485:17: error: undefined identifier 'size_t'
		size_t len, off = getBCLoc(len);
                ^~~~~~
semantic.d:8509:20: error: cannot cast expression 'auto decl=sc.getDeclaration()' of type 'Declaration' to 'bool'
		if(auto decl=sc.getDeclaration())
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8510:40: error: no member 'isAggregateDecl' for type 'Declaration'
			if(auto aggr = decl.isAggregateDecl())
                                       ^~~~~~~~~~~~~~~~~~~~
semantic.d:6312:34: error: undefined identifier 'format'
			sc.error(format("%s has invalid type '%s'", me.kind, this), me.loc);
                                 ^~~~~~
semantic.d:8548:38: error: no member 'isAggregateTy' for type 'Type'
			if(auto aggr=type.getUnqual().isAggregateTy())
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:4367:69: error: no member 'init' for type 'Expression[]'
				auto r = New!TemplateInstanceExp(s, (Expression[]).init);
                                                                    ^~~~~~~~~~~~~~~~~~~
semantic.d:4375:34: error: no member 'isTemplateInstanceDecl' for type 'Declaration'
		}else if(auto tm=meaning.isTemplateInstanceDecl()){
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:4381>:1:4: error: cannot cast expression 'circ' of type 'Symbol' to 'bool'
if(circ){circErrMsg(); mixin(SemCheck);}
   ^~~~
semantic.d:4385:34: error: no member 'isOverloadSet' for type 'Declaration'
		}else if(auto ov=meaning.isOverloadSet()){
                                 ^~~~~~~~~~~~~~~~~~~~~
semantic.d:4415:29: error: cannot cast expression 'type' of type 'Type' to 'bool'
			if(!type) type=Type.get!void(); // TODO: fix
                            ^~~~
semantic.d:4417:25: error: feature TypeidExp not implemented
		else if(typeid(this.meaning) is typeid(ErrorDecl)){mixin(ErrEplg);}
                        ^~~~~~~~~~~~~~~~~~~~
semantic.d:4417:49: error: feature TypeidExp not implemented
		else if(typeid(this.meaning) is typeid(ErrorDecl)){mixin(ErrEplg);}
                                                ^~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:4417>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:4417>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:4420>:1:4: error: cannot cast expression 'circ' of type 'Symbol' to 'bool'
if(circ){circErrMsg(); mixin(SemCheck);}
   ^~~~
semantic.d:4422:45: error: no member 'isFunctionDecl' for type 'Declaration'
		assert(needParamDeduction||!meaning.isFunctionDecl()||(cast(FunctionTy)type).ret);
                                            ^~~~~~~~~~~~~~~~~~~~~~
semantic.d:4422:88: error: cannot cast expression 'type' of type 'Type' to 'FunctionTy'
		assert(needParamDeduction||!meaning.isFunctionDecl()||(cast(FunctionTy)type).ret);
                                                                                       ^~~~
semantic.d:4424:28: error: no member 'isAggregateDecl' for type 'Declaration'
		if(auto at=meaning.isAggregateDecl()){
                           ^~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8550:63: error: no member 'init' for type 'Expression[]'
				init = New!StructConsExp(type,(Expression[]).init);
                                                              ^~~~~~~~~~~~~~~~~~~
semantic.d:8724:38: error: no member 'isLiteralExp' for type 'Expression'
			if(auto lexp=init.isLiteralExp()){
                                     ^~~~~~~~~~~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
semantic.d:5349:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
<mixin@semantic.d:8564>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
semantic.d:8541:29: error: undefined identifier 'STCenum'
		return stc&(STCenum|STCstatic) || isField;
                            ^~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
semantic.d:2354:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
semantic.d:2348:18: error: undefined identifier 'string'
	override string toString(){
                 ^~~~~~
semantic.d:2347:18: error: undefined identifier 'string'
	override string kind(){return "template instance";}
                 ^~~~~~
semantic.d:2305:21: error: cannot cast expression 'constraintScope' of type 'Scope' to 'bool'
		if(!constraintScope){
                    ^~~~~~~~~~~~~~~
semantic.d:2166:31: error: type 'Scheduler' is not callable
		if(!isGagged) Scheduler().add(this, scope_);
                              ^~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
semantic.d:2004:25: error: no member 'type' for type 'Parameter[]'
			x.type = x.rtype.typeSemantic(iftiScope);
                        ^~~~~~
semantic.d:2004:34: error: no member 'rtype' for type 'Parameter[]'
			x.type = x.rtype.typeSemantic(iftiScope);
                                 ^~~~~~~
semantic.d:1814:17: error: current object 'this' of type 'TemplateInstanceDecl' is not callable
		this(parent, loc, func, args);
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8564>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4487:33: error: undefined identifier 'STCimmutable'
			if(stc&(STCimmutable|STCconst)&&init){
                                ^~~~~~~~~~~~
semantic.d:4430:28: error: no member 'isEnumDecl' for type 'Declaration'
		if(auto et=meaning.isEnumDecl()){
                           ^~~~~~~~~~~~~~~~~~
semantic.d:10445:34: error: cannot cast expression 'rewriteIfOk' of type 'FunctionDecl' to 'bool'
			assert(!!rewriteIfOk);
                                 ^~~~~~~~~~~
<mixin@semantic.d:8564>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8560>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
semantic.d:8541:37: error: undefined identifier 'STCstatic'
		return stc&(STCenum|STCstatic) || isField;
                                    ^~~~~~~~~
semantic.d:10450:21: error: cannot cast expression 'gscope' of type 'GaggingScope' to 'bool'
		if(!gscope) gscope = New!GaggingScope(sc_);
                    ^~~~~~
<mixin@<mixin@semantic.d:8560>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:1898:47: error: undefined identifier 'min'
		foreach(i,x; parent.params[0..min(parent.tuplepos,resolved.length)])
                                              ^~~
<mixin@semantic.d:2283>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
semantic.d:2006:29: error: no member 'type' for type 'Parameter[]'
			if(!x.type) continue; // mixin(ErrEplg); // TODO: error message
                            ^~~~~~
semantic.d:2007:25: error: no member 'type' for type 'Parameter[]'
			x.type = x.type.applySTC(x.stc);
                        ^~~~~~
semantic.d:2007:34: error: no member 'type' for type 'Parameter[]'
			x.type = x.type.applySTC(x.stc);
                                 ^~~~~~
semantic.d:2007:50: error: no member 'stc' for type 'Parameter[]'
			x.type = x.type.applySTC(x.stc);
                                                 ^~~~~
semantic.d:2197:25: error: unimplemented feature SwitchStm
		Ldecide:final switch(matchState) with(MatchState){
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:2326:28: error: no member 'sstate' for type 'Parameter[]'
			if(x.sstate == SemState.error)
                           ^~~~~~~~
semantic.d:10454:29: error: cannot cast expression 'x' of type 'Declaration[]' to 'bool'
			if(!x) continue;
                            ^
<mixin@<mixin@semantic.d:2283>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8565:20: error: cannot cast expression 'rtype' of type 'Expression' to 'bool'
		if(rtype){
                   ^~~~~
semantic.d:10455:48: error: cannot cast expression 'eponymous[i]' of type 'Expression' to 'bool'
			if(eponymous.length && eponymous[i]) continue;
                                               ^~~~~~~~~~~~
<mixin@semantic.d:2283>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:10457:29: error: no member 'isTemplateInstanceDecl' for type 'Declaration[]'
			if(!x.isTemplateInstanceDecl()
                            ^~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:10458:67: error: cannot cast expression 'x' of type 'Declaration[]' to 'void*'
			|| !(cast(TemplateInstanceDecl)cast(void*)x).completedMatching){
                                                                  ^
semantic.d:10459:33: error: no member 'semantic' for type 'Declaration[]'
				x.semantic(null);
                                ^~~~~~~~~~
semantic.d:4447:48: error: no member 'init' for type 'Expression[]'
			auto r = New!CallExp(s,(Expression[]).init);
                                               ^~~~~~~~~~~~~~~~~~~
semantic.d:2286:17: error: feature not implemented
		scope(exit) if(sstate == SemState.started) sstate = SemState.begin;
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:2287:25: error: cannot cast expression 'constraint' of type 'Expression' to 'bool'
		assert(!constraint||constraint.type is Type.get!bool());
                        ^~~~~~~~~~
semantic.d:2288:25: error: cannot cast expression 'constraint' of type 'Expression' to 'bool'
		assert(!constraint||constraint.isConstant() && constraint.interpretV());
                        ^~~~~~~~~~
semantic.d:2288:64: error: cannot cast expression 'constraint.interpretV()' of type 'Variant' to 'bool'
		assert(!constraint||constraint.isConstant() && constraint.interpretV());
                                                               ^~~~~~~~~~~~~~~~~~~~~~~
semantic.d:2291:17: error: feature not implemented
		scope(exit) if(sstate == SemState.error)
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4475:30: error: undefined identifier 'STClazy'
		}else if(stc&STClazy){
                             ^~~~~~~
semantic.d:4455:21: error: no member 'isFunctionDecl' for type 'Declaration'
		   !meaning.isFunctionDecl().maybe!(a=>a.isConstructor()) &&
                    ^~~~~~~~~~~~~~~~~~~~~~
semantic.d:4456:21: error: no member 'isOverloadSet' for type 'Declaration'
		   !meaning.isOverloadSet().maybe!(a=>a.isConstructor())
                    ^~~~~~~~~~~~~~~~~~~~~
semantic.d:1828:53: error: cannot cast expression 'scope_' of type 'Scope' to 'GaggingRecordingScope'
		assert(!!cast(GaggingRecordingScope)scope_);
                                                    ^~~~~~
semantic.d:1829:56: error: cannot cast expression 'scope_' of type 'Scope' to 'void*'
		(cast(GaggingRecordingScope)cast(void*)scope_).replay(parentScope);
                                                       ^~~~~~
semantic.d:10461:36: error: no member 'sstate' for type 'Declaration[]'
				if(x.sstate == SemState.error) continue;
                                   ^~~~~~~~
semantic.d:10464:60: error: cannot cast expression 'x' of type 'Declaration[]' to 'TemplateInstanceDecl'
			assert(!!cast(TemplateInstanceDecl)x);
                                                           ^
semantic.d:10465:74: error: cannot cast expression 'x' of type 'Declaration[]' to 'void*'
			auto inst = cast(TemplateInstanceDecl)cast(void*)x;
                                                                         ^
semantic.d:10475:41: error: no member 'semantic' for type 'Declaration[]'
					x.semantic(sc_);
                                        ^~~~~~~~~~
<mixin@<mixin@semantic.d:4469>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:4469>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:1833:17: error: type 'Scheduler' is not callable
		Scheduler().add(this, scope_);
                ^~~~~~~~~~~
interpret.d:4487:46: error: undefined identifier 'STCconst'
			if(stc&(STCimmutable|STCconst)&&init){
                                             ^~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
interpret.d:4488:40: error: undefined identifier 'STCstatic'
				if(stc&STCstatic){
                                       ^~~~~~~~~
semantic.d:10485:105: error: no member 'name' for type 'Declaration[]'
					auto be=New!(BinaryExp!(Tok!"."))(New!Symbol(x), New!Identifier(x.name.name));
                                                                                                        ^~~~~~
semantic.d:8570:20: error: cannot cast expression 'init' of type 'Expression' to 'bool'
		if(init){
                   ^~~~
semantic.d:2332:17: error: feature not implemented
		scope(exit) matchState = MatchState.checkConstraint;
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4480:47: error: undefined identifier 'STClazy'
		assert(!(stc&STCbyref)||!(stc&STClazy));
                                              ^~~~~~~
semantic.d:2016:41: error: undefined identifier 'min'
		foreach(i,a;iftiArgs[0..min($,iftiEponymousParameters.length)])
                                        ^~~
semantic.d:10497:46: error: cannot cast expression 'x' of type 'Expression[]' to 'bool'
		foreach(ref x; eponymous) if(x){
                                             ^
semantic.d:10498:25: error: no member 'semantic' for type 'Expression[]'
			x.semantic(gscope);
                        ^~~~~~~~~~
semantic.d:10501:36: error: no member 'isSymbol' for type 'Expression[]'
			auto sym = x.isSymbol();
                                   ^~~~~~~~~~
interpret.d:4489:59: error: type 'VarDecl' is not an expression
					static LiteralExp[VarDecl] decls;
                                                          ^~~~~~~
<mixin@<mixin@semantic.d:2295>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:2295>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4491:72: error: cannot cast expression 'init' of type 'Expression' to 'LiteralExp'
						assert(cast(LiteralExp)init,text(init," ",));
                                                                       ^~~~
semantic.d:2044:29: error: no member 'filter' for type 'Parameter[]'
		auto numt = iftiEponymousParameters.filter!((a){
                            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4491:77: error: undefined identifier 'text'
						assert(cast(LiteralExp)init,text(init," ",));
                                                                            ^~~~
semantic.d:2049:21: error: undefined identifier 'size_t'
		for(size_t i=0,j=0;i<iftiEponymousParameters.length&&j<=iftiArgs.length;){
                    ^~~~~~
semantic.d:8577:29: error: cannot cast expression 'type' of type 'Type' to 'bool'
			if(!type && init.sstate!=SemState.error) type=init.type;
                            ^~~~
semantic.d:8578:27: error: cannot cast expression 'rtype' of type 'Expression' to 'bool'
		}else if(!rtype && !type){
                          ^~~~~
semantic.d:8578:37: error: cannot cast expression 'type' of type 'Type' to 'bool'
		}else if(!rtype && !type){
                                    ^~~~
semantic.d:10504:54: error: undefined identifier 'MatchCall'
				{alias sc_ sc; mixin(MatchCall!q{x; x, null, loc, args});}
                                                     ^~~~~~~~~
semantic.d:8579:34: error: undefined identifier 'format'
			sc.error(format("initializer required for '%s' declaration",STCtoString(stc)),loc);
                                 ^~~~~~
semantic.d:10505:37: error: cannot cast expression 'x' of type 'Expression[]' to 'bool'
				if(!x) continue;
                                    ^
semantic.d:2054:42: error: undefined identifier 'min'
				auto num=min(iftiArgs.length-j,
                                         ^~~
semantic.d:2060:39: error: undefined identifier 'util'
				alias util.any any;
                                      ^~~~
semantic.d:2063:46: error: undefined identifier 'map'
				auto types = map!(_=>_.type.getHeadUnqual())(iftiArgs[j..j+num]).toTemplArgs;
                                             ^~~
<mixin@<mixin@semantic.d:8580>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8580>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8582:46: error: cannot cast expression 'name' of type 'Identifier' to 'bool'
		if(sstate == SemState.pre && name){ // insert into scope
                                             ^~~~
semantic.d:10513:45: error: undefined identifier 'DetermineFunctionMatches'
			alias sc_ sc; mixin(DetermineFunctionMatches!q{matches; this});
                                            ^~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4494:77: error: incompatible types 'Variant*' and 'Variant*' for binary -
						auto p=Variant([FieldAccess(s.ptr-s.ptr)], s, type.getPointer());
                                                                            ^~~~~~~~~~~
semantic.d:8588:21: error: cannot cast expression 'type' of type 'Type' to 'bool'
		if(!type||type.sstate==SemState.error||rtype&&rtype.sstate==SemState.error){
                    ^~~~
semantic.d:8588:56: error: cannot cast expression 'rtype' of type 'Expression' to 'bool'
		if(!type||type.sstate==SemState.error||rtype&&rtype.sstate==SemState.error){
                                                       ^~~~~
<mixin@<mixin@semantic.d:8590>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8590>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4494:95: error: no member 'getPointer' for type 'Type'
						auto p=Variant([FieldAccess(s.ptr-s.ptr)], s, type.getPointer());
                                                                                              ^~~~~~~~~~~~~~~
semantic.d:2066:39: error: undefined identifier 'TypeMatch'
				mixin(TypeMatch!q{_; mt, New!TypeTuple(types)});
                                      ^~~~~~~~~
semantic.d:2087:31: error: undefined identifier 'TypeMatch'
			mixin(TypeMatch!q{_; a.type, iftiType});
                              ^~~~~~~~~
semantic.d:10519:37: error: undefined identifier 'DetermineTemplateMatches'
		{alias sc_ sc;mixin(DetermineTemplateMatches!q{tmatches; this});}
                                    ^~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:2093:49: error: no member 'adapted' for type 'MatcherTy[]'
			if(!resolved[i] && x && x.adapted && !x.ambiguous){
                                                ^~~~~~~~~
interpret.d:4504:59: error: no member 'getDynArr' for type 'Type'
					emitMakeArray(bld,type.getDynArr(), 1);
                                                          ^~~~~~~~~~~~~~
semantic.d:8595:30: error: no member 'isTypeTuple' for type 'Type'
		if(auto tp = type.isTypeTuple()){
                             ^~~~~~~~~~~~~~~~
semantic.d:8598:29: error: cannot cast expression 'tc' of type 'TupleContext' to 'bool'
			if(!tc) tc = New!TupleContext();
                            ^~
interpret.d:4509:35: error: undefined identifier 'format'
			bld.error(format("cannot access variable '%s' at compile time", name.toString()),loader.loc);
                                  ^~~~~~
semantic.d:2093:63: error: no member 'ambiguous' for type 'MatcherTy[]'
			if(!resolved[i] && x && x.adapted && !x.ambiguous){
                                                              ^~~~~~~~~~~
semantic.d:8601:28: error: cannot cast expression 'init' of type 'Expression' to 'bool'
			if(init){
                           ^~~~
semantic.d:8602:36: error: no member 'isExpTuple' for type 'Expression'
				et=init.isExpTuple();
                                   ^~~~~~~~~~~~~~~
semantic.d:8603:37: error: cannot cast expression 'et' of type 'ExpTuple' to 'bool'
				if(!et) tt=init.type.isTypeTuple();
                                    ^~
semantic.d:8603:44: error: no member 'isTypeTuple' for type 'Type'
				if(!et) tt=init.type.isTypeTuple();
                                           ^~~~~~~~~~~~~~~~~~~~~
semantic.d:8604:36: error: cannot cast expression 'et' of type 'ExpTuple' to 'bool'
				if(et||tt){
                                   ^~
semantic.d:8604:40: error: cannot cast expression 'tt' of type 'TypeTuple' to 'bool'
				if(et||tt){
                                       ^~
semantic.d:8605:50: error: cannot cast expression 'et' of type 'ExpTuple' to 'bool'
					if(len!=(et?et.length:tt.length)){
                                                 ^~
semantic.d:2095:45: error: no member 'adapted' for type 'MatcherTy[]'
				resolved[i]=x.adapted;
                                            ^~~~~~~~~
semantic.d:10524:37: error: undefined identifier 'DetermineMostSpecialized'
		{alias sc_ sc;mixin(DetermineMostSpecialized!q{t; set, tmatches, this_, tcontext});}
                                    ^~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:10527:37: error: undefined identifier 'DetermineMostSpecialized'
		{alias sc_ sc;mixin(DetermineMostSpecialized!q{r; set, matches, this_, context});}
                                    ^~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:10531:52: error: cannot cast expression 't' of type 'FunctionDecl' to 'bool'
		if(tcontext.match>context.match && t){
                                                   ^
semantic.d:10535:28: error: cannot cast expression 'sc_' of type 'Scope' to 'bool'
			if(sc_&&inst.isGagged){
                           ^~~
semantic.d:10543:21: error: cannot cast expression 'r' of type 'FunctionDecl' to 'bool'
		if(!r){
                    ^
semantic.d:10544:29: error: cannot cast expression 'set.cand' of type 'FunctionDecl' to 'bool'
			if(!set.cand && !set.altCand || tcontext.match>context.match)
                            ^~~~~~~~
semantic.d:10544:42: error: cannot cast expression 'set.altCand' of type 'FunctionDecl' to 'bool'
			if(!set.cand && !set.altCand || tcontext.match>context.match)
                                         ^~~~~~~~~~~
semantic.d:10547:28: error: cannot cast expression 'sc_' of type 'Scope' to 'bool'
			if(sc_) set.matchError(sc_, loc, this_, args);
                           ^~~
<mixin@<mixin@semantic.d:10548>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:10548>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:10550:28: error: cannot cast expression 'inst' of type 'TemplateInstanceDecl' to 'bool'
			if(inst&&inst.sstate != SemState.completed){
                           ^~~~
semantic.d:8011:21: error: undefined identifier 'mysc'
		if(!mysc) mysc = New!BlockScope(sc);
                    ^~~~
<mixin@semantic.d:1450>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
semantic.d:8011:27: error: undefined identifier 'mysc'
		if(!mysc) mysc = New!BlockScope(sc);
                          ^~~~
semantic.d:8012:32: error: undefined identifier 'mysc'
		super.semantic(mysc);
                               ^~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
statement.d:44:30: error: current object 'super' of type 'CompoundStm' is not callable
	this(Statement[] ss){super(ss);}
                             ^~~~~~~~~
parser.d:182:21: error: no member 'stringof' for type 'BlockStm'
	enum SetLoc=T.stringof~q{
                    ^~~~~~~~~~
<mixin@<mixin@semantic.d:1450>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
parser.d:1080:23: note: instantiated here
		mixin(SetLoc!BlockStm);
                      ^~~~~~~~~~~~~~~
parser.d:1081:24: error: undefined identifier 'res'
		return res=New!BlockStm(parseCompoundStmHelper());
                       ^~~
<mixin@semantic.d:1450>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:1454>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:1454>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:1457>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:1457>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:1467>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:1467>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
interpret.d:453:21: error: cannot cast expression 'cond' of type 'Variant' to 'bool'
		if(!cond){
                    ^~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
interpret.d:455:42: error: undefined identifier 'format'
				sc.error(format("assertion failure: %s is false",a[0].loc.rep), loc);
                                         ^~~~~~
interpret.d:458:64: error: undefined identifier 'string'
				sc.error(expr.interpretV().get!string(), loc);
                                                               ^~~~~~
<mixin@<mixin@interpret.d:460>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@interpret.d:460>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@interpret.d:462>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@interpret.d:462>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(Identifier)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
expression.d:251:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
declaration.d:67:18: error: undefined identifier 'string'
	override string toString(){return "__error ;";}
                 ^~~~~~
declaration.d:65:22: error: no member 'init' for type 'long'
	this(){super(STC.init, null); sstate=SemState.error;}
                     ^~~~~~~~
semantic.d:4041:24: error: undefined identifier 'string'
	private static string __dgliteralRng(){
                       ^~~~~~
<mixin@semantic.d:3991>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:3991>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:3991>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:4003:31: error: undefined identifier 'TypeCombine'
			mixin(TypeCombine!q{type; e2, e3});
                              ^~~~~~~~~~~
semantic.d:4004:29: error: cannot cast expression 'type' of type 'Type' to 'bool'
			if(!type){
                            ^~~~
semantic.d:4005:42: error: undefined identifier 'format'
				sc.error(format("incompatible types for ternary operator: '%s' and '%s'",e2.type,e3.type),loc);
                                         ^~~~~~
<mixin@<mixin@semantic.d:4006>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:4006>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:4016>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:4016>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
expression.d:476:18: error: undefined identifier 'string'
	override string toString(){return _brk(e1.toString() ~ '?' ~ e2.toString() ~ ':' ~ e3.toString());}
                 ^~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
declaration.d:118:40: error: current object 'super' of type 'Declaration' is not callable
	this(STC stc, Identifier name){super(stc, name);}
                                       ^~~~~~~~~~~~~~~~
semantic.d:8794:17: error: undefined identifier 'string'
	private string path;
                ^~~~~~
semantic.d:3067:29: error: no member 'isSymbol' for type 'Expression'
		if(auto sym=inst.isSymbol())
                            ^~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
declaration.d:92:18: error: undefined identifier 'string'
	override string toString(){return (stc?STCtoString(astStc)~" ":"")~"import "~join(map!(to!string)(symbols),", ")~";";}
                 ^~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
declaration.d:91:54: error: current object 'super' of type 'Declaration' is not callable
	this(STC stc, Expression[] sym){symbols=sym; super(stc,null);}
                                                     ^~~~~~~~~~~~~~~
declaration.d:110:18: error: undefined identifier 'string'
	override string toString(){return (stc?STCtoString(astStc)~" ":"")~"enum"~(name?" "~name.toString():"")~(rbase?":"~rbase.toString():"")~
                 ^~~~~~
semantic.d:8975:29: error: no member 'isDeclaration' for type 'Statement'
		if(auto d = bdy.isDeclaration()) d.potentialRemove(sc, decl);
                            ^~~~~~~~~~~~~~~~~
semantic.d:8971:29: error: no member 'isDeclaration' for type 'Statement'
		if(auto d = bdy.isDeclaration()) d.potentialInsert(sc, decl);
                            ^~~~~~~~~~~~~~~~~
declaration.d:109:107: error: current object 'super' of type 'Declaration' is not callable
	this(STC stc,Identifier name, Expression rbase, EnumVarDecl[] mem){this.rbase=rbase; members=mem; super(stc,name);}
                                                                                                          ^~~~~~~~~~~~~~~
semantic.d:8976:20: error: cannot cast expression 'els' of type 'Statement' to 'bool'
		if(els)if(auto d = els.isDeclaration()) d.potentialRemove(sc, decl);
                   ^~~
semantic.d:8976:36: error: no member 'isDeclaration' for type 'Statement'
		if(els)if(auto d = els.isDeclaration()) d.potentialRemove(sc, decl);
                                   ^~~~~~~~~~~~~~~~~
semantic.d:8972:20: error: cannot cast expression 'els' of type 'Statement' to 'bool'
		if(els)if(auto d = els.isDeclaration()) d.potentialInsert(sc, decl);
                   ^~~
semantic.d:8972:36: error: no member 'isDeclaration' for type 'Statement'
		if(els)if(auto d = els.isDeclaration()) d.potentialInsert(sc, decl);
                                   ^~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:26:65: error: instantiation of template 'DeepDup' is ambiguous
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
visitors.d:37:1: note: candidate template
mixin template DeepDup(T) if(is(T: Node) && !is(T: BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:81:1: note: candidate template
mixin template DeepDup(T: StaticIfDecl) if(is(T==StaticIfDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
declaration.d:127:82: error: current object 'super' of type 'GenerativeDecl' is not callable
	this(STC stc,Statement b,Statement e)in{assert(b&&1);}body{bdy=b; els=e; super(stc,null);}
                                                                                 ^~~~~~~~~~~~~~~
declaration.d:149:69: error: current object 'super' of type 'ConditionalDecl' is not callable
	this(STC stc,Expression c,Statement b, Statement e){cond=c; super(stc,b,e);}
                                                                    ^~~~~~~~~~~~~~
declaration.d:138:95: error: current object 'super' of type 'ConditionalDecl' is not callable
	this(STC stc,Expression c,Statement b, Statement e)in{assert(c!is null);}body{cond=c; super(stc,b,e);}
                                                                                              ^~~~~~~~~~~~~~
declaration.d:139:18: error: undefined identifier 'string'
	override string toString(){return (stc?STCtoString(astStc)~" ":"")~"version("~cond.toString()~") "~bdy.toString()~
                 ^~~~~~
declaration.d:150:18: error: undefined identifier 'string'
	override string toString(){return (stc?STCtoString(astStc)~" ":"")~"debug"~(cond?"("~cond.toString()~") ":"")~bdy.toString()~
                 ^~~~~~
semantic.d:8801:33: error: no member 'loc' for type 'Declaration[]'
				x.loc = loc;
                                ^~~~~
semantic.d:8921:20: error: cannot cast expression 'name' of type 'Identifier' to 'bool'
		if(name){
                   ^~~~
<mixin@semantic.d:3048>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
semantic.d:9115:31: error: undefined identifier 'aliasee'
		if(auto sym = aliasee.isSymbol()){
                              ^~~~~~~
semantic.d:3033:28: error: no member 'isTemplateInstanceExp' for type 'Expression'
		if(auto ti=inst.isTemplateInstanceExp()) tie = ti;
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8803:46: error: no member 'init' for type 'long'
			auto r=New!BlockDecl(STC.init,decls);
                                             ^~~~~~~~
semantic.d:3035:60: error: no member 'init' for type 'Expression[]'
			tie = New!TemplateInstanceExp(inst,(Expression[]).init);
                                                           ^~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:8948>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:3048>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:8832>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
semantic.d:9126:24: error: undefined identifier 'aliasee'
		auto r=aliasee.clone(sc, inContext, loc);
                       ^~~~~~~
<mixin@semantic.d:3048>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8948>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8927:25: error: no member 'enc' for type 'EnumVarDecl[]'
			m.enc=this;
                        ^~~~~
semantic.d:3050:17: error: feature not implemented
		scope(exit) if(!needRetry) potentialRemove(sc, this);
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8928:25: error: no member 'presemantic' for type 'EnumVarDecl[]'
			m.presemantic(msc?msc:sc);
                        ^~~~~~~~~~~~~
semantic.d:8928:39: error: cannot cast expression 'msc' of type 'NestedScope' to 'bool'
			m.presemantic(msc?msc:sc);
                                      ^~~
<mixin@<mixin@semantic.d:8832>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:9086>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@semantic.d:8948>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:3052:36: error: cannot cast expression 'inst' of type 'Expression' to 'Symbol'
		assert(cast(Symbol)inst,text(inst," ",inst.sstate," ",typeid(this.inst)));
                                   ^~~~
<mixin@semantic.d:8832>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:8835:28: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
			if(rewrite) return;
                           ^~~~~~~
semantic.d:8837:17: error: feature not implemented
		scope(exit) if(!needRetry) potentialRemove(sc, this);
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8839:26: error: cannot cast expression 'cm' of type 'Module' to 'bool'
		assert(!!cm);
                         ^~
semantic.d:8841:17: error: undefined identifier 'string'
		string err;
                ^~~~~~
semantic.d:8949:29: error: cannot cast expression 'base' of type 'Type' to 'bool'
		if(rbase&&(!base||base.sstate!=SemState.completed)){
                            ^~~~
<mixin@<mixin@semantic.d:9086>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
declaration.d:265:18: error: undefined identifier 'string'
	override string toString(){return "mixin "~inst.toString()~(name?" "~name.toString():"")~";";}
                 ^~~~~~
declaration.d:264:83: error: current object 'super' of type 'Declaration' is not callable
	this(STC stc, Expression i, Identifier name)in{assert(i&&1);}body{inst=i; super(stc,name);}
                                                                                  ^~~~~~~~~~~~~~~
semantic.d:3052:41: error: undefined identifier 'text'
		assert(cast(Symbol)inst,text(inst," ",inst.sstate," ",typeid(this.inst)));
                                        ^~~~
semantic.d:3052:71: error: feature TypeidExp not implemented
		assert(cast(Symbol)inst,text(inst," ",inst.sstate," ",typeid(this.inst)));
                                                                      ^~~~~~~~~~~~~~~~~
semantic.d:3053:49: error: cannot cast expression 'inst' of type 'Expression' to 'void*'
		auto sym=cast(Symbol)cast(void*)inst;
                                                ^~~~
<mixin@semantic.d:9086>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:9087:21: error: undefined identifier 'aliasee'
		if(!aliasee){
                    ^~~~~~~
semantic.d:9088:30: error: no member 'isVarDecl' for type 'Declaration'
		if(auto vd = decl.isVarDecl()){
                             ^~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8933>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8933>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8935:44: error: no member 'prec' for type 'EnumVarDecl[]'
		foreach(i,x;members[1..$]) x.prec=members[i];
                                           ^~~~~~
semantic.d:8809:47: error: undefined identifier 'STCprivate'
		if(!(stc&STCvisibility)) stc|=STCprivate;
                                              ^~~~~~~~~~
<mixin@<mixin@semantic.d:8845>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8845>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8936:20: error: cannot cast expression 'name' of type 'Identifier' to 'bool'
		if(name||rbase){
                   ^~~~
semantic.d:8936:26: error: cannot cast expression 'rbase' of type 'Expression' to 'bool'
		if(name||rbase){
                         ^~~~~
semantic.d:8938:36: error: no member 'rtype' for type 'EnumVarDecl[]'
				if(x.rtype){
                                   ^~~~~~~
semantic.d:8939:111: error: cannot cast expression 'rbase' of type 'Expression' to 'bool'
					sc.error("explicit type only allowed in anonymous enum declarations"~(rbase?" without base type":""),x.rtype.loc);
                                                                                                              ^~~~~
semantic.d:8939:142: error: no member 'rtype' for type 'EnumVarDecl[]'
					sc.error("explicit type only allowed in anonymous enum declarations"~(rbase?" without base type":""),x.rtype.loc);
                                                                                                                                             ^~~~~~~
semantic.d:8940:41: error: no member 'sstate' for type 'EnumVarDecl[]'
					x.sstate=SemState.error;
                                        ^~~~~~~~
semantic.d:8847:26: error: undefined identifier 'STCstatic'
		if(!(stc&STCstatic)&&!sc.addImport(m.sc,importKindFromSTC(stc))) mixin(ErrEplg);;
                         ^~~~~~~~~
semantic.d:8814:17: error: undefined identifier 'string'
		string computePath(Expression e){
                ^~~~~~
<mixin@<mixin@semantic.d:9091>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:9091>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:9093:25: error: undefined identifier 'aliasee'
			aliasee = vd.rtype;
                        ^~~~~~~
semantic.d:9094:36: error: no member 'isFunctionDecl' for type 'Declaration'
		}else if(auto fd = decl.isFunctionDecl()){
                                   ^~~~~~~~~~~~~~~~~~~
semantic.d:9095:25: error: undefined identifier 'aliasee'
			aliasee = fd.type;
                        ^~~~~~~
semantic.d:9098:17: error: undefined identifier 'aliasee'
		aliasee.weakenAccessCheck(AccessCheck.none);
                ^~~~~~~
semantic.d:9099:17: error: undefined identifier 'aliasee'
		aliasee.willAlias();
                ^~~~~~~
<mixin@<mixin@semantic.d:8847>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8847>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:3058>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:3058>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8848>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8848>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:9102:21: error: undefined identifier 'aliasee'
		if(!aliasee.isSymbol() && !aliasee.isType() && !aliasee.isConstant() && !aliasee.isExpTuple()){
                    ^~~~~~~
semantic.d:9102:44: error: undefined identifier 'aliasee'
		if(!aliasee.isSymbol() && !aliasee.isType() && !aliasee.isConstant() && !aliasee.isExpTuple()){
                                           ^~~~~~~
semantic.d:9102:65: error: undefined identifier 'aliasee'
		if(!aliasee.isSymbol() && !aliasee.isType() && !aliasee.isConstant() && !aliasee.isExpTuple()){
                                                                ^~~~~~~
semantic.d:9102:90: error: undefined identifier 'aliasee'
		if(!aliasee.isSymbol() && !aliasee.isType() && !aliasee.isConstant() && !aliasee.isExpTuple()){
                                                                                         ^~~~~~~
semantic.d:9103:35: error: undefined identifier 'aliasee'
			auto ae = aliasee.isAddressExp();
                                  ^~~~~~~
<mixin@<mixin@semantic.d:9106>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:9106>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:3062>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:3062>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:9109>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:9109>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
declaration.d:183:28: error: undefined identifier 'string'
	override @property string kind(){return "alias declaration";}
                           ^~~~~~
declaration.d:182:18: error: undefined identifier 'string'
	override string toString(){return (stc?STCtoString(astStc)~" ":"")~"alias "~decl.toString();}
                 ^~~~~~
declaration.d:181:66: error: current object 'super' of type 'Declaration' is not callable
	this(STC stc, Declaration declaration){decl=declaration; super(stc, declaration.name);}
                                                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:11173:25: error: feature not implemented
			scope(success) if(rewrite||sstate==SemState.error) potentialRemove(sc, this);
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:2832:21: error: cannot cast expression 'eponymousDecl' of type 'Declaration' to 'bool'
		if(!eponymousDecl) return null;
                    ^~~~~~~~~~~~~
semantic.d:2833:24: error: no member 'isFunctionDecl' for type 'Declaration'
		return eponymousDecl.isFunctionDecl();
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:2984:29: error: undefined identifier 'store'
		foreach(k,v;store.instances) dg(v);
                            ^~~~~
semantic.d:2956:40: error: undefined identifier 'store'
			if(auto exst = store.lookup(inst.resolved)) inst = exst;
                                       ^~~~~
semantic.d:2957:30: error: undefined identifier 'store'
			else store.add(inst);
                             ^~~~~
semantic.d:2825:9: error: undefined identifier 'size_t'
	size_t tuplepos = -1;
        ^~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
declaration.d:247:18: error: undefined identifier 'string'
	override string kind(){
                 ^~~~~~
declaration.d:243:18: error: undefined identifier 'string'
	override string toString(){
                 ^~~~~~
semantic.d:1846:24: error: cannot cast expression 'parent.iftiDecl()' of type 'FunctionDecl' to 'bool'
		return parent.iftiDecl()?bdy.decls[0].isFunctionDecl():null;
                       ^~~~~~~~~~~~~~~~~
semantic.d:1846:42: error: no member 'isFunctionDecl' for type 'Declaration'
		return parent.iftiDecl()?bdy.decls[0].isFunctionDecl():null;
                                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:1947:21: error: cannot cast expression 'fd' of type 'FunctionDecl' to 'bool'
		if(!fd){ // TODO: this is probably not required (and the test suite does not cover it)
                    ^~
semantic.d:1958:28: error: no member 'dup' for type 'Expression[]'
		iftiArgs = iftiArgs.dup;
                           ^~~~~~~~~~~~
semantic.d:1970:26: error: cannot cast expression 'fdecl' of type 'FunctionDecl' to 'bool'
		assert(!!fdecl);
                         ^~~~~
semantic.d:1975:17: error: no member 'assumeSafeAppend' for type 'Parameter[]'
		iftiEponymousParameters.assumeSafeAppend(); // ok
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:3132:25: error: need 'this' to access member function 'TemplateDecl.finishArgumentPreparation'
			TemplateDecl.finishArgumentPreparation(sc, x);
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:2865:9: note: member function was declared here
	static void finishArgumentPreparation(Scope sc, ref Expression x){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:1911:29: error: undefined identifier 'min'
		resolved[0..min(tuplepos, args.length)] = args[0..min(tuplepos,args.length)]; // TODO: dollar
                            ^~~
semantic.d:2307:28: error: cannot cast expression 'parent.eponymousDecl' of type 'Declaration' to 'bool'
			if(parent.eponymousDecl) if(auto fd = parent.eponymousDecl.isFunctionDecl()){
                           ^~~~~~~~~~~~~~~~~~~~
semantic.d:2307:63: error: no member 'isFunctionDecl' for type 'Declaration'
			if(parent.eponymousDecl) if(auto fd = parent.eponymousDecl.isFunctionDecl()){
                                                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
declaration.d:241:61: error: current object 'super' of type 'OverloadableDecl' is not callable
		isMixin=m; params=prm; constraint=c; bdy=b; super(stc,name);
                                                            ^~~~~~~~~~~~~~~
semantic.d:1854:33: error: undefined identifier 'STCstatic'
		if(!(parent.stc&STCstatic)) return; // TODO: fix!
                                ^~~~~~~~~
semantic.d:2146:39: error: undefined identifier 'STCstatic'
		if(isMixin) bdy.stc&=~STCstatic;
                                      ^~~~~~~~~
semantic.d:2971:21: error: cannot cast expression 'iftiDecl' of type 'FunctionDecl' to 'bool'
		if(!iftiDecl) return matchInstantiation(sc, loc, !sc||!sc.handler.showsEffect, false, func, args);
                    ^~~~~~~~
semantic.d:2971:67: error: cannot cast expression 'sc' of type 'Scope' to 'bool'
		if(!iftiDecl) return matchInstantiation(sc, loc, !sc||!sc.handler.showsEffect, false, func, args);
                                                                  ^~
semantic.d:2972:30: error: cannot cast expression 'sc' of type 'Scope' to 'bool'
		auto gagged=!sc||!sc.handler.showsEffect; // TODO: get rid of !sc
                             ^~
semantic.d:2868:20: error: no member 'isType' for type 'Expression'
		if(x.isType()) return;
                   ^~~~~~~~
semantic.d:10339:44: error: cannot implicitly convert function call result 'set.tdecls[i].matchInstantiation(sc/+isMixin?sc:null+/, loc, true, isMixin, func, args)' of type 'Declaration' to 'Declaration[]'
		foreach(i, ref x; insts) x=set.tdecls[i].matchInstantiation(sc/+isMixin?sc:null+/, loc, true, isMixin, func, args);
                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:2148:35: error: undefined identifier 'STCstatic'
			bdy.stc&=~STCstatic;
                                  ^~~~~~~~~
semantic.d:10398:44: error: cannot implicitly convert function call result 'set.tdecls[i].matchIFTI(null, loc, this_, func, templArgs, args)' of type 'Declaration' to 'Declaration[]'
		foreach(i, ref x; iftis) x=set.tdecls[i].matchIFTI(null, loc, this_, func, templArgs, args);
                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:10400:17: error: undefined identifier 'size_t'
		size_t numfunclit;
                ^~~~~~
semantic.d:1960:30: error: no member 'isAddressExp' for type 'Expression[]'
		if(auto ae = a.isAddressExp())
                             ^~~~~~~~~~~~~~
semantic.d:2964:52: error: cannot cast expression 'sc' of type 'Scope' to 'bool'
		auto r=matchHelper!false(sc, loc, !sc||!sc.handler.showsEffect||gagged, isMixin, expr, args);
                                                   ^~
semantic.d:1795:17: error: current object 'super' of type 'Declaration' is not callable
		super(parent.stc, parent.name);
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:10402:38: error: no member 'isAddressExp' for type 'Expression[]'
			if(auto ae = a.isAddressExp())
                                     ^~~~~~~~~~~~~~
semantic.d:1799:35: error: cannot cast expression 'parent.constraint' of type 'Expression' to 'bool'
		this.constraint = parent.constraint?parent.constraint.ddup():null;
                                  ^~~~~~~~~~~~~~~~~
semantic.d:10406:33: error: undefined identifier 'size_t'
		positions = new size_t[numfunclit];
                                ^~~~~~
semantic.d:10408:17: error: undefined identifier 'size_t'
		size_t i=0;
                ^~~~~~
semantic.d:10410:38: error: no member 'isAddressExp' for type 'Expression[]'
			if(auto ae = a.isAddressExp()){
                                     ^~~~~~~~~~~~~~
semantic.d:10414:41: error: unimplemented feature ForeachRangeStm
					foreach(j;0..set.decls.length)
                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:1962:27: error: no member 'ddup' for type 'Expression[]'
			a=a.ddup();
                          ^~~~~~
semantic.d:1911:67: error: undefined identifier 'min'
		resolved[0..min(tuplepos, args.length)] = args[0..min(tuplepos,args.length)]; // TODO: dollar
                                                                  ^~~
semantic.d:2112:28: error: no member 'which' for type 'TemplateParameter[]'
			if(p.which!=WhichTemplateParameter.constant) continue;
                           ^~~~~~~
semantic.d:2311:43: error: no member 'ddup' for type 'Parameter[]'
					x=x.ddup;
                                          ^~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
semantic.d:2149:33: error: initializer required for '' declaration
			foreach(decl;&bdy.traverseInOrder)
                                ^~~~
semantic.d:2113:52: error: no member 'type' for type 'TemplateParameter[]'
			if(resolved[i].type.equals(p.type)) continue;
                                                   ^~~~~~
semantic.d:2115:33: error: undefined identifier 'min'
			match = min(match, resolved[i].type.constConvertsTo(p.type).force ?
                                ^~~
semantic.d:1804:21: error: cannot cast expression 'this.instantiation' of type 'Expression' to 'bool'
		if(!this.instantiation)
                    ^~~~~~~~~~~~~~~~~~
semantic.d:2115:77: error: no member 'type' for type 'TemplateParameter[]'
			match = min(match, resolved[i].type.constConvertsTo(p.type).force ?
                                                                            ^~~~~~
semantic.d:1914:21: error: cannot cast expression 'paramScope' of type 'TemplateScope' to 'bool'
		if(!paramScope){
                    ^~~~~~~~~~
semantic.d:2869:28: error: no member 'isAddressExp' for type 'Expression'
		if(auto ae=x.isAddressExp()) if(auto lit=ae.e.isSymbol()){
                           ^~~~~~~~~~~~~~
semantic.d:2121:57: error: no member 'init' for type 'Expression[]'
			resolved[tuplepos]=New!ExpTuple((Expression[]).init);
                                                        ^~~~~~~~~~~~~~~~~~~
semantic.d:2123:23: error: undefined identifier 'util'
		alias util.any any;
                      ^~~~
semantic.d:3137:21: error: function call result 'this.analyzedArgsInitialized()' of type 'bool' is not callable
		if(!analyzedArgsInitialized){
                    ^~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8480:25: error: undefined identifier 'ndecls'
			ndecls~=decl;
                        ^~~~~~
semantic.d:8483:25: error: undefined identifier 'ndecls'
			ndecls~=def;
                        ^~~~~~
semantic.d:9741:15: note: instantiated here
	mixin HandleNestedDeclarations;
              ^~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:2150:33: error: undefined identifier 'decl'
				decl.stc&=~STCstatic;
                                ^~~~
semantic.d:2150:44: error: undefined identifier 'STCstatic'
				decl.stc&=~STCstatic;
                                           ^~~~~~~~~
<mixin@semantic.d:11100>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
semantic.d:2155:20: error: cannot cast expression 'decl' of type 'Declaration' to 'bool'
		if(decl) decl.nestedTemplateInstantiation(this); // TODO: correct?
                   ^~~~
semantic.d:9736:20: error: undefined identifier 'type'
		if(type) return type;
                   ^~~~
semantic.d:9736:33: error: undefined identifier 'type'
		if(type) return type;
                                ^~~~
semantic.d:9737:24: error: undefined identifier 'type'
		return type=New!AggregateTy(this);
                       ^~~~
semantic.d:2158:22: error: type 'Scheduler' is not callable
		else Scheduler().remove(this);
                     ^~~~~~~~~~~
semantic.d:3140:53: error: no member 'map' for type 'Expression[]'
			argTypes = TypeTuple.expand(args.map!((a){
                                                    ^~~~~~~~
<mixin@semantic.d:2893>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
semantic.d:2886:20: error: no member 'isSymbol' for type 'Expression'
		if(x.isSymbol()||x.isType()) return;
                   ^~~~~~~~~~
semantic.d:2886:34: error: no member 'isType' for type 'Expression'
		if(x.isSymbol()||x.isType()) return;
                                 ^~~~~~~~
<mixin@<mixin@semantic.d:11100>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:9707:20: error: cannot cast expression 'auto decl=sc.getDeclaration()' of type 'Declaration' to 'bool'
		if(auto decl=sc.getDeclaration())
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:9708:38: error: no member 'isAggregateDecl' for type 'Declaration'
			if(auto aggr=decl.isAggregateDecl())
                                     ^~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:2893>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:11100>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:2893>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:2894:36: error: no member 'sstate' for type 'TemplateParameter[]'
		foreach(x; params) x.sstate = max(x.sstate,SemState.begin);
                                   ^~~~~~~~
<mixin@semantic.d:9725>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
semantic.d:9709:65: error: undefined identifier 'isValueAggregateDecl'
				if(aggr.isValueAggregateDecl()||isValueAggregateDecl())
                                                                ^~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:9725>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:2894:47: error: undefined identifier 'max'
		foreach(x; params) x.sstate = max(x.sstate,SemState.begin);
                                              ^~~
semantic.d:2894:51: error: no member 'sstate' for type 'TemplateParameter[]'
		foreach(x; params) x.sstate = max(x.sstate,SemState.begin);
                                                  ^~~~~~~~
<mixin@semantic.d:9725>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:9710:46: error: undefined identifier 'STCstatic'
					stc|=STCstatic;
                                             ^~~~~~~~~
semantic.d:2899:28: error: no member 'which' for type 'TemplateParameter[]'
			if(x.which == WhichTemplateParameter.tuple) tuplepos = i;
                           ^~~~~~~
semantic.d:9726:20: error: cannot cast expression 'bdy' of type 'BlockDecl' to 'bool'
		if(bdy) mixin(SemChld!q{sc=asc;bdy});
                   ^~~
semantic.d:9716:21: error: cannot cast expression 'asc' of type 'AggregateScope' to 'bool'
		if(!asc) asc = isReferenceAggregateDecl()?
                    ^~~
semantic.d:2905:28: error: no member 'name' for type 'Declaration[]'
			if(x.name && x.name.name is name.name) eponymousDecl = x;
                           ^~~~~~
semantic.d:2905:38: error: no member 'name' for type 'Declaration[]'
			if(x.name && x.name.name is name.name) eponymousDecl = x;
                                     ^~~~~~
semantic.d:9728:20: error: cannot cast expression 'auto exp=unresolvedParent()' of type 'Expression' to 'bool'
		if(auto exp=unresolvedParent()){mixin(PropRetry!q{exp});}
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:11106>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:11106>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:11109>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:11109>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:9716:32: error: undefined identifier 'isReferenceAggregateDecl'
		if(!asc) asc = isReferenceAggregateDecl()?
                               ^~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:9720:20: error: cannot cast expression 'bdy' of type 'BlockDecl' to 'bool'
		if(bdy) bdy.presemantic(asc);
                   ^~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
scope_.d:479:17: error: current object 'super' of type 'NestedScope' is not callable
		super(decl.scope_);
                ^~~~~~~~~~~~~~~~~~
scope_.d:480:17: error: undefined identifier 'aggr'
		aggr = decl;
                ^~~~
interpret.d:4016:25: error: initializer required for '' declaration
		foreach(d;&bdy.traverseInOrder){
                        ^
interpret.d:4048:15: error: undefined identifier 'size_t'
	final size_t getBCSize(){
              ^~~~~~
interpret.d:3986:19: error: undefined identifier 'size_t'
	protected size_t initialOffset(){
                  ^~~~~~
interpret.d:4031:17: error: undefined identifier 'size_t'
		size_t off=initialOffset();
                ^~~~~~
interpret.d:4109:51: error: undefined identifier 'size_t'
	private FunctionDecl findFunDeclFromIndex(size_t index){
                                                  ^~~~~~
declaration.d:282:53: error: current object 'super' of type 'AggregateDecl' is not callable
	this(STC stc, Identifier name, BlockDecl b){super(stc,name,b);}
                                                    ^~~~~~~~~~~~~~~~~
declaration.d:273:60: error: current object 'super' of type 'Declaration' is not callable
	this(STC stc, Identifier name, BlockDecl b){bdy=b; super(stc,name);}
                                                           ^~~~~~~~~~~~~~~
interpret.d:4034:25: error: initializer required for '' declaration
		foreach(vd;&traverseDeclaredFields){
                        ^~
declaration.d:275:28: error: undefined identifier 'string'
	override @property string kind(){return "aggregate";}
                           ^~~~~~
interpret.d:4090:25: error: initializer required for '' declaration
		foreach(vd;&traverseDeclaredFields){
                        ^~
interpret.d:4091:25: error: undefined identifier 'size_t'
			size_t len, off = vd.getBCLoc(len);
                        ^~~~~~
interpret.d:4091:25: error: undefined identifier 'size_t'
			size_t len, off = vd.getBCLoc(len);
                        ^~~~~~
interpret.d:4062:25: error: unimplemented feature ForeachRangeStm
			foreach(i;0..bcPointerBCSize){
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4067:26: error: undefined identifier 'STCstatic'
		if(!(stc&STCstatic)){
                         ^~~~~~~~~
interpret.d:3991:22: error: type 'NotifyOnLayoutChanged' is not an expression
	private bool[NotifyOnLayoutChanged] subscribers;
                     ^~~~~~~~~~~~~~~~~~~~~
interpret.d:4056:20: error: undefined identifier 'vers'
		if(vers == ulong.max) assert(0);
                   ^~~~
interpret.d:4053:24: error: undefined identifier 'vers'
		return vers;
                       ^~~~
interpret.d:4056:28: error: no member 'max' for type 'ulong'
		if(vers == ulong.max) assert(0);
                           ^~~~~~~~~
interpret.d:4057:17: error: undefined identifier 'vers'
		vers++;
                ^~~~
interpret.d:4091:43: error: undefined identifier 'vd'
			size_t len, off = vd.getBCLoc(len);
                                          ^~
interpret.d:4035:40: error: undefined identifier 'vd'
			if(auto aggrty=vd.type.isAggregateTy()){
                                       ^~
interpret.d:4093:36: error: undefined identifier 'vd'
				if(vd.init) vd.init.byteCompile(bld);
                                   ^~
interpret.d:4093:45: error: undefined identifier 'vd'
				if(vd.init) vd.init.byteCompile(bld);
                                            ^~
interpret.d:4094:38: error: unimplemented feature ForeachRangeStm
				else foreach(i;0..len){bld.emit(Instruction.push); bld.emitConstant(0);}
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4040:34: error: undefined identifier 'vd'
			assert(!!vd.type, vd.to!string);
                                 ^~
interpret.d:4040:43: error: undefined identifier 'vd'
			assert(!!vd.type, vd.to!string);
                                          ^~
interpret.d:4075:31: error: undefined identifier 'isReferenceAggregateDecl'
		if(auto raggr=isReferenceAggregateDecl()){
                              ^~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4076:32: error: undefined identifier 'STCstatic'
			if(stc&STCstatic) emitNullPtr();
                               ^~~~~~~~~
interpret.d:4012:24: error: undefined identifier 'layoutKnown'
		return layoutKnown;
                       ^~~~~~~~~~~
semantic.d:11118:31: error: undefined identifier 'ImplConvertsTo'
			mixin(ImplConvertsTo!q{bool icd; a[0], t});
                              ^~~~~~~~~~~~~~
interpret.d:3997:17: error: undefined identifier 'layoutKnown'
		layoutKnown = false;
                ^~~~~~~~~~~
interpret.d:4017:36: error: undefined identifier 'd'
			if(auto vd=d.isVarDecl()){
                                   ^
interpret.d:4019:44: error: undefined identifier 'STCstatic'
				if(vd.stc&(STCstatic|STCenum)) continue;
                                           ^~~~~~~~~
interpret.d:4041:48: error: undefined identifier 'vd'
			auto len = getBCSizeof(vd.type);
                                               ^~
interpret.d:4096:43: error: undefined identifier 'format'
				bld.error(format("cannot interpret field '%s' of type '%s' during compile time",vd.toString(),vd.type.toString()),loc);
                                          ^~~~~~
interpret.d:4096:113: error: undefined identifier 'vd'
				bld.error(format("cannot interpret field '%s' of type '%s' during compile time",vd.toString(),vd.type.toString()),loc);
                                                                                                                ^~
interpret.d:4096:127: error: undefined identifier 'vd'
				bld.error(format("cannot interpret field '%s' of type '%s' during compile time",vd.toString(),vd.type.toString()),loc);
                                                                                                                              ^~
interpret.d:4042:25: error: undefined identifier 'vd'
			vd.setBCLoc(off, len);
                        ^~
<mixin@<mixin@semantic.d:9732>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:9732>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4019:54: error: undefined identifier 'STCenum'
				if(vd.stc&(STCstatic|STCenum)) continue;
                                                     ^~~~~~~
semantic.d:11119:28: error: undefined identifier 'icd'
			if(icd) which=cast(int)i+1;
                           ^~~
<mixin@<mixin@semantic.d:11123>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:11123>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4045:17: error: undefined identifier 'bcSize'
		bcSize = off;
                ^~~~~~
interpret.d:4046:17: error: undefined identifier 'layoutKnown'
		layoutKnown = true;
                ^~~~~~~~~~~
semantic.d:11127:45: error: no member 'getImmutable' for type 'Type[3]'
			a[0]=a[0].convertTo(t.getImmutable());
                                            ^~~~~~~~~~~~~~
semantic.d:11133:50: error: undefined identifier 'string'
		auto str = a[0].interpretV().get!string();
                                                 ^~~~~~
semantic.d:11136:41: error: undefined identifier 'format'
		Source src = New!Source(format("<mixin@%s:%d>",loc.source.name,loc.line), str); // TODO: column?
                                        ^~~~~~
semantic.d:11150:71: error: no member 'init' for type 'long'
		else static if(is(T==MixinDecl)) auto r=New!BlockDecl(STC.init,parseDeclDefs(src,sc.handler));
                                                                      ^~~~~~~~
<mixin@<mixin@semantic.d:11153>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:11153>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
declaration.d:174:28: error: undefined identifier 'string'
	override @property string kind(){return "string mixin declaration";}
                           ^~~~~~
declaration.d:172:18: error: undefined identifier 'string'
	override string toString(){return (stc?STCtoString(astStc)~" ":"")~"mixin("~join(map!(to!string)(a),",")~");";}
                 ^~~~~~
declaration.d:171:48: error: current object 'super' of type 'GenerativeDecl' is not callable
	this(STC stc, Expression[] arg){a=arg; super(stc,null);}
                                               ^~~~~~~~~~~~~~~
interpret.d:5244:49: error: undefined identifier 'size_t'
	final size_t getBCLocOf(VarDecl vd, out size_t len){
                                                ^~~~~~
interpret.d:4116:34: error: undefined identifier 'size_t'
	final Symbol bcFetchVTBL(size_t index){
                                 ^~~~~~
interpret.d:4188:28: error: undefined identifier 'size_t'
	override protected size_t initialOffset(){
                           ^~~~~~
interpret.d:5244:15: error: undefined identifier 'size_t'
	final size_t getBCLocOf(VarDecl vd, out size_t len){
              ^~~~~~
type.d:343:15: note: instantiated here
	mixin CTFEInterpret!AggregateTy; // ditto
              ^~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4132:24: error: type 'FunctionDecl' is not an expression
	private Symbol[FunctionDecl] dynSymbols;
                       ^~~~~~~~~~~~
interpret.d:4133:28: error: type 'FunctionDecl' is not an expression
	private Identifier[FunctionDecl] lkupIdents;
                           ^~~~~~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
declaration.d:294:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
interpret.d:4274:41: error: cannot cast expression 'type.getHeadUnqual()' of type 'Type' to 'AggregateTy'
		assert(cast(AggregateTy)type.getHeadUnqual()&&scope_.getAggregate());
                                        ^~~~~~~~~~~~~~~~~~~~
interpret.d:4275:49: error: cannot cast expression 'type.getHeadUnqual()' of type 'Type' to 'void*'
		if((cast(AggregateTy)cast(void*)type.getHeadUnqual()).decl.isReferenceAggregateDecl()){
                                                ^~~~~~~~~~~~~~~~~~~~
interpret.d:247:44: error: no member 'isFunctionDef' for type 'Declaration'
				if(auto fd=self.meaning.isFunctionDef)
                                           ^~~~~~~~~~~~~~~~~~~~~~~~~~
declaration.d:307:18: error: undefined identifier 'string'
	override string toString(){return (stc?STCtoString(astStc)~" ":"")~"union"~(name?" "~name.toString():"")~(bdy?bdy.toString():";");}
                 ^~~~~~
declaration.d:299:18: error: undefined identifier 'string'
	override string toString(){return (stc?STCtoString(astStc)~" ":"")~"struct"~(name?" "~name.toString():"")~(bdy?bdy.toString():";");}
                 ^~~~~~
declaration.d:309:28: error: undefined identifier 'string'
	override @property string kind(){ return "union"; }
                           ^~~~~~
declaration.d:301:28: error: undefined identifier 'string'
	override @property string kind(){ return "struct"; }
                           ^~~~~~
declaration.d:306:52: error: current object 'super' of type 'ValueAggregateDecl' is not callable
	this(STC stc,Identifier name, BlockDecl b){super(stc,name,b);}
                                                   ^~~~~~~~~~~~~~~~~
declaration.d:298:52: error: current object 'super' of type 'ValueAggregateDecl' is not callable
	this(STC stc,Identifier name, BlockDecl b){super(stc,name,b);}
                                                   ^~~~~~~~~~~~~~~~~
interpret.d:4283:50: error: type 'LVpopc' is not callable
		auto lv=diff?LVpopcc(type, this):LVpopc(type, this);
                                                 ^~~~~~~~~~~~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
semantic.d:5750:41: error: cannot cast expression 'type.getHeadUnqual()' of type 'Type' to 'AggregateTy'
		assert(cast(AggregateTy)type.getHeadUnqual());
                                        ^~~~~~~~~~~~~~~~~~~~
semantic.d:5751:44: error: cannot cast expression 'type.getHeadUnqual()' of type 'Type' to 'AggregateTy'
		return !!(cast(AggregateTy)type.getHeadUnqual()).decl.isValueAggregateDecl();
                                           ^~~~~~~~~~~~~~~~~~~~
semantic.d:5047:28: error: cannot cast expression 'auto el=exp.type.getElementType()' of type 'Type' to 'bool'
			if(auto el=exp.type.getElementType())
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5049:37: error: no member 'isLiteralExp' for type 'Expression'
			if(auto lit=exp.isLiteralExp()){
                                    ^~~~~~~~~~~~~~~~
semantic.d:5060:26: error: undefined identifier 'format'
		sc.error(format("cannot cast function literal to '%s'",type.toString()),loc);
                         ^~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5290:18: error: undefined identifier 'string'
	override string toString(){return e.toString();}
                 ^~~~~~
expression.d:290:18: error: undefined identifier 'string'
	override string toString(){return _brk("cast("~(stc?STCtoString(stc)~(ty?" ":""):"")~(ty?ty.toString():"")~")"~e.toString());}
                 ^~~~~~
semantic.d:5251:51: error: no member 'init' for type 'long'
	this(Expression tt, Expression exp){super(STC.init, tt, exp);}
                                                  ^~~~~~~~
semantic.d:5151:20: error: no member 'isPointerTy' for type 'Type'
		if(type.getHeadUnqual().isPointerTy()
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5152:23: error: no member 'isPointerTy' for type 'Type'
		   || e.type.getHeadUnqual().isPointerTy()) return false; // TODO!
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5156:20: error: no member 'isPointerTy' for type 'Type'
		if(type.getHeadUnqual().isPointerTy()) return false;
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5163:20: error: no member 'isPointerTy' for type 'Type'
		if(type.getHeadUnqual().isPointerTy()
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5164:23: error: no member 'isPointerTy' for type 'Type'
		   || e.type.getHeadUnqual().isPointerTy()) return false; // TODO!
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:150:25: error: no member 'isLiteralExp' for type 'Expression'
		auto le=e.isLiteralExp(); // polysemous string literals might be cast
                        ^~~~~~~~~~~~~~
interpret.d:155:28: error: cannot cast expression 'typeu.isSomeString()' of type 'Type' to 'bool'
			if(typeu.isSomeString()) return vle.convertTo(type);
                           ^~~~~~~~~~~~~~~~~~~~
interpret.d:158:48: error: 'Variant' is not indexable
			foreach(i,ref x;r) x = vle[i].convertTo(el);
                                               ^~~~~~
<mixin@semantic.d:5068>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
<mixin@<mixin@semantic.d:5068>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:5068>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:5072:21: error: cannot cast expression 'ty' of type 'Expression' to 'bool'
		if(!ty) {
                    ^~
semantic.d:5087:32: error: no member 'isAddressExp' for type 'Expression'
		if(auto uexp = e.isAddressExp()            ){ // TODO: reduce the DMD bug
                               ^~~~~~~~~~~~~~
semantic.d:5091:36: error: cannot cast expression 'auto fty=type.getHeadUnqual().getFunctionTy()' of type 'FunctionTy' to 'bool'
				if(auto fty=type.getHeadUnqual().getFunctionTy()){
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:5101>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:5101>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5104:38: error: no member 'isDelegateTy' for type 'Type'
			if(auto dg = type.getHeadUnqual().isDelegateTy()){
                                     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5105:43: error: undefined identifier 'STCstatic'
				if(fd.stc&STCstatic && fd.deduceStatic){
                                          ^~~~~~~~~
semantic.d:5107:47: error: undefined identifier 'ImplConvertsTo'
					mixin(ImplConvertsTo!q{
                                              ^~~~~~~~~~~~~~
semantic.d:5112:44: error: undefined identifier 'delegaterequested'
					if(delegaterequested){
                                           ^~~~~~~~~~~~~~~~~
semantic.d:5122:23: error: undefined identifier 'CheckConv'
		mixin(CheckConv!q{bool conversionLegal; this, sc});
                      ^~~~~~~~~
semantic.d:5123:21: error: undefined identifier 'conversionLegal'
		if(!conversionLegal) mixin(ErrEplg);
                    ^~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:5123>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:5123>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5127:38: error: no member 'isArrayLiteralExp' for type 'Expression'
			if(auto al = e.isArrayLiteralExp()){
                                     ^~~~~~~~~~~~~~~~~~~
semantic.d:5137:30: error: no member 'isTernaryExp' for type 'Expression'
		if(auto te = e.isTernaryExp()){
                             ^~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:5144>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:5144>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8766:35: error: no member 'isIndexExp' for type 'Expression'
		for(;;)if(auto id=postfix.isIndexExp()){
                                  ^~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
declaration.d:389:18: error: undefined identifier 'string'
	override string toString(){return (stc?STCtoString(astStc)~" ":"")~rtype.toString()~" "~postfix.toString()~(init?"="~init.toString():"")~";";}
                 ^~~~~~
declaration.d:387:31: error: current object 'super' of type 'VarDecl' is not callable
		postfix=pfix; super(stc, rtype, name, initializer);
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5300:17: error: current object 'super' of type 'VarDecl' is not callable
		super(stc, rtype, name, initializer);
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8752:25: error: cannot cast expression 'type' of type 'Type' to 'bool'
		return !type && !rtype && !init;
                        ^~~~
semantic.d:8861:24: error: cannot cast expression 'enc.name' of type 'Identifier' to 'bool'
		assert(enc.name&&sc is enc.msc||sc is enc.scope_);
                       ^~~~~~~~
semantic.d:8766:35: error: no member 'isIndexExp' for type 'Expression'
		for(;;)if(auto id=postfix.isIndexExp()){
                                  ^~~~~~~~~~~~~~~~~~
semantic.d:8752:34: error: cannot cast expression 'rtype' of type 'Expression' to 'bool'
		return !type && !rtype && !init;
                                 ^~~~~
semantic.d:8752:44: error: cannot cast expression 'init' of type 'Expression' to 'bool'
		return !type && !rtype && !init;
                                           ^~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
declaration.d:422:18: error: undefined identifier 'string'
	override string toString(){return (stc?STCtoString(astStc)~" ":"")~rtype.toString()~" "~postfix.toString()~(init?"="~init.toString():"");}
                 ^~~~~~
declaration.d:420:31: error: current object 'super' of type 'Parameter' is not callable
		postfix=pfix; super(stc, rtype, name, initializer);
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:8862>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:8862>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:8862>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:8863:21: error: cannot cast expression 'init' of type 'Expression' to 'bool'
		if(!init){
                    ^~~~
semantic.d:8864:29: error: cannot cast expression 'prec' of type 'EnumVarDecl' to 'bool'
			if(!prec){
                            ^~~~
semantic.d:8865:40: error: need 'this' to access member function 'LiteralExp.factory'
				init = LiteralExp.factory(Variant(0, Type.get!int()));
                                       ^~~~~~~~~~~~~~~~~~
semantic.d:879:9: note: member function was declared here
	static Expression factory(Variant value)in{
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8869:40: error: cannot cast expression 'prec.rinit' of type 'Expression' to 'bool'
				assert(prec.rinit);
                                       ^~~~~~~~~~
semantic.d:8870:37: error: cannot cast expression 'rtype' of type 'Expression' to 'bool'
				if(!rtype) type=prec.type;
                                    ^~~~~
semantic.d:8872:42: error: need 'this' to access member function 'LiteralExp.factory'
				auto one=LiteralExp.factory(Variant(1,Type.get!int()));
                                         ^~~~~~~~~~~~~~~~~~
semantic.d:879:9: note: member function was declared here
	static Expression factory(Variant value)in{
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8877:26: error: cannot cast expression 'enc.name' of type 'Identifier' to 'bool'
		}else if(enc.name&&prec||enc.rbase){
                         ^~~~~~~~
semantic.d:8877:36: error: cannot cast expression 'prec' of type 'EnumVarDecl' to 'bool'
		}else if(enc.name&&prec||enc.rbase){
                                   ^~~~
semantic.d:8878:31: error: undefined identifier 'GetEnumBase'
			mixin(GetEnumBase!q{auto base;enc});
                              ^~~~~~~~~~~
semantic.d:8879:30: error: undefined identifier 'base'
			type=base;
                             ^~~~
semantic.d:8882:21: error: cannot cast expression 'rinit' of type 'Expression' to 'bool'
		if(!rinit) super.semantic(sc);
                    ^~~~~
semantic.d:8884:21: error: cannot cast expression 'prec' of type 'EnumVarDecl' to 'bool'
		if(!prec) enc.base=type;
                    ^~~~
semantic.d:8885:21: error: cannot cast expression 'rinit' of type 'Expression' to 'bool'
		if(!rinit) rinit=init;
                    ^~~~~
semantic.d:8886:20: error: cannot cast expression 'enc.name' of type 'Identifier' to 'bool'
		if(enc.name){
                   ^~~~~~~~
semantic.d:8888:34: error: cannot cast expression 'ty' of type 'Type' to 'bool'
			assert(!!ty);
                                 ^~
<mixin@<mixin@semantic.d:8891>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8891>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8952:29: error: cannot cast expression 'members[0].rtype' of type 'Expression' to 'bool'
			if(!members[0].rtype) members[0].rtype=base;
                            ^~~~~~~~~~~~~~~~
declaration.d:100:23: error: undefined identifier 'STCenum'
		super(STCenum, rtype, name, initializer);
                      ^~~~~~~
semantic.d:8956:29: error: cannot cast expression 'base' of type 'Type' to 'bool'
		if(name && !base) base=members[0].rinit.type;
                            ^~~~
<mixin@<mixin@semantic.d:8960>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8960>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5335:21: error: cannot cast expression 'tmpVarDecl' of type 'VarDecl' to 'bool'
		if(!tmpVarDecl){
                    ^~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
semantic.d:5343:25: error: feature not implemented
			scope(success) sstate = tmpVarDecl.sstate;
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(ModuleIdentifier)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
expression.d:258:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
interpret.d:601:20: error: undefined identifier 'fun'
		if(fun.type.getHeadUnqual().getFunctionTy().ret is Type.get!void()) return super.checkInterpret(sc);
                   ^~~
visitors.d:17:78: note: instantiated here
	static if(is(typeof(this):Expression)&&!is(typeof(this):Type)) mixin Interpret!(typeof(this));// TODO: minimize and report bug
                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~
expression.d:395:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
interpret.d:590:32: error: undefined identifier 'ctfeCallWrapper'
		callWrapper(sc,ctfeCallWrapper,consCall?consCall.e:null);		
                               ^~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
semantic.d:2727:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
semantic.d:2696:18: error: undefined identifier 'string'
	override string toString(){return "("~join(map!(to!string)(types),",")~")";}
                 ^~~~~~
semantic.d:2685:19: error: undefined identifier 'size_t'
	@property size_t length(){ return types.length;}
                  ^~~~~~
semantic.d:2697:28: error: undefined identifier 'string'
	override @property string kind(){return "type sequence";}
                           ^~~~~~
semantic.d:2739:18: error: undefined identifier 'size_t'
	override size_t tmplArgToHash(){
                 ^~~~~~
semantic.d:2700:23: error: undefined identifier 'util'
		alias util.all all;
                      ^~~~
semantic.d:2730:23: error: undefined identifier 'util'
		alias util.all all;
                      ^~~~
semantic.d:2702:30: error: no member 'isTypeTuple' for type 'Type'
		if(auto tt = rhs.isTypeTuple()){
                             ^~~~~~~~~~~~~~~
semantic.d:2703:39: error: undefined identifier 'types'
			if(tt.length!=types.length) return false;
                                      ^~~~~
semantic.d:2732:30: error: no member 'isTypeTuple' for type 'Expression'
		if(auto tt = rhs.isTypeTuple()){
                             ^~~~~~~~~~~~~~~
semantic.d:2733:39: error: undefined identifier 'types'
			if(tt.length!=types.length) return false;
                                      ^~~~~
semantic.d:8606:58: error: undefined identifier 'format'
						sc.error(format("tuple of %d elements cannot be assigned to tuple of %d elements",et.length,len),loc);
                                                         ^~~~~~
<mixin@<mixin@semantic.d:8607>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8607>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:2683:38: error: undefined identifier 'types'
		return New!TypeTuple(types[cast(size_t)a..cast(size_t)b]);
                                     ^~~~~
semantic.d:2683:49: error: undefined identifier 'size_t'
		return New!TypeTuple(types[cast(size_t)a..cast(size_t)b]);
                                                ^~~~~~
semantic.d:2704:59: error: undefined identifier 'zip'
			return all!(a=>a[0].equals(a[1]))(zip(types, tt.types));
                                                          ^~~
semantic.d:2704:63: error: undefined identifier 'types'
			return all!(a=>a[0].equals(a[1]))(zip(types, tt.types));
                                                              ^~~~~
semantic.d:2734:66: error: undefined identifier 'zip'
			return all!(_=>_[0].tmplArgEquals(_[1]))(zip(types,tt.types));
                                                                 ^~~
semantic.d:2734:70: error: undefined identifier 'types'
			return all!(_=>_[0].tmplArgEquals(_[1]))(zip(types,tt.types));
                                                                     ^~~~~
semantic.d:2675:24: error: undefined identifier 'types'
		return types[cast(size_t)index];
                       ^~~~~
semantic.d:2683:64: error: undefined identifier 'size_t'
		return New!TypeTuple(types[cast(size_t)a..cast(size_t)b]);
                                                               ^~~~~~
semantic.d:2675:35: error: undefined identifier 'size_t'
		return types[cast(size_t)index];
                                  ^~~~~~
<mixin@semantic.d:2667>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:2667>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:2667>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
semantic.d:8616:37: error: no member 'isVoidInitializerExp' for type 'Expression'
				if(!init.isVoidInitializerExp){
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8617:47: error: undefined identifier 'ImplConvertsTo'
					mixin(ImplConvertsTo!q{bool iconv; init, type});
                                              ^~~~~~~~~~~~~~
semantic.d:8618:45: error: undefined identifier 'iconv'
					if(!iconv) mixin(ImplConvertTo!q{init, type});
                                            ^~~~~
semantic.d:8622:28: error: cannot cast expression 'init' of type 'Expression' to 'bool'
			if(init) assert(tt || et && et.length==len && init.sstate == SemState.completed);
                           ^~~~
semantic.d:8624:29: error: cannot cast expression 'tc.vds' of type 'VarDecl[]' to 'bool'
			if(!tc.vds){
                            ^~~~~~
semantic.d:8627:52: error: cannot cast expression 'name' of type 'Identifier' to 'bool'
					auto id  = name?New!Identifier("__tuple_"~name.name~"_"~to!string(i)):null;
                                                   ^~~~
interpret.d:590:48: error: cannot cast expression 'consCall' of type 'CallExp' to 'bool'
		callWrapper(sc,ctfeCallWrapper,consCall?consCall.e:null);		
                                               ^~~~~~~~
visitors.d:17:78: note: instantiated here
	static if(is(typeof(this):Expression)&&!is(typeof(this):Type)) mixin Interpret!(typeof(this));// TODO: minimize and report bug
                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5389:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
semantic.d:5658:20: error: cannot cast expression 'meaning' of type 'Declaration' to 'bool'
		if(meaning) return;
                   ^~~~~~~
semantic.d:5552:21: error: cannot cast expression 'meaning' of type 'Declaration' to 'bool'
		if(!meaning) lookupSemantic(sc, sc);
                    ^~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
expression.d:247:18: error: undefined identifier 'string'
	override string toString(){return !meaning?_brk(name):super.toString();}
                 ^~~~~~
expression.d:236:9: error: undefined identifier 'string'
	string name;
        ^~~~~~
semantic.d:5679:14: error: undefined identifier 'string'
	this(string name, Scope lkup){
             ^~~~~~
scheduler.d:225:25: error: need 'this' to access field 'Identifier.tryAgain'
			Identifier.tryAgain = true;
                        ^~~~~~~~~~~~~~~~~~~
semantic.d:5664:9: note: field was declared here
	static bool tryAgain = false;
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:10341>:4:9: error: need 'this' to access field 'Identifier.tryAgain'
	Identifier.tryAgain = true;
        ^~~~~~~~~~~~~~~~~~~
semantic.d:5664:9: note: field was declared here
	static bool tryAgain = false;
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
parser.d:1167:73: error: function call result 'this.tok()' of type 'Token' is not callable
				name=New!Identifier(tok.name); name.loc=tok.loc; nextToken();
                                                                        ^~~
expression.d:240:14: error: undefined identifier 'string'
	this(string name){ // TODO: make more efficient, this is a bottleneck!
             ^~~~~~
expression.d:248:28: error: undefined identifier 'string'
	override @property string kind(){return meaning?super.kind:"identifier";}
                           ^~~~~~
<mixin@semantic.d:10423>:4:9: error: need 'this' to access field 'Identifier.tryAgain'
	Identifier.tryAgain = true;
        ^~~~~~~~~~~~~~~~~~~
semantic.d:5664:9: note: field was declared here
	static bool tryAgain = false;
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:2101>:4:9: error: need 'this' to access field 'Identifier.tryAgain'
	Identifier.tryAgain = true;
        ^~~~~~~~~~~~~~~~~~~
semantic.d:5664:9: note: field was declared here
	static bool tryAgain = false;
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
parser.d:1209:63: error: function call result 'this.tok()' of type 'Token' is not callable
			name=New!Identifier("this"), name.loc=tok.loc; nextToken();
                                                              ^~~
scheduler.d:227:33: error: need 'this' to access field 'Identifier.tryAgain'
				Identifier.tryAgain = false;
                                ^~~~~~~~~~~~~~~~~~~
semantic.d:5664:9: note: field was declared here
	static bool tryAgain = false;
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:2101>:6>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
scope_.d:50:22: error: undefined identifier 'format'
		note(format("this lookup should have %s if it was valid", lookup.meaning?"resolved to it":"succeeded"), lookup.loc);
                     ^~~~~~
scope_.d:50:75: error: cannot cast expression 'lookup.meaning' of type 'Declaration' to 'bool'
		note(format("this lookup should have %s if it was valid", lookup.meaning?"resolved to it":"succeeded"), lookup.loc);
                                                                          ^~~~~~~~~~~~~~
parser.d:1172:54: error: cannot cast expression 'name' of type 'Identifier' to 'bool'
			}else if(ttype==Tok!"*=" && !name){ // EXTENSION
                                                     ^~~~
parser.d:1173:57: error: function call result 'this.tok()' of type 'Token' is not callable
				auto oloc = type.loc.to(tok.loc);
                                                        ^~~
parser.d:1210:44: error: default parameters not implemented yet
			if(ttype==Tok!"("&&peek().type==Tok!"this"){
                                           ^~~~~~
parser.d:1212:81: error: function call result 'this.tok()' of type 'Token' is not callable
				auto param = New!PostblitParameter(); param.loc=tok.loc;
                                                                                ^~~
scope_.d:83:30: error: no member 'isOverloadableDecl' for type 'Declaration'
		if(auto ov = decl.isOverloadableDecl()){
                             ^~~~~~~~~~~~~~~~~~~~~~~
scope_.d:88:17: error: undefined identifier 'symtab'
		symtab[decl.name.ptr]=decl;
                ^~~~~~
scope_.d:290:41: error: undefined identifier 'psymtab'
		auto ptr = ident.ptr in psymtab;
                                        ^~~~~~~
scope_.d:266:41: error: undefined identifier 'psymtab'
		auto ptr = ident.ptr in psymtab;
                                        ^~~~~~~
semantic.d:10899:45: error: no member 'init' for type 'long'
		auto alias_ = New!AliasDecl(STC.init, New!VarDecl(STC.init,uexp,New!Identifier(tmplname),Expression.init));
                                            ^~~~~~~~
semantic.d:10899:67: error: no member 'init' for type 'long'
		auto alias_ = New!AliasDecl(STC.init, New!VarDecl(STC.init,uexp,New!Identifier(tmplname),Expression.init));
                                                                  ^~~~~~~~
semantic.d:10899:106: error: no member 'init' for type 'Expression'
		auto alias_ = New!AliasDecl(STC.init, New!VarDecl(STC.init,uexp,New!Identifier(tmplname),Expression.init));
                                                                                                         ^~~~~~~~~~~~~~~
scope_.d:267:26: error: undefined identifier 'psymtab'
		if(!ptr) psymtab[ident.ptr]~=decl;
                         ^~~~~~~
parser.d:1216:44: error: default parameters not implemented yet
		}else if(ttype==Tok!"~" && peek().type==Tok!"this"){
                                           ^~~~~~
parser.d:1218:38: error: function call result 'this.tok()' of type 'Token' is not callable
			Location loc=tok.loc;
                                     ^~~
parser.d:1219:54: error: function call result 'this.tok()' of type 'Token' is not callable
			nextToken(), name.loc=loc.to(tok.loc);
                                                     ^~~
parser.d:1222:38: error: function call result 'this.tok()' of type 'Token' is not callable
			Location loc=tok.loc;
                                     ^~~
semantic.d:2905:80: error: cannot implicitly convert parameter 'x' of type 'Declaration[]' to 'Declaration'
			if(x.name && x.name.name is name.name) eponymousDecl = x;
                                                                               ^
<mixin@<mixin@semantic.d:8315>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8315>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8315>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8315>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4421:24: error: undefined identifier 'STCstatic'
		if(stc&STCstatic && (!(stc&(STCimmutable|STCconst)||!init))){
                       ^~~~~~~~~
interpret.d:4421:45: error: undefined identifier 'STCimmutable'
		if(stc&STCstatic && (!(stc&(STCimmutable|STCconst)||!init))){
                                            ^~~~~~~~~~~~
interpret.d:4421:58: error: undefined identifier 'STCconst'
		if(stc&STCstatic && (!(stc&(STCimmutable|STCconst)||!init))){
                                                         ^~~~~~~~
interpret.d:4421:70: error: cannot cast expression 'init' of type 'Expression' to 'bool'
		if(stc&STCstatic && (!(stc&(STCimmutable|STCconst)||!init))){
                                                                     ^~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
declaration.d:446:18: error: undefined identifier 'string'
	override string toString(){
                 ^~~~~~
declaration.d:431:18: error: undefined identifier 'string'
	override string toString(){return "this";}
                 ^~~~~~
declaration.d:412:28: error: undefined identifier 'string'
	override @property string kind(){return "parameter";}
                           ^~~~~~
declaration.d:410:18: error: undefined identifier 'string'
	override string toString(){return (rtype?STCtoString(astStc)~(astStc?" ":"")~rtype.toString():type?STCtoString(stc)~(stc?" ":"")~type.toString()~" ":"")~
                 ^~~~~~
declaration.d:430:22: error: no member 'init' for type 'long'
	this(){super(STC.init,null,null,null);}
                     ^~~~~~~~
declaration.d:439:25: error: undefined identifier 'STCauto'
		stc &= ~STCauto; // auto does not matter
                        ^~~~~~~
declaration.d:440:64: error: current object 'super' of type 'OverloadableDecl' is not callable
		this.type=type; pre=pr, post=po; postres=pres; super(stc, name);
                                                               ^~~~~~~~~~~~~~~~
declaration.d:409:82: error: current object 'super' of type 'VarDecl' is not callable
	this(STC stc, Expression rtype, Identifier name, Expression initializer){super(stc,rtype,name,initializer);}
                                                                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4424:25: error: undefined identifier 'STCenum'
		}if(stc&STCenum){
                        ^~~~~~~
parser.d:1180:48: error: function call result 'this.ptok()' of type 'const(Token)' is not callable
		Lcarrayparameter: p.loc=loc.to(ptok.loc);
                                               ^~~~
semantic.d:5685:21: error: cannot cast expression 'meaning' of type 'Declaration' to 'bool'
		if(!meaning) lookupSemantic(sc, lkup);
                    ^~~~~~~
interpret.d:4430:25: error: undefined identifier 'size_t'
			size_t len, off = getBCLoc(len);
                        ^~~~~~
interpret.d:4430:25: error: undefined identifier 'size_t'
			size_t len, off = getBCLoc(len);
                        ^~~~~~
interpret.d:4434:41: error: undefined identifier 'STCimmutable'
				if(stc&(STCimmutable|STCconst)&&init){
                                        ^~~~~~~~~~~~
interpret.d:4434:54: error: undefined identifier 'STCconst'
				if(stc&(STCimmutable|STCconst)&&init){
                                                     ^~~~~~~~
scheduler.d:229:32: error: need 'this' to access field 'Identifier.tryAgain'
			}while(Identifier.tryAgain);
                               ^~~~~~~~~~~~~~~~~~~
semantic.d:5664:9: note: field was declared here
	static bool tryAgain = false;
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
scope_.d:90:17: error: need 'this' to access field 'Identifier.tryAgain'
		Identifier.tryAgain = true; // TODO: is this required?
                ^~~~~~~~~~~~~~~~~~~
semantic.d:5664:9: note: field was declared here
	static bool tryAgain = false;
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
statement.d:158:18: error: undefined identifier 'string'
	override string toString(){return "continue"~(e?" "~e.name:"")~";";}
                 ^~~~~~
scope_.d:308:40: error: undefined identifier 'zip'
				return zip(chain(psym,arbitrary),chain(psym,arbitrarydecls))
                                       ^~~
statement.d:165:18: error: undefined identifier 'string'
	override string toString(){return "break"~(e?" "~e.name:"")~";";}
                 ^~~~~~
scope_.d:643:31: error: undefined identifier 'format'
			error(format("redefinition of label '%s'",stm.l.toString()),stm.l.loc);
                              ^~~~~~
semantic.d:1976:60: error: cannot implicitly convert function call result 'funparams[i].ddup()' of type 'Parameter' to 'Parameter[]'
		foreach(i,ref t;iftiEponymousParameters) t=funparams[i].ddup();
                                                           ^~~~~~~~~~~~~~~~~~~
semantic.d:10909:60: error: cannot cast expression 'bdy.decls[0]' of type 'Declaration' to 'FunctionDecl'
				assert(!!cast(FunctionDecl)bdy.decls[0]);
                                                           ^~~~~~~~~~~~
semantic.d:10910:69: error: cannot cast expression 'bdy.decls[0]' of type 'Declaration' to 'void*'
				return cast(FunctionDecl)cast(void*)bdy.decls[0];
                                                                    ^~~~~~~~~~~~
semantic.d:1982:36: error: no member 'which' for type 'TemplateParameter[]'
				if(p.which == WhichTemplateParameter.type
                                   ^~~~~~~
semantic.d:1983:36: error: no member 'which' for type 'TemplateParameter[]'
				|| p.which == WhichTemplateParameter.tuple)
                                   ^~~~~~~
scope_.d:647:17: error: undefined identifier 'lstmsymtab'
		lstmsymtab[stm.l.ptr] = stm;
                ^~~~~~~~~~
scheduler.d:233:25: error: need 'this' to access field 'Identifier.allowDelay'
			Identifier.allowDelay=false;
                        ^~~~~~~~~~~~~~~~~~~~~
semantic.d:5665:9: note: field was declared here
	static bool allowDelay = false;
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
scope_.d:308:44: error: undefined identifier 'chain'
				return zip(chain(psym,arbitrary),chain(psym,arbitrarydecls))
                                           ^~~~~
scope_.d:308:55: error: undefined identifier 'arbitrary'
				return zip(chain(psym,arbitrary),chain(psym,arbitrarydecls))
                                                      ^~~~~~~~~
scope_.d:308:66: error: undefined identifier 'chain'
				return zip(chain(psym,arbitrary),chain(psym,arbitrarydecls))
                                                                 ^~~~~
scope_.d:308:77: error: undefined identifier 'arbitrarydecls'
				return zip(chain(psym,arbitrary),chain(psym,arbitrarydecls))
                                                                            ^~~~~~~~~~~~~~
semantic.d:1984:71: error: no member 'which' for type 'TemplateParameter[]'
					matcherTypes[i]=New!MatcherTy(p.which);
                                                                      ^~~~~~~
scheduler.d:235:25: error: need 'this' to access field 'Identifier.allowDelay'
			Identifier.allowDelay=true;
                        ^~~~~~~~~~~~~~~~~~~~~
semantic.d:5665:9: note: field was declared here
	static bool allowDelay = false;
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
scope_.d:312:24: error: undefined identifier 'psymtab'
		return psymtab.get(ident.ptr,[])~arbitrarydecls;
                       ^~~~~~~
scope_.d:312:50: error: undefined identifier 'arbitrarydecls'
		return psymtab.get(ident.ptr,[])~arbitrarydecls;
                                                 ^~~~~~~~~~~~~~
semantic.d:8627:97: error: undefined identifier 'to'
					auto id  = name?New!Identifier("__tuple_"~name.name~"_"~to!string(i)):null;
                                                                                                ^~
semantic.d:8628:52: error: cannot cast expression 'init' of type 'Expression' to 'bool'
					auto ini = init&&et?et.index(sc,InContext.none,init.loc,i):null;
                                                   ^~~~
semantic.d:8628:58: error: cannot cast expression 'et' of type 'ExpTuple' to 'bool'
					auto ini = init&&et?et.index(sc,InContext.none,init.loc,i):null;
                                                         ^~
parser.d:107:40: error: undefined identifier 'string'
	else static if(is(typeof(T[0]):string)) enum doParseImpl={
                                       ^~~~~~
semantic.d:1987:49: error: no member 'init' for type 'long'
			auto al = New!AliasDecl(STC.init, New!VarDecl(STC.init, resolved[i]?resolved[i]:matcherTypes[i], parent.params[i].name,null));
                                                ^~~~~~~~
semantic.d:1987:71: error: no member 'init' for type 'long'
			auto al = New!AliasDecl(STC.init, New!VarDecl(STC.init, resolved[i]?resolved[i]:matcherTypes[i], parent.params[i].name,null));
                                                                      ^~~~~~~~
semantic.d:10903:58: error: no member 'init' for type 'Expression'
				super(false,stc,name,prm,Expression.init,b);
                                                         ^~~~~~~~~~~~~~~
parser.d:125:39: note: instantiated here
private template doParse(T...){ alias doParseImpl!(true,T) doParse; }
                                      ^~~~~~~~~~~~~~~~~~~~
parser.d:1223:31: note: instantiated here
			mixin(doParse!("_","(",")"));
                              ^~~~~~~~~~~~~~~~~~~~~
parser.d:1229:93: error: undefined identifier 'string'
			if(ttype!=Tok!"i") expectErr!"function name"(), name=New!Identifier(string.init);
                                                                                            ^~~~~~
parser.d:1230:50: error: function call result 'this.tok()' of type 'Token' is not callable
			else{name=New!Identifier(tok.name); name.loc=tok.loc; nextToken();}
                                                 ^~~
parser.d:1230:70: error: function call result 'this.tok()' of type 'Token' is not callable
			else{name=New!Identifier(tok.name); name.loc=tok.loc; nextToken();}
                                                                     ^~~
parser.d:1233:24: error: default parameters not implemented yet
		params=parseParameterList(vararg);
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:1991:25: error: feature declaration.DebugDecl not implemented
			debug{
                        ^~~~~~
<mixin@semantic.d:5518>:34:21: error: cannot cast expression 'constructor.meaning' of type 'Declaration' to 'bool'
		if(!constructor.meaning){
                    ^~~~~~~~~~~~~~~~~~~
semantic.d:5644:47: error: cannot cast expression 'meaning.scope_' of type 'Scope' to 'NestedScope'
		if(auto nest=cast(NestedScope)meaning.scope_){
                                              ^~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
<mixin@semantic.d:5518>:35:31: error: undefined identifier 'Lookup'
			mixin(Lookup!q{_; constructor, sc, caggr.asc});
                              ^~~~~~
semantic.d:10914:52: error: undefined identifier 'STCstatic'
		auto t=New!FunclitTemplateDecl(stc&STCstatic, New!Identifier(tmplname), tparams,
                                                   ^~~~~~~~~
semantic.d:10915:58: error: no member 'init' for type 'long'
		                           New!BlockDecl(STC.init,[cast(Declaration)this,alias_]),sc);
                                                         ^~~~~~~~
<mixin@semantic.d:5518>:39:13: error: cannot cast expression 'constructor' of type 'Identifier' to 'bool'
	if(!constructor||constructor.sstate == SemState.failed){
            ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8155>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:2910>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:2910>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8155>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@<mixin@semantic.d:5518>:45>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@<mixin@semantic.d:5518>:45>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8629:45: error: undefined identifier 'newVarDecl'
					x = newVarDecl(stc, tp.index(sc,InContext.none,loc,i), id, ini);
                                            ^~~~~~~~~~
<mixin@<mixin@semantic.d:5661>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
interpret.d:4516:65: error: type 'LVpopc' is not callable
		return inHeapContext?diff?LVpopcc(type, loader):LVpopc(type, loader):LVpopr(len);
                                                                ^~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:5559>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:5661>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:5559>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:5559>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:8630:41: error: no member 'sstate' for type 'VarDecl[]'
					x.sstate = SemState.begin;
                                        ^~~~~~~~
semantic.d:8631:41: error: no member 'loc' for type 'VarDecl[]'
					x.loc = loc;
                                        ^~~~~
semantic.d:8632:41: error: no member 'scope_' for type 'VarDecl[]'
					x.scope_=scope_;
                                        ^~~~~~~~
semantic.d:8633:41: error: no member 'isField' for type 'VarDecl[]'
					x.isField=isField;
                                        ^~~~~~~~~
semantic.d:8637:29: error: cannot cast expression 'tc.syms' of type 'Expression[]' to 'bool'
			if(!tc.syms){
                            ^~~~~~~
semantic.d:5562:23: error: undefined identifier 'Lookup'
		mixin(Lookup!q{_;this,sc,lkup});
                      ^~~~~~
semantic.d:8158:57: error: undefined identifier 'curparam'
				if(vars.length == 2 && !curparam){
                                                        ^~~~~~~~
semantic.d:8160:44: error: cannot cast expression 'vars[0].rtype' of type 'Expression' to 'bool'
					if(vars[0].rtype){
                                           ^~~~~~~~~~~~~
semantic.d:8161:91: error: undefined identifier 'lsc'
						vars[0].type = vars[0].rtype.typeSemantic(lsc);
                                                                                          ^~~
semantic.d:8649:29: error: cannot cast expression 'tc.tupleAlias' of type 'AliasDecl' to 'bool'
			if(!tc.tupleAlias){
                            ^~~~~~~~~~~~~
semantic.d:5565:34: error: undefined identifier 'format'
			sc.error(format("undefined identifier '%s'",name), loc);
                                 ^~~~~~
<mixin@semantic.d:5518>:52:23: error: undefined identifier 'MatchCallHelper'
		mixin(MatchCallHelper!q{auto r; constructor, sc, loc, type, args, context});
                      ^~~~~~~~~~~~~~~
semantic.d:8652:63: error: no member 'init' for type 'long'
				tc.tupleAlias = New!AliasDecl(STC.init, newVarDecl(STC.init, stpl, name, null));
                                                              ^~~~~~~~
semantic.d:8652:73: error: undefined identifier 'newVarDecl'
				tc.tupleAlias = New!AliasDecl(STC.init, newVarDecl(STC.init, stpl, name, null));
                                                                        ^~~~~~~~~~
semantic.d:8652:84: error: no member 'init' for type 'long'
				tc.tupleAlias = New!AliasDecl(STC.init, newVarDecl(STC.init, stpl, name, null));
                                                                                   ^~~~~~~~
<mixin@<mixin@semantic.d:5566>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:5566>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8658:33: error: cannot cast expression 'tt' of type 'TypeTuple' to 'bool'
			assert(!tt||cast(CallExp)init);
                                ^~
semantic.d:8658:50: error: cannot cast expression 'init' of type 'Expression' to 'CallExp'
			assert(!tt||cast(CallExp)init);
                                                 ^~~~
semantic.d:8659:28: error: cannot cast expression 'tt' of type 'TypeTuple' to 'bool'
			if(tt){
                           ^~
<mixin@semantic.d:5518>:54:21: error: undefined identifier 'r'
		if(!r){
                    ^
<mixin@<mixin@<mixin@semantic.d:5518>:57>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@<mixin@semantic.d:5518>:57>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:5518>:59:21: error: cannot cast expression 'consCall' of type 'CallExp' to 'bool'
		if(!consCall){
                    ^~~~~~~~
<mixin@semantic.d:5518>:61:25: error: no member 'fun' for type 'CallExp'
			consCall.fun = r;
                        ^~~~~~~~~~~~
<mixin@semantic.d:5518>:61:40: error: undefined identifier 'r'
			consCall.fun = r;
                                       ^
semantic.d:8164:66: error: undefined identifier 'format'
							sc.error(format("invalid type '%s' for index variable '%s'", vars[0].rtype.loc.rep, vars[0].name.toString()), vars[0].rtype.loc);
                                                                 ^~~~~~
semantic.d:8168:41: error: undefined identifier 'curparam'
					curparam++;
                                        ^~~~~~~~
semantic.d:8170:36: error: undefined identifier 'curparam'
				if(curparam < vars.length){
                                   ^~~~~~~~
semantic.d:8171:49: error: undefined identifier 'curparam'
					if(vars[curparam].rtype){
                                                ^~~~~~~~
semantic.d:8172:54: error: undefined identifier 'curparam'
						vars[curparam].type = vars[curparam].rtype.typeSemantic(lsc);
                                                     ^~~~~~~~
semantic.d:8172:76: error: undefined identifier 'curparam'
						vars[curparam].type = vars[curparam].rtype.typeSemantic(lsc);
                                                                           ^~~~~~~~
semantic.d:8172:105: error: undefined identifier 'lsc'
						vars[curparam].type = vars[curparam].rtype.typeSemantic(lsc);
                                                                                                        ^~~
semantic.d:8661:80: error: cannot cast expression 'init' of type 'Expression' to 'void*'
				init = makeMultiReturn(cast(CallExp)cast(void*)init);
                                                                               ^~~~
semantic.d:8666:18: error: feature not implemented
		{scope(exit) if(sstate==SemState.error) type=null;
                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8677:21: error: cannot cast expression 'init' of type 'Expression' to 'bool'
		if(!init) defaultInit(); // TODO: this is a hack (and incorrect, since some code relies on init==null)
                    ^~~~
semantic.d:8174:55: error: undefined identifier 'ImplConvertsTo'
						mixin(ImplConvertsTo!q{auto iconv; et, vars[curparam].type});
                                                      ^~~~~~~~~~~~~~
semantic.d:8679:20: error: cannot cast expression 'init' of type 'Expression' to 'bool'
		if(init){
                   ^~~~
semantic.d:8686:39: error: undefined identifier 'ImplConvertsTo'
				mixin(ImplConvertsTo!q{bool iconv;init, type});
                                      ^~~~~~~~~~~~~~
semantic.d:8688:37: error: undefined identifier 'iconv'
				if(!iconv) mixin(FinishDeductionProp!q{init});
                                    ^~~~~
semantic.d:8689:75: error: undefined identifier 'to'
				assert(init.sstate == SemState.completed, to!string(init));
                                                                          ^~
semantic.d:8175:53: error: undefined identifier 'iconv'
						if(!iconv){
                                                    ^~~~~
semantic.d:8176:66: error: undefined identifier 'format'
							sc.error(format("cannot implicitly convert from element type '%s' to '%s'", et.toString(), vars[curparam].rtype.loc.rep),vars[curparam].rtype.loc);
                                                                 ^~~~~~
semantic.d:8695:29: error: no member 'isVoidInitializerExp' for type 'Expression'
			if(!init.isVoidInitializerExp()){
                            ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8701:40: error: undefined identifier 'STCenum'
				if(stc&STCenum){
                                       ^~~~~~~
semantic.d:8176:153: error: undefined identifier 'curparam'
							sc.error(format("cannot implicitly convert from element type '%s' to '%s'", et.toString(), vars[curparam].rtype.loc.rep),vars[curparam].rtype.loc);
                                                                                                                                                        ^~~~~~~~
semantic.d:8706:30: error: undefined identifier 'STCenum'
		}else if(stc&STCenum){
                             ^~~~~~~
<mixin@<mixin@semantic.d:8708>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8708>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8176:183: error: undefined identifier 'curparam'
							sc.error(format("cannot implicitly convert from element type '%s' to '%s'", et.toString(), vars[curparam].rtype.loc.rep),vars[curparam].rtype.loc);
                                                                                                                                                                                      ^~~~~~~~
semantic.d:8179:52: error: undefined identifier 'curparam'
					}else vars[curparam].type = ty;
                                                   ^~~~~~~~
semantic.d:8180:41: error: undefined identifier 'curparam'
					curparam++;
                                        ^~~~~~~~
semantic.d:8190:36: error: no member 'semantic' for type 'Parameter[]'
		foreach(var; vars) var.semantic(lsc); // TODO: fix?
                                   ^~~~~~~~~~~~
semantic.d:8190:49: error: undefined identifier 'lsc'
		foreach(var; vars) var.semantic(lsc); // TODO: fix?
                                                ^~~
semantic.d:8713:37: error: no member 'isAggregateDecl' for type 'Declaration'
			auto aggr = sc.getDeclaration().isAggregateDecl();
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8715:35: error: undefined identifier 'STCstatic'
			if(!(stc&(STCstatic|STCenum))) aggr.layoutChanged();
                                  ^~~~~~~~~
semantic.d:8715:45: error: undefined identifier 'STCenum'
			if(!(stc&(STCstatic|STCenum))) aggr.layoutChanged();
                                            ^~~~~~~
semantic.d:8192:30: error: undefined identifier 'lsc'
		bdy.semantic(lsc); // TODO: get rid of direct call
                             ^~~
<mixin@<mixin@semantic.d:8195>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8195>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
statement.d:112:18: error: undefined identifier 'string'
	override string toString(){return "foreach"~(isReverse?"_reverse":"")~"("~join(map!(to!string)(vars),",")~";"~aggregate.toString()~") "~bdy.toString();}
                 ^~~~~~
util.d:305:27: error: no member 'stringof' for type 'FunctionDef'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
parser.d:1019:25: error: unimplemented feature SwitchStm
			switch(ttype){
                        ^~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'FunctionDef'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
parser.d:1235:22: note: instantiated here
		stc|=parseSTC!functionSTC();
                     ^~~~~~~~~~~~~~~~~~~~
declaration.d:471:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
parser.d:1240:38: error: function call result 'this.tok()' of type 'Token' is not callable
			Location loc=tok.loc; nextToken(); pre=parseCompoundStm(); pre.loc=loc.to(pre.loc);
                                     ^~~
parser.d:1244:58: error: function call result 'this.tok()' of type 'Token' is not callable
			if(ttype==Tok!"in"){Location loc=tok.loc; nextToken(); pre=parseCompoundStm(); pre.loc=loc.to(pre.loc);}
                                                         ^~~
parser.d:1248:28: error: cannot cast expression 'pre' of type 'CompoundStm' to 'bool'
			if(pre||post) expect(Tok!"body");
                           ^~~
parser.d:1248:33: error: cannot cast expression 'post' of type 'CompoundStm' to 'bool'
			if(pre||post) expect(Tok!"body");
                                ^~~~
parser.d:1260:62: error: no member 'init' for type 'long'
			r=New!FunctionDef(stc,New!FunctionTy(STC.init,ret,params,vararg),name,pre,post,pres,bdy);
                                                             ^~~~~~~~
parser.d:1262:29: error: cannot cast expression 'pre' of type 'CompoundStm' to 'bool'
			if(!pre&&!post) expect(Tok!";");
                            ^~~
parser.d:1262:35: error: cannot cast expression 'post' of type 'CompoundStm' to 'bool'
			if(!pre&&!post) expect(Tok!";");
                                  ^~~~
parser.d:1263:63: error: no member 'init' for type 'long'
			r=New!FunctionDecl(stc,New!FunctionTy(STC.init,ret,params,vararg),name,pre,post,pres);
                                                              ^~~~~~~~
parser.d:1265:34: error: function call result 'this.tok()' of type 'Token' is not callable
		r.loc = begin.to(tok.loc);
                                 ^~~
visitors.d:17:78: note: instantiated here
	static if(is(typeof(this):Expression)&&!is(typeof(this):Type)) mixin Interpret!(typeof(this));// TODO: minimize and report bug
                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~
expression.d:283:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:7955:16: error: undefined identifier 'string'
	static string valueToString(Type type, Variant value)in{
               ^~~~~~
semantic.d:7936:18: error: undefined identifier 'string'
	override string toString(){
                 ^~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4809:29: error: undefined identifier 'fun'
		if(auto s = fun.isSymbol())if(auto m = s.meaning)
                            ^~~
semantic.d:5755:28: error: undefined identifier 'string'
	override @property string kind(){ return "current object"; }
                           ^~~~~~
semantic.d:611:60: error: undefined identifier 'min'
					self.accessCheck = min(self.accessCheck, check);
                                                           ^~~
semantic.d:593:60: error: undefined identifier 'min'
					self.accessCheck = min(self.accessCheck, check);
                                                           ^~~
interpret.d:4287:42: error: cannot cast expression 'type.getHeadUnqual()' of type 'Type' to 'AggregateTy'
		assert((cast(AggregateTy)type.getHeadUnqual())&&cast(ValueAggregateDecl)(cast(AggregateTy)type.getHeadUnqual()).decl);
                                         ^~~~~~~~~~~~~~~~~~~~
interpret.d:4287:107: error: cannot cast expression 'type.getHeadUnqual()' of type 'Type' to 'AggregateTy'
		assert((cast(AggregateTy)type.getHeadUnqual())&&cast(ValueAggregateDecl)(cast(AggregateTy)type.getHeadUnqual()).decl);
                                                                                                          ^~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
<mixin@semantic.d:5722>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:5722>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:5722>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:5725:21: error: cannot cast expression 'aggr' of type 'AggregateDecl' to 'bool'
		if(!aggr){
                    ^~~~
semantic.d:5726:34: error: undefined identifier 'format'
			sc.error(format("invalid use of '%s' outside of an aggregate declaration", toString()), loc);
                                 ^~~~~~
<mixin@<mixin@semantic.d:5727>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:5727>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5732:43: error: undefined identifier 'STCstatic'
				if(dl.stc&STCstatic) goto Lerr;
                                          ^~~~~~~~~
semantic.d:5735:29: error: cannot cast expression 'mfun' of type 'Declaration' to 'bool'
			if(!mfun||!mfun.isFunctionDecl()){
                            ^~~~
semantic.d:5735:36: error: no member 'isFunctionDecl' for type 'Declaration'
			if(!mfun||!mfun.isFunctionDecl()){
                                   ^~~~~~~~~~~~~~~~~~~
semantic.d:5737:42: error: undefined identifier 'format'
				sc.error(format("invalid use of '%s' outside of a nonstatic member function", toString()), loc);
                                         ^~~~~~
<mixin@<mixin@semantic.d:5738>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:5738>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5744:23: error: undefined identifier 'DetermineType'
		mixin(DetermineType!q{type; this, sc, aggr});
                      ^~~~~~~~~~~~~
<mixin@<mixin@semantic.d:5746>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:5746>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4851:20: error: undefined identifier 'fun'
		if(fun.type.getHeadUnqual().getFunctionTy().stc&STCref) LVpointer(type, this).emitLoad(bld);
                   ^~~
util.d:305:27: error: no member 'stringof' for type 'SuperExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                          ^~~~~~~~~~~~~~~~~~~~~
util.d:305:55: error: no member 'stringof' for type 'SuperExp'
	mixin(`override `~typeof(this).stringof~` is`~typeof(this).stringof~`(){return this;}`);
                                                      ^~~~~~~~~~~~~~~~~~~~~
expression.d:268:15: note: instantiated here
	mixin DownCastMethod;
              ^~~~~~~~~~~~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(FunctionDef)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
interpret.d:4215:20: error: cannot cast expression 'consCall' of type 'CallExp' to 'bool'
		if(consCall) tmpVarDecl.inHeapContext = true; // conservative, anticipating that the constructor might escape 'this'
                   ^~~~~~~~
semantic.d:9407:17: error: undefined identifier 'size_t'
	private size_t knownParents = 0;
                ^~~~~~
semantic.d:9243:27: error: undefined identifier 'size_t'
		@property size_t length(){ return vtbl.length; }
                          ^~~~~~
semantic.d:9417:45: error: undefined identifier 'size_t'
	public final void findFirstNParents(size_t n,bool weak=false)in{
                                            ^~~~~~
semantic.d:9242:17: error: undefined identifier 'size_t'
		size_t[FunctionDecl] vtblIndex;
                ^~~~~~
semantic.d:9317:28: error: type 'const(char)*' is not an expression
	private Identifier[const(char)*] sealedLookups;
                           ^~~~~~~~~~~~
semantic.d:9257:25: error: undefined identifier 'size_t'
			size_t index = vtblIndex[old];
                        ^~~~~~
semantic.d:9244:41: error: no member 'dup' for type 'VtblEntry[]'
		Vtbl dup(){ return Vtbl(vtbl.dup, vtblIndex.dup); }
                                        ^~~~~~~~
interpret.d:4810:56: error: undefined identifier 'STCstatic'
			if(m.isFunctionDecl()&&!(m.stc&STCstatic)) ctx=true;
                                                       ^~~~~~~~~
interpret.d:4811:29: error: undefined identifier 'fun'
		if(auto f = fun.isFieldExp())if(auto m = f.e2.meaning)
                            ^~~
interpret.d:4812:56: error: undefined identifier 'STCstatic'
			if(m.isFunctionDecl()&&!(m.stc&STCstatic)) ctx=true;
                                                       ^~~~~~~~~
interpret.d:4813:25: error: undefined identifier 'fun'
		auto tt=fun.type.getHeadUnqual();
                        ^~~
semantic.d:9250:31: error: too many arguments to struct literal (expected zero)
			vtbl~=VtblEntry(fun, VtblState.fresh);
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4826:17: error: undefined identifier 'fun'
		fun.byteCompile(bld);
                ^~~
semantic.d:9246:45: error: no member 'state' for type 'VtblEntry[]'
			foreach(ref x;vtbl) x.state = VtblState.inherited;
                                            ^~~~~~~
semantic.d:9260:37: error: too many arguments to struct literal (expected zero)
			vtbl[index]=VtblEntry(fresh, VtblState.overridden);
                                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4224:20: error: cannot cast expression 'consCall' of type 'CallExp' to 'bool'
		if(consCall){
                   ^~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
semantic.d:9310:38: error: cannot cast expression 'parents[0]' of type 'Expression' to 'bool'
		if(!parents.length||!parents[0]||parents[0].sstate!=SemState.completed) return null;
                                     ^~~~~~~~~~
expression.d:60:47: error: cannot cast expression 'dependee' of type 'Dependee' to 'bool'
		bool isIndependent(){ return !dependee; }
                                              ^~~~~~~~
semantic.d:9281:17: note: instantiated here
	private Dependent!ClassDecl inheritVtbl(){
                ^~~~~~~~~~~~~~~~~~~
semantic.d:9311:43: error: cannot cast expression 'parents[0]' of type 'Expression' to 'AggregateTy'
		assert(!!cast(AggregateTy)parents[0]);
                                          ^~~~~~~~~~
semantic.d:9312:53: error: cannot cast expression 'parents[0]' of type 'Expression' to 'void*'
		return (cast(AggregateTy)cast(void*)parents[0]).decl.isClassDecl();
                                                    ^~~~~~~~~~
semantic.d:9199:25: error: current object 'super' of type 'NestedScope' is not callable
			super(parent);
                        ^~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4175:20: error: cannot cast expression 'auto p=parentClass()' of type 'ClassDecl' to 'bool'
		if(auto p=parentClass()) if(auto r=p.traverseFields(dg)) return r;
                   ^~~~~~~~~~~~~~~~~~~~
interpret.d:4185:20: error: cannot cast expression 'auto p = parentClass()' of type 'ClassDecl' to 'bool'
		if(auto p = parentClass()) parentVers = p.getVersion();
                   ^~~~~~~~~~~~~~~~~~~~~~
interpret.d:4180:20: error: cannot cast expression 'auto p = parentClass()' of type 'ClassDecl' to 'bool'
		if(auto p = parentClass()) if(parentVers != getVersion()) return false;
                   ^~~~~~~~~~~~~~~~~~~~~~
declaration.d:290:28: error: current object 'super' of type 'AggregateDecl' is not callable
		parents=p; super(stc,name,b);
                           ^~~~~~~~~~~~~~~~~
expression.d:60:47: error: cannot cast expression 'dependee' of type 'Dependee' to 'bool'
		bool isIndependent(){ return !dependee; }
                                              ^~~~~~~~
interpret.d:4196:20: error: cannot cast expression 'auto p = parentClass()' of type 'ClassDecl' to 'bool'
		if(auto p = parentClass()) p.byteCompileFields(bld);
                   ^~~~~~~~~~~~~~~~~~~~~~
semantic.d:9337:9: note: instantiated here
	Dependent!OverloadSet lookupSealedOverloadSet(Scope view, Identifier name){
        ^~~~~~~~~~~~~~~~~~~~~
semantic.d:9203:31: error: undefined identifier 'format'
			error(format("declaration of '%s' "~suspiciousDeclDesc, decl), decl.loc);
                              ^~~~~~
semantic.d:9560:86: error: undefined identifier 'SupertypeStack'
	private final Dependent!bool isSubtypeOfImpl(ReferenceAggregateDecl rhs, ref SupertypeStack stack, out bool failed){
                                                                                     ^~~~~~~~~~~~~~
semantic.d:9475:23: error: undefined identifier 'CheckCircularInheritance'
		mixin(CheckCircularInheritance!q{_;this});
                      ^~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4167:47: error: feature not implemented
				if(!x.value){ throw new UnwindException; }
                                              ^~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4078:39: error: no member 'sizeof' for type 'ReferenceAggregateDecl'
			static assert(ReferenceAggregateDecl.sizeof<=(void*).sizeof &&
                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4078:70: error: no member 'sizeof' for type 'void*'
			static assert(ReferenceAggregateDecl.sizeof<=(void*).sizeof &&
                                                                     ^~~~~~~~~~~~~~
interpret.d:4080:64: error: cannot cast expression 'this' of type 'AggregateDecl' to 'void*'
			bld.emitConstant(cast(ulong)cast(void*)this);
                                                               ^~~~
interpret.d:4180:47: error: undefined identifier 'parentVers'
		if(auto p = parentClass()) if(parentVers != getVersion()) return false;
                                              ^~~~~~~~~~
interpret.d:4185:44: error: undefined identifier 'parentVers'
		if(auto p = parentClass()) parentVers = p.getVersion();
                                           ^~~~~~~~~~
interpret.d:4083:21: error: undefined identifier 'bcSize'
		if(!bcSize){
                    ^~~~~~
semantic.d:9318:20: error: undefined identifier 'std'
	Dependent!(std.typecons.Tuple!(OverloadSet,ubyte)) lookupSealedOverloadSetWithRetry(Scope view, Identifier name){
                   ^~~
interpret.d:3912:39: error: no member 'sizeof' for type 'FunctionDecl'
			static assert(fun.sizeof<=(void*).sizeof&&(void*).sizeof<=ulong.sizeof);
                                      ^~~~~~~~~~
interpret.d:3912:51: error: no member 'sizeof' for type 'void*'
			static assert(fun.sizeof<=(void*).sizeof&&(void*).sizeof<=ulong.sizeof);
                                                  ^~~~~~~~~~~~~~
interpret.d:3913:64: error: cannot cast expression 'fun' of type 'FunctionDecl' to 'void*'
			bld.emitConstant(cast(ulong)cast(void*)fun);
                                                               ^~~
semantic.d:9204:30: error: undefined identifier 'format'
			note(format("this lookup on subclass '%s' should have %s if it was valid", raggr.name,lookup.meaning?"resolved to it":"succeeded"), lookup.loc);
                             ^~~~~~
semantic.d:9476:23: error: undefined identifier 'InheritVtbl'
		mixin(InheritVtbl!q{ClassDecl _; this});
                      ^~~~~~~~~~~
semantic.d:9478:78: error: cannot cast expression 'parents[0]' of type 'Expression' to 'AggregateTy'
		assert(parents[0].sstate==SemState.error||!!cast(AggregateTy)parents[0]);
                                                                             ^~~~~~~~~~
semantic.d:9204:111: error: cannot cast expression 'lookup.meaning' of type 'Declaration' to 'bool'
			note(format("this lookup on subclass '%s' should have %s if it was valid", raggr.name,lookup.meaning?"resolved to it":"succeeded"), lookup.loc);
                                                                                                              ^~~~~~~~~~~~~~
semantic.d:9482:79: error: cannot cast expression 'parents[0]' of type 'Expression' to 'void*'
			hasExplicitBaseClass = !!(cast(AggregateTy)cast(void*)parents[0]).decl.isClassDecl();
                                                                              ^~~~~~~~~~
semantic.d:9486:28: error: no member 'sstate' for type 'Expression[]'
			if(x.sstate == SemState.error){rparents[i].sstate=SemState.error; continue;}
                           ^~~~~~~~
semantic.d:9487:32: error: no member 'sstate' for type 'Expression[]'
			assert(x.sstate == SemState.completed);
                               ^~~~~~~~
semantic.d:9488:51: error: cannot cast expression 'x' of type 'Expression[]' to 'AggregateTy'
			assert(!!cast(AggregateTy)x);
                                                  ^
semantic.d:9489:57: error: cannot cast expression 'x' of type 'Expression[]' to 'void*'
			if((cast(AggregateTy)cast(void*)x).decl.isClassDecl()){
                                                        ^
semantic.d:9501:25: error: initializer required for '' declaration
		foreach(decl; &bdy.traverseInOrder){
                        ^~~~
semantic.d:9502:38: error: undefined identifier 'decl'
			if(auto fd = decl.isFunctionDecl()){
                                     ^~~~
semantic.d:9505:39: error: undefined identifier 'AddToVtbl'
				mixin(AddToVtbl!(q{_;this,fd},false));
                                      ^~~~~~~~~
semantic.d:9509:22: error: type 'FunctionDecl' is not an expression
		bool[FunctionDecl] hiders;
                     ^~~~~~~~~~~~
semantic.d:9511:28: error: no member 'state' for type 'VtblEntry[]'
			if(x.state != VtblState.needsOverride) continue;
                           ^~~~~~~
semantic.d:9513:31: error: undefined identifier 'LookupSealedOverloadSetWithRetry'
			mixin(LookupSealedOverloadSetWithRetry!q{auto ovsnr; this, asc, x.fun.name});
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:9514:28: error: undefined identifier 'ovsnr'
			if(ovsnr[1]){ needRetry=ovsnr[1]; return; }
                           ^~~~~
semantic.d:9514:49: error: undefined identifier 'ovsnr'
			if(ovsnr[1]){ needRetry=ovsnr[1]; return; }
                                                ^~~~~
semantic.d:9515:34: error: undefined identifier 'ovsnr'
			auto ovs=ovsnr[0];
                                 ^~~~~
semantic.d:9527:34: error: cannot cast expression 'fun' of type 'FunctionDecl' to 'bool'
			assert(!!fun);
                                 ^~~
semantic.d:9531:25: error: undefined identifier 'string'
			string hint = fun.stc & STCoverride ?
                        ^~~~~~
semantic.d:9531:49: error: undefined identifier 'STCoverride'
			string hint = fun.stc & STCoverride ?
                                                ^~~~~~~~~~~
semantic.d:9535:25: error: undefined identifier 'string'
			string kind = fun.stc & STCoverride ?" override":"";
                        ^~~~~~
semantic.d:9535:49: error: undefined identifier 'STCoverride'
			string kind = fun.stc & STCoverride ?" override":"";
                                                ^~~~~~~~~~~
semantic.d:9537:38: error: undefined identifier 'format'
			scope_.error(format("method%s '%s' illegally shadows a method in the parent class%s", kind, fun.name, hint),fun.loc);
                                     ^~~~~~
semantic.d:9539:25: error: no member 'state' for type 'VtblEntry[]'
			x.state = VtblState.inherited;
                        ^~~~~~~
semantic.d:9543:23: error: undefined identifier 'FillShortcutScope'
		mixin(FillShortcutScope!q{_;this});
                      ^~~~~~~~~~~~~~~~~
semantic.d:9545:25: error: initializer required for '' declaration
		foreach(decl; &bdy.traverseInOrder) mixin(PropErr!q{decl});
                        ^~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:7:28: error: feature expression.TraitsExp not implemented
		enum siz = __traits(classInstanceSize,T);
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@visitors.d:38>:10:17: error: undefined identifier 'memcpy'
		memcpy(data.ptr, cast(void*)this, siz);
                ^~~~~~
<mixin@visitors.d:38>:10:45: error: cannot cast expression 'this' of type 'inout(SuperExp)' to 'void*'
		memcpy(data.ptr, cast(void*)this, siz);
                                            ^~~~
interpret.d:4833:64: error: no member 'type' for type 'Expression[]'
					numargs += getBCSizeof(x.type.getPointer());
                                                               ^~~~~~
<mixin@visitors.d:38>:23:27: error: feature expression.TraitsExp not implemented
		foreach(x;__traits(allMembers, T)){
                          ^~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4834:61: error: undefined identifier 'STClazy'
				}else if(ft.params[i].stc & STClazy){
                                                            ^~~~~~~
visitors.d:26:65: note: instantiated here
		static if(!is(typeof(this)==AggregateTy)) mixin DeepDup!(typeof(this));
                                                                ^~~~~~~~~~~~~~~~~~~~~~
interpret.d:4835:48: error: undefined identifier 'adapted'
					assert(adapted[i] && adapted[i].sstate == SemState.completed &&
                                               ^~~~~~~
interpret.d:4835:62: error: undefined identifier 'adapted'
					assert(adapted[i] && adapted[i].sstate == SemState.completed &&
                                                             ^~~~~~~
interpret.d:4836:48: error: undefined identifier 'adapted'
					       adapted[i].type.isDelegateTy());
                                               ^~~~~~~
interpret.d:4837:41: error: undefined identifier 'adapted'
					adapted[i].byteCompile(bld);
                                        ^~~~~~~
interpret.d:3825:34: error: undefined identifier 'STCstatic'
		if(meaning.stc & STCstatic){
                                 ^~~~~~~~~
interpret.d:4838:64: error: undefined identifier 'adapted'
					numargs += getBCSizeof(adapted[i].type);
                                                               ^~~~~~~
interpret.d:4840:41: error: no member 'byteCompile' for type 'Expression[]'
					x.byteCompile(bld);
                                        ^~~~~~~~~~~~~
interpret.d:4841:64: error: no member 'type' for type 'Expression[]'
					numargs += getBCSizeof(x.type);
                                                               ^~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(StaticIfDecl)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
declaration.d:159:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(UFCSCallExp)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
semantic.d:4719:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
semantic.d:5694:26: error: cannot cast expression 'sc.getModule()' of type 'Module' to 'bool'
		assert(!!sc.getModule());
                         ^~~~~~~~~~~~~~
semantic.d:5695:21: error: cannot cast expression 'mscope' of type 'Scope' to 'bool'
		if(!mscope) mscope = sc.getModule().sc;
                    ^~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5704:26: error: cannot cast expression 'sc.getModule' of type 'Module' to 'bool'
		assert(!!sc.getModule);
                         ^~~~~~~~~~~~
expression.d:256:18: error: undefined identifier 'string'
	override string toString(){return !meaning?_brk("."~name):"."~super.toString();}
                 ^~~~~~
expression.d:255:14: error: undefined identifier 'string'
	this(string name){ super(name, null); }
             ^~~~~~
semantic.d:5702:14: error: undefined identifier 'string'
	this(string name){super(name);}
             ^~~~~~
semantic.d:5705:21: error: cannot cast expression 'mscope' of type 'Scope' to 'bool'
		if(!mscope) mscope = sc.getModule().sc;
                    ^~~~~~
semantic.d:5706:21: error: cannot cast expression 'meaning' of type 'Declaration' to 'bool'
		if(!meaning){
                    ^~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
<mixin@semantic.d:5707>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:5707>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:5707>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:5709:31: error: undefined identifier 'Lookup'
			mixin(Lookup!q{_;this,sc,mscope});
                              ^~~~~~
<mixin@<mixin@semantic.d:5710>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:5710>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:17:78: error: no matching template for instantiation 'Interpret!(SuperExp)'
	static if(is(typeof(this):Expression)&&!is(typeof(this):Type)) mixin Interpret!(typeof(this));// TODO: minimize and report bug
                                                                             ^~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:37:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==MixinExp) || is(T==IsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:42:1: note: candidate template not viable
mixin template Interpret(T) if(is(T:Expression) && NotYetImplemented!T || is(T==ThisExp)||is(T==SuperExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:50:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:138:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:165:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:168:2: note: candidate template not viable
}mixin template Interpret(T) if(!is(T==Type) && is(T:Type)){}
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:170:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:191:2: note: candidate template not viable
}mixin template Interpret(T) if(is(T==Identifier)||is(T==ModuleIdentifier)){}
 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:193:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:213:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==BinaryExp!(Tok!"."))){ } // (workaround for DMD bug)
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:215:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==LengthExp)||is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:229:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:256:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:322:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:346:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==IndexExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:391:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:438:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:466:1: note: candidate template not viable
mixin template Interpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:489:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:494:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:495:1: note: candidate template not viable
mixin template Interpret(T) if(is(T _==BinaryExp!S, TokenType S) && !is(T==BinaryExp!(Tok!"."))){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:569:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:582:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==TemporaryExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:585:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==StructConsExp)||is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:597:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:613:1: note: candidate template not viable
mixin template Interpret(T) if(is(T==UFCSCallExp)){ }
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
expression.d:269:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
expression.d:262:18: error: undefined identifier 'string'
	override string toString(){ return "this"; }
                 ^~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
semantic.d:4931:20: error: declaration of 'fun' smells suspicously fishy
	Expression fun;
                   ^~~
interpret.d:4826:17: note: this lookup should have succeeded if it was valid
		fun.byteCompile(bld);
                ^~~
semantic.d:4932:22: error: declaration of 'adapted' smells suspicously fishy
	Expression[] adapted;
                     ^~~~~~~
interpret.d:4838:64: note: this lookup should have succeeded if it was valid
					numargs += getBCSizeof(adapted[i].type);
                                                               ^~~~~~~
interpret.d:4873:33: error: no member 'byteCompile' for type 'VarDecl[]'
				x.byteCompile(bld);
                                ^~~~~~~~~~~~~
<mixin@semantic.d:5518>:65:24: error: no member 'isFunctionDecl' for type 'Declaration'
		assert(constructor.meaning.isFunctionDecl()&&
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:5518>:66:24: error: no member 'isFunctionDecl' for type 'Declaration'
		       constructor.meaning.isFunctionDecl().isConstructor());
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:5522>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:5522>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
expression.d:392:28: error: undefined identifier 'string'
	override @property string kind(){return "function call result";} // TODO: 'struct literal', 'property'
                           ^~~~~~
expression.d:390:18: error: undefined identifier 'string'
	override string toString(){return _brk(e.toString()~(args.length?'('~join(map!(to!string)(args),",")~')':"()"));}
                 ^~~~~~
semantic.d:4810:28: error: no member 'isType' for type 'Expression'
		if(auto ty=e.isType())
                           ^~~~~~~~
interpret.d:4879:39: error: cannot cast expression 'call.type' of type 'Type' to 'TypeTuple'
		assert(cast(TypeTuple)call.type);
                                      ^~~~~~~~~
interpret.d:4880:53: error: cannot cast expression 'call.type' of type 'Type' to 'void*'
		auto tt = cast(TypeTuple)cast(void*)call.type;
                                                    ^~~~~~~~~
semantic.d:4929:90: error: undefined identifier 'STCref'
	override bool isLvalue(){ return !!(e.type.getHeadUnqual().getFunctionTy().stc & STCref); }
                                                                                         ^~~~~~
interpret.d:4851:65: error: undefined identifier 'STCref'
		if(fun.type.getHeadUnqual().getFunctionTy().stc&STCref) LVpointer(type, this).emitLoad(bld);
                                                                ^~~~~~
interpret.d:4854:67: error: undefined identifier 'STCref'
		if(!(fun.type.getHeadUnqual().getFunctionTy().stc&STCref)) return super.byteCompileLV(bld);
                                                                  ^~~~~~
semantic.d:5525:32: error: no member 'getPointer' for type 'Type'
			type = type.getPointer();
                               ^~~~~~~~~~~~~~~
semantic.d:4816:28: error: cannot cast expression 'tmpVarDecl' of type 'VarDecl' to 'bool'
			if(tmpVarDecl) r.initOfVar(tmpVarDecl);
                           ^~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
interpret.d:606:32: error: undefined identifier 'ctfeCallWrapper'
		callWrapper(sc,ctfeCallWrapper,e);
                               ^~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
<mixin@<mixin@semantic.d:5527>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:5527>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:4825>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:4825>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:4825>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:4833:27: error: no member 'isUFCSCallExp' for type 'Expression'
		if(auto r=e.isUFCSCallExp()){
                          ^~~~~~~~~~~~~~~
<mixin@semantic.d:4842>:1:29: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
 constructorRewrite(sc); if(rewrite) return; 
                            ^~~~~~~
semantic.d:4845:31: error: undefined identifier 'MatchCall'
			mixin(MatchCall!q{fun; e, sc, loc, args});
                              ^~~~~~~~~
<mixin@<mixin@semantic.d:4847>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:4847>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:4852>:1:29: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
 constructorRewrite(sc); if(rewrite) return; 
                            ^~~~~~~
semantic.d:4855:24: error: cannot cast expression 'fun' of type 'Expression' to 'bool'
		assert(fun && fun.type);
                       ^~~
semantic.d:4855:31: error: cannot cast expression 'fun.type' of type 'Type' to 'bool'
		assert(fun && fun.type);
                              ^~~~~~~~
semantic.d:4857:21: error: cannot cast expression 'tt' of type 'FunctionTy' to 'bool'
		if(!tt){
                    ^~
semantic.d:4860:31: error: undefined identifier 'MatchCall'
			mixin(MatchCall!q{fun; fun, sc, loc, args});
                              ^~~~~~~~~
<mixin@<mixin@semantic.d:4862>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:4862>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:4867:28: error: no member 'stc' for type 'Parameter[]'
			if(x.stc & STClazy){
                           ^~~~~
semantic.d:4867:36: error: undefined identifier 'STClazy'
			if(x.stc & STClazy){
                                   ^~~~~~~
semantic.d:4869:41: error: cannot cast expression 'adapted[i]' of type 'Expression' to 'bool'
				else if(adapted[i]) continue;
                                        ^~~~~~~~~~
semantic.d:4870:58: error: no member 'init' for type 'long'
				auto ft = New!FunctionTy(STC.init, args[i].type,cast(Parameter[])[],VarArgs.none);
                                                         ^~~~~~~~
analyze.d:44:19: error: feature expression.TraitsExp not implemented
	static if(__traits(hasMember,T,"manualPropagate") && T.manualPropagate)
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:48:26: error: feature expression.TraitsExp not implemented
	alias TypeTuple!(__traits(getOverloads,T,"perform")) overloads;
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:52:28: error: undefined identifier 'manualPropagate'
		static if(!manualPropagate) node._doAnalyze(&runIt);
                           ^~~~~~~~~~~~~~~
analyze.d:61:20: error: undefined identifier 'manualPropagate'
	static if(!manualPropagate) return result;
                   ^~~~~~~~~~~~~~~
semantic.d:4883:33: note: instantiated here
				runAnalysis!Reset(args[i]);
                                ^~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:4895>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:4895>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:4898:36: error: no member 'type' for type 'Parameter[]'
			auto pty = x.type;
                                   ^~~~~~
semantic.d:4908:32: error: no member 'isAggregateTy' for type 'Type'
		if(auto aggrty=type.getHeadUnqual().isAggregateTy())
                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:4911:46: error: no member 'init' for type 'long'
			analyzeTemporary(sc, STC.init);
                                             ^~~~~~~~
semantic.d:4914:20: error: no member 'isTypeTuple' for type 'Type'
		if(type.getHeadUnqual().isTypeTuple()){
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:4926>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:4926>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4881:17: error: undefined identifier 'size_t'
		size_t size=0, i=0;
                ^~~~~~
interpret.d:4881:17: error: undefined identifier 'size_t'
		size_t size=0, i=0;
                ^~~~~~
interpret.d:4892:17: error: undefined identifier 'size_t'
		size_t off = 0;
                ^~~~~~
semantic.d:5385:18: error: undefined identifier 'string'
	override string toString(){ return strd.name.toString()~"("~join(map!(to!string)(args),",")~")"; }
                 ^~~~~~
declaration.d:329:18: error: undefined identifier 'string'
	override string toString(){return (stc?STCtoString(astStc)~" ":"")~"interface"~(name?" "~name.toString():"")~
                 ^~~~~~
semantic.d:5372:26: error: cannot cast expression 'type' of type 'Type' to 'bool'
		assert(!!type);
                         ^~~~
semantic.d:5384:28: error: undefined identifier 'string'
	override @property string kind(){ return "struct literal"; }
                           ^~~~~~
declaration.d:332:28: error: undefined identifier 'string'
	override @property string kind(){ return "interface"; }
                           ^~~~~~
interpret.d:4894:33: error: no member 'byteCompileInitLV' for type 'VarDecl[]'
			auto lv=x.byteCompileInitLV(bld, this, call.tmpVarDecl.scope_);
                                ^~~~~~~~~~~~~~~~~~~
semantic.d:5363:80: error: cannot cast expression 'type.getUnqual()' of type 'Type' to 'void*'
		return cast(StructDecl)cast(void*)(cast(AggregateTy)cast(void*)type.getUnqual()).decl;
                                                                               ^~~~~~~~~~~~~~~~
semantic.d:5361:46: error: cannot cast expression '(cast()type).getUnqual()' of type 'Type' to 'AggregateTy'
	invariant(){ assert(cast(AggregateTy)(cast()type).getUnqual()&&cast(StructDecl)(cast(AggregateTy)(cast()type).getUnqual()).decl);}
                                             ^~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5361:106: error: cannot cast expression '(cast()type).getUnqual()' of type 'Type' to 'AggregateTy'
	invariant(){ assert(cast(AggregateTy)(cast()type).getUnqual()&&cast(StructDecl)(cast(AggregateTy)(cast()type).getUnqual()).decl);}
                                                                                                         ^~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4895:25: error: undefined identifier 'size_t'
			size_t len; x.getBCLoc(len);
                        ^~~~~~
declaration.d:327:17: error: current object 'super' of type 'ReferenceAggregateDecl' is not callable
		super(stc,name,p,b);
                ^~~~~~~~~~~~~~~~~~~
interpret.d:4219:21: error: function call result 'this.strd()' of type 'StructDecl' is not callable
		if(!strd.isLayoutKnown()) strd.updateLayout();
                    ^~~~
interpret.d:4895:37: error: no member 'getBCLoc' for type 'VarDecl[]'
			size_t len; x.getBCLoc(len);
                                    ^~~~~~~~~~
interpret.d:4219:43: error: function call result 'this.strd()' of type 'StructDecl' is not callable
		if(!strd.isLayoutKnown()) strd.updateLayout();
                                          ^~~~
interpret.d:4220:17: error: function call result 'this.strd()' of type 'StructDecl' is not callable
		strd.byteCompileInit(bld, contextIsNull ? null : tmpVarDecl.scope_);
                ^~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:2609:18: error: undefined identifier 'size_t'
	override size_t tmplArgToHash(){ return exp.tmplArgToHash(); }
                 ^~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
semantic.d:9664:74: error: undefined identifier 'SupertypeStack'
	final Dependent!ClassDecl commonSuperTypeImpl(ClassDecl rhs, ref SupertypeStack s1, ref SupertypeStack s2){
                                                                         ^~~~~~~~~~~~~~
semantic.d:9664:97: error: undefined identifier 'SupertypeStack'
	final Dependent!ClassDecl commonSuperTypeImpl(ClassDecl rhs, ref SupertypeStack s1, ref SupertypeStack s2){
                                                                                                ^~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
declaration.d:320:28: error: undefined identifier 'string'
	override @property string kind(){ return "class"; }
                           ^~~~~~
declaration.d:317:18: error: undefined identifier 'string'
	override string toString(){return (stc?STCtoString(astStc)~" ":"")~"class"~(name?" "~name.toString():"")~
                 ^~~~~~
declaration.d:315:17: error: current object 'super' of type 'ReferenceAggregateDecl' is not callable
		super(stc,name,p,b);
                ^~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
<mixin@semantic.d:5373>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:5373>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:5373>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:5376>:5:28: error: function call result 'this.strd()' of type 'StructDecl' is not callable
	}else auto caggr = strd;
                           ^~~~
<mixin@semantic.d:5376>:8:15: error: undefined identifier 'IsDeclAccessible'
	mixin(IsDeclAccessible!q{bool b; Declaration, sc.getDeclaration, caggr});
              ^~~~~~~~~~~~~~~~
<mixin@semantic.d:5376>:10:13: error: undefined identifier 'b'
	if(!b){
            ^
<mixin@semantic.d:5376>:29:21: error: cannot cast expression 'constructor' of type 'Identifier' to 'bool'
		if(!constructor){
                    ^~~~~~~~~~~
<mixin@semantic.d:5376>:34:21: error: cannot cast expression 'constructor.meaning' of type 'Declaration' to 'bool'
		if(!constructor.meaning){
                    ^~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:5376>:35:31: error: undefined identifier 'Lookup'
			mixin(Lookup!q{_; constructor, sc, caggr.asc});
                              ^~~~~~
<mixin@semantic.d:5376>:39:13: error: cannot cast expression 'constructor' of type 'Identifier' to 'bool'
	if(!constructor||constructor.sstate == SemState.failed){
            ^~~~~~~~~~~
<mixin@<mixin@<mixin@semantic.d:5376>:45>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@<mixin@semantic.d:5376>:45>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:5376>:52:23: error: undefined identifier 'MatchCallHelper'
		mixin(MatchCallHelper!q{auto r; constructor, sc, loc, type, args, context});
                      ^~~~~~~~~~~~~~~
<mixin@semantic.d:5376>:54:21: error: undefined identifier 'r'
		if(!r){
                    ^
<mixin@<mixin@<mixin@semantic.d:5376>:57>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@<mixin@semantic.d:5376>:57>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:5376>:59:21: error: cannot cast expression 'consCall' of type 'CallExp' to 'bool'
		if(!consCall){
                    ^~~~~~~~
<mixin@semantic.d:5376>:61:40: error: undefined identifier 'r'
			consCall.fun = r;
                                       ^
<mixin@semantic.d:5376>:65:24: error: no member 'isFunctionDecl' for type 'Declaration'
		assert(constructor.meaning.isFunctionDecl()&&
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:5376>:66:24: error: no member 'isFunctionDecl' for type 'Declaration'
		       constructor.meaning.isFunctionDecl().isConstructor());
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:5379:38: error: no member 'init' for type 'long'
		analyzeTemporary(sc, STC.init);
                                     ^~~~~~~~
<mixin@<mixin@semantic.d:5381>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:5381>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:24:31: error: no matching template for instantiation 'CTFEInterpret!(SuperExp)'
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(!is(T==Node)&&!is(T==FunctionDef)&&!is(T==TemplateDecl)&&!is(T==TemplateInstanceDecl) && !is(T==BlockDecl) && !is(T==PragmaDecl) && !is(T==EmptyStm) && !is(T==CompoundStm) && !is(T==LabeledStm) && !is(T==ExpressionStm) && !is(T==IfStm) && !is(T==ForStm) && !is(T==WhileStm) && !is(T==DoStm) && !is(T==LiteralExp) && !is(T==ArrayLiteralExp) && !is(T==ReturnStm) && !is(T==CastExp) && !is(T==Symbol) && !is(T==FieldExp) && !is(T==ConditionDeclExp) && !is(T==VarDecl) && !is(T==Expression) && !is(T==ExpTuple) && !is(T _==BinaryExp!S,TokenType S) && !is(T==ABinaryExp) && !is(T==AssignExp) && !is(T==TernaryExp)&&!is(T _==UnaryExp!S,TokenType S) && !is(T _==PostfixExp!S,TokenType S) &&!is(T==Declarators) && !is(T==BreakStm) && !is(T==ContinueStm) && !is(T==GotoStm) && !is(T==BreakableStm) && !is(T==LoopingStm) && !is(T==SliceExp) && !is(T==AssertExp) && !is(T==CallExp) && !is(T==Declaration) && !is(T==PtrExp)&&!is(T==LengthExp)&&!is(T==DollarExp)&&!is(T==AggregateDecl)&&!is(T==ReferenceAggregateDecl)&&!is(T==AggregateTy)&&!is(T==TemporaryExp)&&!is(T==StructConsExp)&&!is(T==NewExp)&&!is(T==CurrentExp)&&!is(T==MultiReturnValueExp)&&!is(T:Type)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2669:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Node)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2675:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declaration)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2682:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Expression)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2749:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2755:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2759:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==UnaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2853:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==PostfixExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2981:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==SliceExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3030:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AssertExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3051:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ABinaryExp)||is(T==AssignExp)){}
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3052:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T _==BinaryExp!S,TokenType S)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3325:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TernaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3369:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CompoundStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3395:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LabeledStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3408:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ExpressionStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3419:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==IfStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3436:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakableStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3452:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LoopingStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3464:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==WhileStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3476:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3486:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ForStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3510:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReturnStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3517:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ContinueStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3523:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BreakStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3529:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==GotoStm)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3536:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3637:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayLiteralExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3666:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CastExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3784:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Symbol)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3819:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DollarExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3836:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FieldExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3946:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PtrExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3958:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==LengthExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3971:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConditionDeclExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:3982:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4107:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ReferenceAggregateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4203:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemporaryExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4212:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==StructConsExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4231:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NewExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4266:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CurrentExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4353:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==VarDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4546:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Declarators)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4552:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionDef)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4806:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==CallExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4860:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==MultiReturnValueExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4909:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4915:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TemplateInstanceDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4928:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BlockDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4933:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PragmaDecl)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4960:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==Type)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4974:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ErrorTy)||is(T==MatcherTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4978:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ConstTy)||is(T==ImmutableTy)||is(T==SharedTy)||is(T==InoutTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4987:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==NullPtrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5002:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EmptyArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5017:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==BasicType)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5044:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==FunctionTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5055:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeofExp)||is(T==TypeofReturnExp)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5059:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==PointerTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5167:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DynArrTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5220:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==ArrayTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5232:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==TypeTuple)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5243:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==AggregateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5336:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==EnumTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5350:1: note: candidate template not viable
mixin template CTFEInterpret(T) if(is(T==DelegateTy)){
^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
interpret.d:4683:38: error: need 'this' to access member function 'AggregateDecl.getVersion'
			return vers!=AggregateDecl.getVersion();
                                     ^~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4052:9: note: member function was declared here
	static ulong getVersion(){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4686:32: error: need 'this' to access member function 'AggregateDecl.getVersion'
			vers = AggregateDecl.getVersion();
                               ^~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4052:9: note: member function was declared here
	static ulong getVersion(){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4699:37: error: cannot cast expression 'self.type' of type 'Type' to 'bool'
				if(!self.type) return;
                                    ^~~~~~~~~
interpret.d:4700:48: error: no member 'isAggregateTy' for type 'Type'
				if(auto aggrty=self.type.isAggregateTy())
                                               ^~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4563:37: error: cannot cast expression 'self.meaning' of type 'Declaration' to 'bool'
				if(!self.meaning) return;
                                    ^~~~~~~~~~~~
interpret.d:4564:46: error: no member 'isVarDecl' for type 'Declaration'
				if(auto vd = self.meaning.isVarDecl()){
                                             ^~~~~~~~~~~~~~~~~~~~~~
interpret.d:4694:37: error: cannot cast expression 'self.type' of type 'Type' to 'bool'
				if(!self.type) return;
                                    ^~~~~~~~~
interpret.d:4695:48: error: no member 'isAggregateTy' for type 'Type'
				if(auto aggrty=self.type.isAggregateTy())
                                               ^~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4572:36: error: cannot cast expression 'auto this_=self.e1.extractThis()' of type 'Expression' to 'bool'
				if(auto this_=self.e1.extractThis())
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4573:48: error: no member 'isAggregateTy' for type 'Type'
				if(auto aggrty=this_.type.getHeadUnqual().isAggregateTy())
                                               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:7890:18: error: undefined identifier 'string'
	override string toString(){
                 ^~~~~~
interpret.d:4590:36: error: no member 'isArrayTy' for type 'Type'
				if(self.type.isArrayTy())
                                   ^~~~~~~~~~~~~~~~~~~
semantic.d:7876:21: error: cannot cast expression 'decl.bdy' of type 'BlockDecl' to 'bool'
		if(!decl.bdy){
                    ^~~~~~~~
semantic.d:7877:28: error: cannot cast expression 'me.name' of type 'Identifier' to 'bool'
			if(me.name)
                           ^~~~~~~
semantic.d:7878:42: error: undefined identifier 'format'
				sc.error(format("%s '%s' has incomplete type '%s'", me.kind, me.name, this), me.loc);
                                         ^~~~~~
semantic.d:7880:42: error: undefined identifier 'format'
				sc.error(format("%s has incomplete type '%s'", me.kind, this), me.loc);
                                         ^~~~~~
<mixin@semantic.d:7871>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:7871>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:7871>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:7872>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:7872>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
interpret.d:5299:25: error: type 'VarDecl' is not an expression
		Variant[VarDecl] res;
                        ^~~~~~~
type.d:340:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
interpret.d:5303:53: error: cannot cast expression 'type' of type 'Type' to 'void*'
			res[cast(VarDecl)cast(void*)type]=Variant(null);
                                                    ^~~~
interpret.d:5255:46: error: no member 'sizeof' for type 'BCPointer'
			assert(res.length == BCPointer.sizeof);
                                             ^~~~~~~~~~~~~~~~
interpret.d:5256:50: error: too many arguments to struct literal (expected zero)
			*cast(BCPointer*)res.ptr=BCPointer(mem,mem.ptr);
                                                 ^~~~~~~~~~~~~~~~~~~~~~
interpret.d:5259:48: error: type 'VarDecl' is not an expression
		auto vars = value.get!(Variant[VarDecl])();
                                               ^~~~~~~
interpret.d:5260:28: error: no member 'isReferenceAggregateDecl' for type 'AggregateDecl'
		if(auto rd=decl.isReferenceAggregateDecl()){
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5303:59: error: no matching function for call to 'this(typeof(null))'
			res[cast(VarDecl)cast(void*)type]=Variant(null);
                                                          ^~~~~~~~~~~~~
interpret.d:5266:63: error: no member 'sizeof' for type 'ulong'
			}else mem = new void[decl.getBCSize()*ulong.sizeof];
                                                              ^~~~~~~~~~~~
interpret.d:5268:34: error: undefined identifier 'q'
			auto tag=q(cast(Type)this,mem.ptr);
                                 ^
interpret.d:5270:39: error: no member 'sizeof' for type 'ReferenceAggregateDecl'
			static assert(ReferenceAggregateDecl.sizeof<=ulong.sizeof);
                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5270:70: error: no member 'sizeof' for type 'ulong'
			static assert(ReferenceAggregateDecl.sizeof<=ulong.sizeof);
                                                                     ^~~~~~~~~~~~
interpret.d:5274:37: error: no member 'sizeof' for type 'ulong'
		assert(!(mem.length%ulong.sizeof));
                                    ^~~~~~~~~~~~
interpret.d:5275:66: error: no member 'sizeof' for type 'ulong'
		assert(!mem.length||mem.length==decl.getBCSize()*ulong.sizeof);
                                                                 ^~~~~~~~~~~~
interpret.d:5277:25: error: initializer required for '' declaration
		foreach(vd;&decl.traverseFields){
                        ^~
interpret.d:5278:25: error: undefined identifier 'size_t'
			size_t len, off = vd.getBCLoc(len);
                        ^~~~~~
interpret.d:5278:25: error: undefined identifier 'size_t'
			size_t len, off = vd.getBCLoc(len);
                        ^~~~~~
interpret.d:5278:43: error: undefined identifier 'vd'
			size_t len, off = vd.getBCLoc(len);
                                          ^~
interpret.d:5279:48: error: undefined identifier 'vd'
			auto ctlen=getCTSizeof(vd.type);
                                               ^~
interpret.d:5281:28: error: undefined identifier 'vd'
			if(vd !in vars && vd.init){
                           ^~
interpret.d:5281:43: error: undefined identifier 'vd'
			if(vd !in vars && vd.init){
                                          ^~
interpret.d:5282:38: error: undefined identifier 'vd'
				vars[vd]=vd.init.interpretV(); // TODO: ok?
                                     ^~
interpret.d:5282:42: error: undefined identifier 'vd'
				vars[vd]=vd.init.interpretV(); // TODO: ok?
                                         ^~
interpret.d:5284:28: error: undefined identifier 'vd'
			if(vd in vars){
                           ^~
interpret.d:5285:49: error: undefined identifier 'vd'
				auto var = vars[vd];
                                                ^~
interpret.d:5286:52: error: undefined identifier 'vd'
				assert(getCTSizeof(vd.type)==getCTSizeof(var.getType()));
                                                   ^~
interpret.d:5287:76: error: no member 'sizeof' for type 'ulong'
				var.getType().variantToMemory(var, mem[off*ulong.sizeof..off*ulong.sizeof+ctlen]);
                                                                           ^~~~~~~~~~~~
interpret.d:5287:94: error: no member 'sizeof' for type 'ulong'
				var.getType().variantToMemory(var, mem[off*ulong.sizeof..off*ulong.sizeof+ctlen]);
                                                                                             ^~~~~~~~~~~~
interpret.d:5290:20: error: no member 'isReferenceAggregateDecl' for type 'AggregateDecl'
		if(decl.isReferenceAggregateDecl()){
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5304:60: error: cannot cast expression 'type' of type 'Type' to 'void*'
			res.remove(cast(VarDecl)cast(void*)type);
                                                           ^~~~
interpret.d:5306:20: error: no member 'isReferenceAggregateDecl' for type 'AggregateDecl'
		if(decl.isReferenceAggregateDecl()){
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5310:69: error: type 'VarDecl' is not an expression
			if(ptr.ptr is null) return Variant((Variant[VarDecl]).init, type);
                                                                    ^~~~~~~
interpret.d:5314:34: error: undefined identifier 'q'
			auto tag=q(cast(Type)decl.getType(),mem.ptr);
                                 ^
semantic.d:6195:21: error: cannot cast expression 'meaning' of type 'Declaration' to 'bool'
		if(!meaning) meaning=sc.getDollar();
                    ^~~~~~~
semantic.d:6196:21: error: cannot cast expression 'meaning' of type 'Declaration' to 'bool'
		if(!meaning){
                    ^~~~~~~
interpret.d:5319:20: error: no member 'isReferenceAggregateDecl' for type 'AggregateDecl'
		if(decl.isReferenceAggregateDecl){
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:5320:34: error: undefined identifier 'q'
			auto tag=q(cast(Type)decl.getType(),mem.ptr);
                                 ^
semantic.d:6220:28: error: undefined identifier 'string'
	override @property string kind(){ return "array length"; }
                           ^~~~~~
semantic.d:6221:18: error: undefined identifier 'string'
	override string toString(){ return "$"; }
                 ^~~~~~
interpret.d:5325:25: error: initializer required for '' declaration
		foreach(vd;&decl.traverseFields){
                        ^~
interpret.d:5326:25: error: undefined identifier 'size_t'
			size_t len, off = vd.getBCLoc(len);
                        ^~~~~~
interpret.d:5326:25: error: undefined identifier 'size_t'
			size_t len, off = vd.getBCLoc(len);
                        ^~~~~~
interpret.d:5326:43: error: undefined identifier 'vd'
			size_t len, off = vd.getBCLoc(len);
                                          ^~
interpret.d:5327:48: error: undefined identifier 'vd'
			auto ctlen=getCTSizeof(vd.type);
                                               ^~
interpret.d:5329:33: error: undefined identifier 'vd'
			auto tt=vd.type.applySTC(type.getHeadSTC());
                                ^~
interpret.d:5330:29: error: undefined identifier 'vd'
			res[vd]=tt.variantFromMemory(mem[off*ulong.sizeof..off*ulong.sizeof+ctlen], tt);
                            ^~
interpret.d:5330:62: error: no member 'sizeof' for type 'ulong'
			res[vd]=tt.variantFromMemory(mem[off*ulong.sizeof..off*ulong.sizeof+ctlen], tt);
                                                             ^~~~~~~~~~~~
interpret.d:5330:80: error: no member 'sizeof' for type 'ulong'
			res[vd]=tt.variantFromMemory(mem[off*ulong.sizeof..off*ulong.sizeof+ctlen], tt);
                                                                               ^~~~~~~~~~~~
<mixin@<mixin@semantic.d:6198>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:6198>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
expression.d:281:28: error: undefined identifier 'string'
	override @property string kind(){return "array length";}
                           ^~~~~~
semantic.d:6224:25: error: declaration of 'dollar' smells suspicously fishy
		VarDecl dollar;
                        ^~~~~~
<mixin@interpret.d:2987>:10:30: note: this lookup should have succeeded if it was valid
		auto strat = dollar.byteCompileSymbolLV(bld,this,ascope);
                             ^~~~~~
semantic.d:6228:29: error: cannot cast expression 'dollar' of type 'VarDecl' to 'bool'
			if(!dollar){
                            ^~~~~~
semantic.d:6228:29: error: cannot cast expression 'dollar' of type 'VarDecl' to 'bool'
			if(!dollar){
                            ^~~~~~
semantic.d:1411:28: error: undefined identifier 'string'
	override @property string kind(){ return e.kind; }
                           ^~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
analyze.d:44:19: error: feature expression.TraitsExp not implemented
	static if(__traits(hasMember,T,"manualPropagate") && T.manualPropagate)
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:47:23: error: too many arguments to struct literal (expected zero)
	auto result = T(args);
                      ^~~~~~~
analyze.d:48:26: error: feature expression.TraitsExp not implemented
	alias TypeTuple!(__traits(getOverloads,T,"perform")) overloads;
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:52:28: error: undefined identifier 'manualPropagate'
		static if(!manualPropagate) node._doAnalyze(&runIt);
                           ^~~~~~~~~~~~~~~
analyze.d:61:20: error: undefined identifier 'manualPropagate'
	static if(!manualPropagate) return result;
                   ^~~~~~~~~~~~~~~
interpret.d:251:30: note: instantiated here
		foreach(x;e) runAnalysis!DollarResolve(x, value);
                             ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:6229:44: error: no member 'init' for type 'long'
				auto stc = STC.init;
                                           ^~~~~~~~
semantic.d:527:25: error: unimplemented feature SwitchStm
			final switch(inContext) with(InContext){
                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:6231:44: error: no member 'isTuple' for type 'Expression'
				if(auto tp=e.isTuple()){
                                           ^~~~~~~~~
semantic.d:1401:28: error: no member 'isTuple' for type 'Expression'
		if(auto tp=e.isTuple()) return cast(TypeTuple)cast(void*)sliceTuple(sc, tp);
                           ^~~~~~~~~
semantic.d:1220:36: error: undefined identifier 'to'
		assert(a.length==1,to!string(this));
                                   ^~
semantic.d:1215:36: error: undefined identifier 'to'
		assert(a.length==1,to!string(this));
                                   ^~
semantic.d:1285:28: error: undefined identifier 'string'
	override @property string kind(){ return e.kind; }
                           ^~~~~~
semantic.d:6229:44: error: no member 'init' for type 'long'
				auto stc = STC.init;
                                           ^~~~~~~~
interpret.d:407:25: error: need 'this' to access member function 'DollarExp.resolveValue'
			DollarExp.resolveValue(e[], len);
                        ^~~~~~~~~~~~~~~~~~~~~~
interpret.d:234:9: note: member function was declared here
	static void resolveValue(Expression[] e, ulong value){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:6231:44: error: no member 'isTuple' for type 'Expression'
				if(auto tp=e.isTuple()){
                                           ^~~~~~~~~
semantic.d:6232:48: error: undefined identifier 'STCenum'
					stc |= STCenum;
                                               ^~~~~~~
semantic.d:1228:27: error: no member 'isTuple' for type 'Expression'
		auto tp = e.isTuple();
                          ^~~~~~~~~
semantic.d:6233:48: error: need 'this' to access member function 'LiteralExp.factory'
					init = LiteralExp.factory(Variant(tp.length, Type.get!Size_t()));
                                               ^~~~~~~~~~~~~~~~~~
semantic.d:879:9: note: member function was declared here
	static Expression factory(Variant value)in{
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
semantic.d:6232:48: error: undefined identifier 'STCenum'
					stc |= STCenum;
                                               ^~~~~~~
semantic.d:6237:37: error: cannot cast expression 'ascope.getDeclaration()' of type 'Declaration' to 'bool'
				if(!ascope.getDeclaration()) stc |= STCstatic;
                                    ^~~~~~~~~~~~~~~~~~~~~~~
semantic.d:6233:48: error: need 'this' to access member function 'LiteralExp.factory'
					init = LiteralExp.factory(Variant(tp.length, Type.get!Size_t()));
                                               ^~~~~~~~~~~~~~~~~~
semantic.d:879:9: note: member function was declared here
	static Expression factory(Variant value)in{
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:521:81: error: undefined identifier 'text'
			assert(this.inContext.among(InContext.none, inContext), text(this," ",this.inContext," ",inContext));
                                                                                ^~~~
semantic.d:1109:15: note: instantiated here
	mixin ContextSensitive;
              ^~~~~~~~~~~~~~~~
semantic.d:1401:74: error: undefined identifier 'sliceTuple'
		if(auto tp=e.isTuple()) return cast(TypeTuple)cast(void*)sliceTuple(sc, tp);
                                                                         ^~~~~~~~~~
<mixin@semantic.d:1313>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
semantic.d:6237:37: error: cannot cast expression 'ascope.getDeclaration()' of type 'Declaration' to 'bool'
				if(!ascope.getDeclaration()) stc |= STCstatic;
                                    ^~~~~~~~~~~~~~~~~~~~~~~
interpret.d:421:26: error: could not match call to function template
		auto a = l.interpretV().get!ulong();
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:422:26: error: could not match call to function template
		auto b = r.interpretV().get!ulong();
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:6237:69: error: undefined identifier 'STCstatic'
				if(!ascope.getDeclaration()) stc |= STCstatic;
                                                                    ^~~~~~~~~
<mixin@<mixin@semantic.d:1313>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:425:34: error: undefined identifier 'format'
			sc.error(format("slice indices [%s..%s] are out of bounds [0%s..%d%s]",
                                 ^~~~~~
<mixin@semantic.d:1114>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
semantic.d:6239:42: error: need 'this' to access member function 'DollarExp.createDecl'
				dollar = DollarExp.createDecl(ascope, stc, init);
                                         ^~~~~~~~~~~~~~~~~~~~
semantic.d:6204:9: note: member function was declared here
	static VarDecl createDecl(Scope ascope, STC stc, Expression init)in{
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:6237:69: error: undefined identifier 'STCstatic'
				if(!ascope.getDeclaration()) stc |= STCstatic;
                                                                    ^~~~~~~~~
semantic.d:1108:15: note: instantiated here
	mixin DollarExp.DollarProviderImpl!e;
              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
expression.d:371:18: error: undefined identifier 'string'
	override string toString(){return _brk(e.toString()~(a.length?'['~join(map!(to!string)(a),",")~']':"[]"));}
                 ^~~~~~
semantic.d:6239:42: error: need 'this' to access member function 'DollarExp.createDecl'
				dollar = DollarExp.createDecl(ascope, stc, init);
                                         ^~~~~~~~~~~~~~~~~~~~
semantic.d:6204:9: note: member function was declared here
	static VarDecl createDecl(Scope ascope, STC stc, Expression init)in{
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:1309:15: note: instantiated here
	mixin DollarExp.DollarProviderImpl!e;
              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:1313>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:1114>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:1114>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:1238>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
interpret.d:2951:20: error: no member 'isArrayTy' for type 'Type'
		if(e.type.getHeadUnqual().isArrayTy()){ // static arrays
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2905:20: error: no member 'isArrayTy' for type 'Type'
		if(e.type.getHeadUnqual().isArrayTy()){ // static arrays
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:367:28: error: cannot cast expression 'ascope.dollar' of type 'VarDecl' to 'bool'
			if(ascope.dollar){
                           ^~~~~~~~~~~~~
interpret.d:370:33: error: need 'this' to access member function 'DollarExp.resolveValue'
				DollarExp.resolveValue(a, len);
                                ^~~~~~~~~~~~~~~~~~~~~~
interpret.d:234:9: note: member function was declared here
	static void resolveValue(Expression[] e, ulong value){
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:1320:21: error: cannot cast expression 'ascope' of type 'DollarScope' to 'bool'
		if(!ascope) ascope = New!DollarScope(sc_, this);
                    ^~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
interpret.d:381:28: error: could not match call to function template
			if(a[0].interpretV().get!ulong()>=len){
                           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
semantic.d:1323:30: error: no member 'isTuple' for type 'Expression'
		if(auto tp = e.isTuple()){
                             ^~~~~~~~~
semantic.d:1324:32: error: undefined identifier 'sliceTuple'
			auto r=sliceTuple(sc_,tp);
                               ^~~~~~~~~~
semantic.d:1117:21: error: cannot cast expression 'ascope' of type 'DollarScope' to 'bool'
		if(!ascope) ascope = New!DollarScope(sc_, this);
                    ^~~~~~
semantic.d:1240:41: error: no member 'getDynArr' for type 'Type'
			else   { return ty.getDynArr(); }
                                        ^~~~~~~~~~~~
semantic.d:1245:29: error: cannot cast expression 'ascope' of type 'DollarScope' to 'bool'
			if(!ascope) ascope = New!DollarScope(sc_,this);
                            ^~~~~~
semantic.d:1120:20: error: no member 'isType' for type 'Expression'
		if(e.isType()){
                   ^~~~~~~~
semantic.d:1249:30: error: no member 'prepareInterpret' for type 'Expression[]'
		foreach(x;a) x.prepareInterpret();
                             ^~~~~~~~~~~~~~~~~~
interpret.d:382:42: error: undefined identifier 'format'
				sc.error(format("array index %s is out of bounds [0%s..%d%s)",
                                         ^~~~~~
<mixin@interpret.d:2919>:2:12: error: cannot cast expression 'dollar' of type 'VarDecl' to 'bool'
	if(dollar){
           ^~~~~~
semantic.d:1253:41: error: undefined identifier 'format'
			if(tp) sc.error(format("can only use one index to index '%s'",e.type),a[0].loc.to(a[$-1].loc));
                                        ^~~~~~
interpret.d:2957:32: error: type 'LVstorea' is not callable
			return LVstorea(type, this);
                               ^~~~~~~~~~~~~~~~~~~~
semantic.d:1123:34: error: cannot cast expression 'r' of type 'Type' to 'bool'
			assert(!!r);
                                 ^
<mixin@interpret.d:2960>:2:12: error: cannot cast expression 'dollar' of type 'VarDecl' to 'bool'
	if(dollar){
           ^~~~~~
<mixin@<mixin@interpret.d:428>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@interpret.d:428>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@interpret.d:432>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@interpret.d:432>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:1255>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:1255>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2964:27: error: undefined identifier 'size_t'
		static if(size_t.sizeof>uint.sizeof){
                          ^~~~~~
interpret.d:2922:27: error: undefined identifier 'size_t'
		static if(size_t.sizeof>uint.sizeof){
                          ^~~~~~
interpret.d:2964:41: error: no member 'sizeof' for type 'uint'
		static if(size_t.sizeof>uint.sizeof){
                                        ^~~~~~~~~~~
interpret.d:2922:41: error: no member 'sizeof' for type 'uint'
		static if(size_t.sizeof>uint.sizeof){
                                        ^~~~~~~~~~~
semantic.d:1125:34: error: no member 'isExpTuple' for type 'Expression'
		}else if(auto et=e.isExpTuple()){
                                 ^~~~~~~~~~~~
interpret.d:2972:20: error: no member 'isPointerTy' for type 'Type'
		if(e.type.getHeadUnqual().isPointerTy()){
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2930:20: error: no member 'isPointerTy' for type 'Type'
		if(e.type.getHeadUnqual().isPointerTy()){
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2938:20: error: no member 'isDynArrTy' for type 'Type'
		if(type.getHeadUnqual().isDynArrTy()){
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
expression.d:376:15: note: instantiated here
	mixin CTFEInterpretIE!IndexExp;
              ^~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:1132:42: error: undefined identifier 'format'
				sc.error(format("can only use one index to index '%s'",e.type),a[1].loc.to(a[$-1].loc));
                                         ^~~~~~
<mixin@<mixin@semantic.d:1133>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:1133>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@interpret.d:384>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@interpret.d:384>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:2977:24: error: type 'LVstorea' is not callable
		return LVstorea(type, this);
                       ^~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:1266>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
semantic.d:1268:27: error: could not match call to function template
		ulong n = a[0].interpretV().get!ulong();
                          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:1271:42: error: undefined identifier 'format'
				sc.error(format("tuple index %s is out of bounds [0%s..%d%s)",a[0].toString(),Size_t.suffix,tp.length,Size_t.suffix),a[0].loc);
                                         ^~~~~~
semantic.d:1140:34: error: could not match call to function template
			auto n = a[0].interpretV().get!ulong();
                                 ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:1142:42: error: undefined identifier 'format'
				sc.error(format("tuple index %s is out of bounds [0%s..%d%s)",a[0].toString(),Size_t.suffix,et.length,Size_t.suffix),a[0].loc);
                                         ^~~~~~
<mixin@<mixin@semantic.d:1143>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:1143>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:1272>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:1272>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:1277:26: error: cannot cast expression 'ty' of type 'Type' to 'bool'
		assert(!!ty);
                         ^~
semantic.d:1336:37: error: no member 'isDynArrTy' for type 'Type'
			if(auto dyn=ty.isDynArrTy()){
                                    ^~~~~~~~~~~~~
semantic.d:1338:43: error: no member 'isArrayTy' for type 'Type'
			}else if(auto arr=ty.isArrayTy()){
                                          ^~~~~~~~~~~~
semantic.d:1341:43: error: no member 'isPointerTy' for type 'Type'
			}else if(auto ptr=ty.isPointerTy()){
                                          ^~~~~~~~~~~~~~
semantic.d:1152:37: error: no member 'isDynArrTy' for type 'Type'
			if(auto dyn=ty.isDynArrTy()){
                                    ^~~~~~~~~~~~~
semantic.d:1154:43: error: no member 'isArrayTy' for type 'Type'
			}else if(auto arr=ty.isArrayTy()){
                                          ^~~~~~~~~~~~
semantic.d:1157:43: error: no member 'isPointerTy' for type 'Type'
			}else if(auto ptr=ty.isPointerTy()){
                                          ^~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:1160>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:1160>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:1168:42: error: undefined identifier 'format'
				sc.error(format("'%s' is not indexable", e.type),loc);
                                         ^~~~~~
<mixin@<mixin@semantic.d:1169>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:1169>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:1171:46: error: no member 'getDynArr' for type 'Type'
			if(!a.length) type = type.getDynArr();
                                             ^~~~~~~~~~~~~~
semantic.d:1174:50: error: undefined identifier 'format'
					sc.error(format("can only use one index to index '%s'",e.type),a[0].loc.to(a[$-1].loc));
                                                 ^~~~~~
<mixin@<mixin@semantic.d:1175>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:1175>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:1349:42: error: undefined identifier 'format'
				sc.error(format("'%s' is not sliceable",e.type),loc);
                                         ^~~~~~
semantic.d:1182:46: error: no member 'isArrayLiteralExp' for type 'Expression'
				if(auto le = e.isArrayLiteralExp())
                                             ^~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:1350>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:1350>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:1352:32: error: no member 'getDynArr' for type 'Type'
			type = type.getDynArr();
                               ^~~~~~~~~~~~~~
semantic.d:1199:50: error: undefined identifier 'format'
					sc.error(format("array index %s is out of bounds [0%s..%d%s)",
                                                 ^~~~~~
<mixin@<mixin@semantic.d:1201>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:1201>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:1209>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:1209>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:1362:38: error: no member 'isArrayLiteralExp' for type 'Expression'
			if(auto le = e.isArrayLiteralExp())
                                     ^~~~~~~~~~~~~~~~~~~
semantic.d:1381:42: error: undefined identifier 'format'
				sc.error(format("slice indices [%s..%s] are out of bounds [0%s..%d%s]",l.toString(),r.toString(),Size_t.suffix,length,Size_t.suffix),l.loc.to(r.loc));
                                         ^~~~~~
<mixin@<mixin@semantic.d:1382>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:1382>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:1387>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:1387>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:1395>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:1395>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4556:17: error: undefined identifier 'size_t'
	private size_t bcnumargs=-1;
                ^~~~~~
visitors.d:24:31: note: instantiated here
			mixin CTFEInterpret!(typeof(this));
                              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:18:23: error: feature expression.IsExp not implemented
	static assert(is(TypeTuple==class));
                      ^~~~~~~~~~~~~~~~~~~~
declaration.d:472:15: note: instantiated here
	mixin Visitors;
              ^~~~~~~~
<mixin@semantic.d:8990>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@semantic.d:9019>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
<mixin@<mixin@semantic.d:8990>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:9019>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:8990>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
<mixin@semantic.d:9019>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:8991:17: error: feature not implemented
		scope(exit) if(sstate==SemState.error) potentialRemove(sc, this);
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:9022:21: error: cannot cast expression 'res' of type 'Statement' to 'bool'
		if(!res||res is this) return;
                    ^~~
semantic.d:9023:26: error: cannot cast expression 'res' of type 'Statement' to 'bool'
		assert(!!res);
                         ^~~
semantic.d:9002:20: error: cannot cast expression 'cond.interpretV()' of type 'Variant' to 'bool'
		if(cond.interpretV()){
                   ^~~~~~~~~~~~~~~~~
semantic.d:9003:28: error: undefined identifier 'lazyDup'
			if(lazyDup) { lazyDup = false; bdy = bdy.ddup(); }
                           ^~~~~~~
semantic.d:9003:39: error: undefined identifier 'lazyDup'
			if(lazyDup) { lazyDup = false; bdy = bdy.ddup(); }
                                      ^~~~~~~
semantic.d:9004:35: error: no member 'isDeclaration' for type 'Statement'
			if(auto d=bdy.isDeclaration()) d.pickupSTC(stc);
                                  ^~~~~~~~~~~~~~~~~
semantic.d:9005:40: error: no member 'isDeclaration' for type 'Statement'
			if(auto decl = bdy.isDeclaration()) decl.presemantic(sc);
                                       ^~~~~~~~~~~~~~~~~
semantic.d:9007:26: error: cannot cast expression 'els' of type 'Statement' to 'bool'
		}else if(els){
                         ^~~
semantic.d:9008:28: error: undefined identifier 'lazyDup'
			if(lazyDup) { lazyDup = false; els = els.ddup(); }
                           ^~~~~~~
semantic.d:9008:39: error: undefined identifier 'lazyDup'
			if(lazyDup) { lazyDup = false; els = els.ddup(); }
                                      ^~~~~~~
semantic.d:9009:35: error: no member 'isDeclaration' for type 'Statement'
			if(auto d=els.isDeclaration()) d.pickupSTC(stc);
                                  ^~~~~~~~~~~~~~~~~
semantic.d:9010:40: error: no member 'isDeclaration' for type 'Statement'
			if(auto decl = els.isDeclaration()) decl.presemantic(sc);
                                       ^~~~~~~~~~~~~~~~~
semantic.d:9013:25: error: undefined identifier 'lazyDup'
			lazyDup = false;
                        ^~~~~~~
<mixin@<mixin@semantic.d:9014>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:9014>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
declaration.d:156:18: error: undefined identifier 'string'
	override string toString(){return (stc?STCtoString(astStc)~" ":"")~"static if("~cond.toString()~") "~bdy.toString()~
                 ^~~~~~
declaration.d:155:89: error: current object 'super' of type 'ConditionalDecl' is not callable
	this(STC stc,Expression c,Statement b,Statement e)in{assert(c&&b);}body{cond=c; super(stc,b,e);}
                                                                                        ^~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
semantic.d:4726:17: error: current object 'super' of type 'CallExp' is not callable
		super(exp, [this_]);
                ^~~~~~~~~~~~~~~~~~~
semantic.d:4754:18: error: undefined identifier 'string'
	override string toString(){
                 ^~~~~~
semantic.d:4753:28: error: undefined identifier 'string'
	override @property string kind(){ return "UFCS function call"; }
                           ^~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
<mixin@<mixin@semantic.d:4749>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:4749>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:2599>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
<mixin@<mixin@semantic.d:2599>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@semantic.d:2599>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
expression.d:266:18: error: undefined identifier 'string'
	override string toString(){ return "super"; }
                 ^~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
semantic.d:8483:25: error: undefined identifier 'ndecls'
			ndecls~=def;
                        ^~~~~~
semantic.d:8480:25: error: undefined identifier 'ndecls'
			ndecls~=decl;
                        ^~~~~~
semantic.d:10987:15: note: instantiated here
	mixin HandleNestedDeclarations;
              ^~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:10925:26: error: cannot cast expression 'scope_' of type 'Scope' to 'bool'
		assert(!!scope_);
                         ^~~~~~
semantic.d:11003:23: error: undefined identifier 'STCstatic'
		stc&=~STCstatic;
                      ^~~~~~~~~
<mixin@semantic.d:10948>:2:68: error: cannot cast expression 'rewrite' of type 'Node' to 'bool'
	if(sstate == SemState.error||sstate == SemState.completed||rewrite){mixin(SemRet);}
                                                                   ^~~~~~~
semantic.d:10927:21: error: undefined identifier 'fsc'
		if(!fsc){
                    ^~~
semantic.d:10928:25: error: undefined identifier 'fsc'
			fsc = New!FunctionScope(scope_, this);
                        ^~~
<mixin@<mixin@semantic.d:10948>:2>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:10930:36: error: no member 'sstate' for type 'Parameter[]'
				if(p.sstate == SemState.pre) p.sstate = SemState.begin;
                                   ^~~~~~~~
semantic.d:10930:62: error: no member 'sstate' for type 'Parameter[]'
				if(p.sstate == SemState.pre) p.sstate = SemState.begin;
                                                             ^~~~~~~~
semantic.d:10931:36: error: no member 'name' for type 'Parameter[]'
				if(p.name) if(!fsc.insert(p)) p.sstate = SemState.error;
                                   ^~~~~~
semantic.d:10931:48: error: undefined identifier 'fsc'
				if(p.name) if(!fsc.insert(p)) p.sstate = SemState.error;
                                               ^~~
semantic.d:10931:63: error: no member 'sstate' for type 'Parameter[]'
				if(p.name) if(!fsc.insert(p)) p.sstate = SemState.error;
                                                              ^~~~~~~~
semantic.d:10936:25: error: no member 'semantic' for type 'Parameter[]'
			x.semantic(fsc);
                        ^~~~~~~~~~
semantic.d:10936:36: error: undefined identifier 'fsc'
			x.semantic(fsc);
                                   ^~~
semantic.d:10937:33: error: no member 'rewrite' for type 'Parameter[]'
			assert(!x.rewrite);
                                ^~~~~~~~~
semantic.d:10938:36: error: no member 'needRetry' for type 'Parameter[]'
			if(auto nr=x.needRetry){
                                   ^~~~~~~~~~~
<mixin@semantic.d:10948>:12:9: error: type 'Scheduler' is not callable
	Scheduler().add(this,sc);
        ^~~~~~~~~~~
semantic.d:10939:33: error: type 'Scheduler' is not callable
				Scheduler().await(this, x, fsc);
                                ^~~~~~~~~~~
semantic.d:10939:60: error: undefined identifier 'fsc'
				Scheduler().await(this, x, fsc);
                                                           ^~~
semantic.d:10944:36: error: type 'Scheduler' is not callable
		if(type.needRetry) Scheduler().await(this, type, scope_);
                                   ^~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8253:24: error: cannot cast expression 'fun' of type 'FunctionDef' to 'bool'
		assert(fun && fun.type,text(fun," ",fun?fun.type:null," ",sc," ",this));
                       ^~~
semantic.d:8253:31: error: cannot cast expression 'fun.type' of type 'FunctionTy' to 'bool'
		assert(fun && fun.type,text(fun," ",fun?fun.type:null," ",sc," ",this));
                              ^~~~~~~~
interpret.d:4660:27: error: no member 'filter' for type 'Parameter[]'
		foreach(p;type.params.filter!(p=>p.inHeapContext))
                          ^~~~~~~~~~~~~~~~~~
semantic.d:6003:39: error: no member 'isReferenceAggregateDecl' for type 'AggregateDecl'
			if(auto raggr=decl.isReferenceAggregateDecl()){
                                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4668:37: error: cannot cast expression 'vd.scope_' of type 'Scope' to 'bool'
				if(!vd.scope_||vd.scope_.getFunction() !is self) return;
                                    ^~~~~~~~~
semantic.d:738:33: error: undefined identifier 'size_t'
				size_t unres=0;
                                ^~~~~~
semantic.d:740:44: error: no member 'sstate' for type 'Parameter[]'
					if(x.sstate!=SemState.error
                                           ^~~~~~~~
semantic.d:741:40: error: no member 'mustBeTypeDeduced' for type 'Parameter[]'
				    && x.mustBeTypeDeduced())
                                       ^~~~~~~~~~~~~~~~~~~
semantic.d:747:53: error: no member 'mustBeTypeDeduced' for type 'Parameter[]'
						if(!x.mustBeTypeDeduced()) continue;
                                                    ^~~~~~~~~~~~~~~~~~~
semantic.d:748:58: error: undefined identifier 'format'
						sc.error(format("cannot deduce type for function literal parameter%s",
                                                         ^~~~~~
semantic.d:749:65: error: no member 'name' for type 'Parameter[]'
						                x.name?" '"~x.name.name~"'":""),x.loc);
                                                                ^~~~~~
declaration.d:466:18: error: undefined identifier 'string'
	override string toString(){
                 ^~~~~~
semantic.d:749:97: error: no member 'loc' for type 'Parameter[]'
						                x.name?" '"~x.name.name~"'":""),x.loc);
                                                                                                ^~~~~
declaration.d:463:17: error: current object 'super' of type 'FunctionDecl' is not callable
		super(stc, type, name, precondition, postcondition, pres); bdy=fbody;
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8253:40: error: undefined identifier 'text'
		assert(fun && fun.type,text(fun," ",fun?fun.type:null," ",sc," ",this));
                                       ^~~~
semantic.d:8253:53: error: cannot cast expression 'fun' of type 'FunctionDef' to 'bool'
		assert(fun && fun.type,text(fun," ",fun?fun.type:null," ",sc," ",this));
                                                    ^~~
interpret.d:4612:49: error: no member 'isArrayTy' for type 'Type'
				if(self.e.type&&self.e.type.getHeadUnqual().isArrayTy())
                                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:44:19: error: feature expression.TraitsExp not implemented
	static if(__traits(hasMember,T,"manualPropagate") && T.manualPropagate)
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4635:36: error: cannot cast expression 'self.type' of type 'Type' to 'bool'
				if(self.type) // alias declarations can contain such expressions (TODO: should they?)
                                   ^~~~~~~~~
interpret.d:4636:36: error: cannot cast expression 'self.type.getHeadUnqual().getFunctionTy()' of type 'FunctionTy' to 'bool'
				if(self.type.getHeadUnqual().getFunctionTy())
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4637:36: error: cannot cast expression 'auto this_=self.e1.extractThis()' of type 'Expression' to 'bool'
				if(auto this_=self.e1.extractThis())
                                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4638:48: error: no member 'isAggregateTy' for type 'Type'
				if(auto aggrty=this_.type.isAggregateTy())
                                               ^~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:44:19: error: feature expression.TraitsExp not implemented
	static if(__traits(hasMember,T,"manualPropagate") && T.manualPropagate)
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4623:36: error: cannot cast expression 'self.tmpVarDecl' of type 'VarDecl' to 'bool'
				if(self.tmpVarDecl) self.tmpVarDecl.inHeapContext = true;
                                   ^~~~~~~~~~~~~~~
interpret.d:4624:37: error: cannot cast expression 'self.fun' of type 'Expression' to 'bool'
				if(!self.fun || !self.fun.type) return; // TODO: ok?
                                    ^~~~~~~~
interpret.d:4624:50: error: cannot cast expression 'self.fun.type' of type 'Type' to 'bool'
				if(!self.fun || !self.fun.type) return; // TODO: ok?
                                                 ^~~~~~~~~~~~~
interpret.d:4626:42: error: cannot cast expression 'tt' of type 'FunctionTy' to 'bool'
				assert(!!tt,text(self.fun.type));
                                         ^~
semantic.d:8256:29: error: cannot cast expression 'e' of type 'Expression' to 'bool'
			if(!e) fun.type.resolveReturn(Type.get!void());
                            ^
interpret.d:4607:49: error: no member 'isArrayTy' for type 'Type'
				if(self.e.type&&self.e.type.getHeadUnqual().isArrayTy())
                                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:47:23: error: too many arguments to struct literal (expected zero)
	auto result = T(args);
                      ^~~~~~~
interpret.d:4649:47: error: undefined identifier 'STCstatic'
				if(!(self.stc&STCstatic)) self.resetByteCode();
                                              ^~~~~~~~~
interpret.d:4715:29: error: no member 'init' for type 'ByteCodeBuilder'
			bld=ByteCodeBuilder.init;
                            ^~~~~~~~~~~~~~~~~~~~
interpret.d:4717:25: error: undefined identifier 'size_t'
			size_t loc = 0, len = 0;
                        ^~~~~~
interpret.d:4717:25: error: undefined identifier 'size_t'
			size_t loc = 0, len = 0;
                        ^~~~~~
analyze.d:48:26: error: feature expression.TraitsExp not implemented
	alias TypeTuple!(__traits(getOverloads,T,"perform")) overloads;
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:48:26: error: feature expression.TraitsExp not implemented
	alias TypeTuple!(__traits(getOverloads,T,"perform")) overloads;
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4653:47: error: undefined identifier 'STCstatic'
				if(!(self.stc&STCstatic)) self.resetByteCode();
                                              ^~~~~~~~~
interpret.d:4718:34: error: undefined identifier 'STCstatic'
			if(!(stc&STCstatic)) loc+=bcPointerBCSize; // context pointer
                                 ^~~~~~~~~
analyze.d:44:19: error: feature expression.TraitsExp not implemented
	static if(__traits(hasMember,T,"manualPropagate") && T.manualPropagate)
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:52:28: error: undefined identifier 'manualPropagate'
		static if(!manualPropagate) node._doAnalyze(&runIt);
                           ^~~~~~~~~~~~~~~
analyze.d:52:28: error: undefined identifier 'manualPropagate'
		static if(!manualPropagate) node._doAnalyze(&runIt);
                           ^~~~~~~~~~~~~~~
analyze.d:19:52: error: feature expression.TraitsExp not implemented
				foreach(_idfododi; __traits(allMembers, T)){
                                                   ^~~~~~~~~~~~~~~~~~~~~~~
analyze.d:61:20: error: undefined identifier 'manualPropagate'
	static if(!manualPropagate) return result;
                   ^~~~~~~~~~~~~~~
analyze.d:61:20: error: undefined identifier 'manualPropagate'
	static if(!manualPropagate) return result;
                   ^~~~~~~~~~~~~~~
interpret.d:4575:41: note: instantiated here
					runAnalysis!MarkHeapContext(this_);
                                        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4672:24: note: instantiated here
		return runAnalysis!CollectVariables(this,this,dg).r;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:23:31: note: instantiated here
			mixin Analyze; // wtf?
                              ^~~~~~~
analyze.d:44:19: error: feature expression.TraitsExp not implemented
	static if(__traits(hasMember,T,"manualPropagate") && T.manualPropagate)
                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:48:26: error: feature expression.TraitsExp not implemented
	alias TypeTuple!(__traits(getOverloads,T,"perform")) overloads;
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:47:23: error: too many arguments to struct literal (expected zero)
	auto result = T(args);
                      ^~~~~~~
semantic.d:6005:39: error: undefined identifier 'RefConvertsTo'
				mixin(RefConvertsTo!q{bool conv; etu, ttu, 0});
                                      ^~~~~~~~~~~~~
analyze.d:52:28: error: undefined identifier 'manualPropagate'
		static if(!manualPropagate) node._doAnalyze(&runIt);
                           ^~~~~~~~~~~~~~~
analyze.d:61:20: error: undefined identifier 'manualPropagate'
	static if(!manualPropagate) return result;
                   ^~~~~~~~~~~~~~~
interpret.d:4656:17: note: instantiated here
		runAnalysis!HeapContextAnalysis(this);
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:48:26: error: feature expression.TraitsExp not implemented
	alias TypeTuple!(__traits(getOverloads,T,"perform")) overloads;
                         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
analyze.d:52:28: error: undefined identifier 'manualPropagate'
		static if(!manualPropagate) node._doAnalyze(&runIt);
                           ^~~~~~~~~~~~~~~
analyze.d:61:20: error: undefined identifier 'manualPropagate'
	static if(!manualPropagate) return result;
                   ^~~~~~~~~~~~~~~
interpret.d:4704:17: note: instantiated here
		runAnalysis!Subscribe(this, this);
                ^~~~~~~~~~~~~~~~~~~~~
interpret.d:4626:45: error: undefined identifier 'text'
				assert(!!tt,text(self.fun.type));
                                            ^~~~
<mixin@semantic.d:8259>:4:9: error: need 'this' to access field 'Identifier.tryAgain'
	Identifier.tryAgain = true;
        ^~~~~~~~~~~~~~~~~~~
semantic.d:5664:9: note: field was declared here
	static bool tryAgain = false;
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4720:36: error: no member 'stc' for type 'Parameter[]'
				if(x.stc&STCbyref) len = getBCSizeof(x.type.getPointer());
                                   ^~~~~
<mixin@<mixin@semantic.d:8259>:6>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4720:70: error: no member 'type' for type 'Parameter[]'
				if(x.stc&STCbyref) len = getBCSizeof(x.type.getPointer());
                                                                     ^~~~~~
semantic.d:6006:36: error: undefined identifier 'conv'
				if(conv) goto Lok;
                                   ^~~~
interpret.d:4721:41: error: no member 'stc' for type 'Parameter[]'
				else if(x.stc&STClazy) len = bcPointerBCSize+bcFunPointerBCSiz; // TODO: ok?
                                        ^~~~~
semantic.d:6009:37: error: no member 'isSymbol' for type 'Expression'
			if(auto sym=e1.isSymbol())
                                    ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8265>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8265>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8267:26: error: cannot cast expression 'e' of type 'Expression' to 'bool'
		}else if(e){
                         ^
semantic.d:10968:30: error: undefined identifier 'fsc'
		foreach(gto;&fsc.unresolvedLabels){
                             ^~~
semantic.d:10981:48: error: undefined identifier 'STCstatic'
			if(canBeStatic) stc |= STCstatic;
                                               ^~~~~~~~~
semantic.d:10982:38: error: undefined identifier 'STCstatic'
			else stc &= ~STCstatic; // struct/class member delegates
                                     ^~~~~~~~~
semantic.d:6012:39: error: undefined identifier 'IsDeclAccessible'
				mixin(IsDeclAccessible!q{bool acc; Declaration, decl, sym.meaning});
                                      ^~~~~~~~~~~~~~~~
semantic.d:8269:28: error: cannot cast expression 'fun.type.rret' of type 'Expression' to 'bool'
			if(fun.type.rret) mixin(PropErr!q{fun.type.rret});
                           ^~~~~~~~~~~~~
semantic.d:8270:34: error: cannot cast expression 'fun.type.ret' of type 'Type' to 'bool'
			assert(!!fun.type.ret);
                                 ^~~~~~~~~~~~
interpret.d:4721:47: error: undefined identifier 'STClazy'
				else if(x.stc&STClazy) len = bcPointerBCSize+bcFunPointerBCSiz; // TODO: ok?
                                              ^~~~~~~
<mixin@<mixin@semantic.d:10984>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:10984>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4785:28: error: too many arguments to struct literal (expected zero)
		auto stack=Stack(stackst[]);
                           ^~~~~~~~~~~~~~~~
semantic.d:8274:41: error: undefined identifier 'STCref'
			if(fun.type.stc&STCref && !e.checkLvalue(sc,e.loc)) mixin(ErrEplg);
                                        ^~~~~~
interpret.d:4789:17: error: function call result 'this.byteCode()' of type 'immutable(ulong)[]' is not callable
		byteCode.doInterpret(stack, handler);
                ^~~~~~~~
<mixin@<mixin@semantic.d:8274>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8274>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4795:17: error: feature declaration.VersionDecl not implemented
		version(LittleEndian) enum endiannessok=true;
                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:6013:36: error: undefined identifier 'acc'
				if(acc) goto Lok;
                                   ^~~
semantic.d:6016:34: error: undefined identifier 'format'
			sc.error(format("need 'this' to access %s '%s'",
                                 ^~~~~~
semantic.d:6017:41: error: cannot cast expression 'e2.meaning' of type 'Declaration' to 'bool'
			                e2.meaning?e2.kind:"member",e2.loc.rep),loc);
                                        ^~~~~~~~~~
semantic.d:6018:28: error: cannot cast expression 'e2.meaning' of type 'Declaration' to 'bool'
			if(e2.meaning) sc.note(format("%s was declared here",e2.kind),e2.meaning.loc);
                           ^~~~~~~~~~
semantic.d:6018:48: error: undefined identifier 'format'
			if(e2.meaning) sc.note(format("%s was declared here",e2.kind),e2.meaning.loc);
                                               ^~~~~~
<mixin@<mixin@semantic.d:6019>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:6019>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:6024:23: error: undefined identifier 'RefConvertsTo'
		mixin(RefConvertsTo!q{bool conv; etu, ttu, 0});
                      ^~~~~~~~~~~~~
semantic.d:6025:21: error: undefined identifier 'conv'
		if(!conv){
                    ^~~~
semantic.d:6026:34: error: undefined identifier 'format'
			sc.error(format("need 'this' of type '%s' to access %s '%s'",
                                 ^~~~~~
<mixin@<mixin@semantic.d:6028>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:6028>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8276:34: error: undefined identifier 'format'
			sc.error(format("non-void function '%s' should return a value",fun.name),loc);
                                 ^~~~~~
interpret.d:4722:56: error: no member 'type' for type 'Parameter[]'
				else len = getBCSizeof(x.type);
                                                       ^~~~~~
<mixin@<mixin@semantic.d:8277>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8277>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
semantic.d:8280:55: error: undefined identifier 'STCref'
		isRefReturn = cast(bool)(fun.type.stc&STCref);
                                                      ^~~~~~
semantic.d:8281:45: error: cannot cast expression 'e' of type 'Expression' to 'bool'
		if(isRefReturn && (assert(!!e),!e.checkLvalue(sc,e.loc))) mixin(ErrEplg);
                                            ^
<mixin@<mixin@semantic.d:8281>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8281>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4723:33: error: no member 'setBCLoc' for type 'Parameter[]'
				x.setBCLoc(loc, len);
                                ^~~~~~~~~~
semantic.d:8283:20: error: cannot cast expression 'e' of type 'Expression' to 'bool'
		if(e&&!e.finishDeduction(sc)) mixin(ErrEplg);
                   ^
<mixin@<mixin@semantic.d:8283>:3>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8283>:5>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
<mixin@<mixin@semantic.d:8284>:2>:3:9: error: type 'Scheduler' is not callable
	Scheduler().remove(this);
        ^~~~~~~~~~~
<mixin@<mixin@semantic.d:8284>:4>:3:24: error: feature expression.IsExp not implemented
	else static if(is(typeof(return)==class)) return null;
                       ^~~~~~~~~~~~~~~~~~~~~~~~~
visitors.d:19:55: note: instantiated here
	static if(!IsNonASTType!(typeof(this))) mixin Semantic!(typeof(this));
                                                      ^~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4796:31: error: undefined identifier 'endiannessok'
		static assert(endiannessok);
                              ^~~~~~~~~~~~
interpret.d:4729:31: error: undefined identifier 'util'
			alias util.any any;
                              ^~~~
interpret.d:4730:51: error: undefined identifier 'STCstatic'
			bool hasBCContext = !(stc&STCstatic) || any!(_=>_.inHeapContext)(type.params);
                                                  ^~~~~~~~~
interpret.d:4737:42: error: undefined identifier 'STCstatic'
				if(!(stc&STCstatic)){
                                         ^~~~~~~~~
interpret.d:4747:45: error: no member 'inHeapContext' for type 'Parameter[]'
					if(!x.inHeapContext) continue;
                                            ^~~~~~~~~~~~~~~
interpret.d:4748:41: error: undefined identifier 'size_t'
					size_t coff = bld.getContextOffset();
                                        ^~~~~~
interpret.d:4749:41: error: undefined identifier 'size_t'
					size_t slen, soff = x.getBCLoc(slen);
                                        ^~~~~~
interpret.d:4749:41: error: undefined identifier 'size_t'
					size_t slen, soff = x.getBCLoc(slen);
                                        ^~~~~~
interpret.d:4749:61: error: no member 'getBCLoc' for type 'Parameter[]'
					size_t slen, soff = x.getBCLoc(slen);
                                                            ^~~~~~~~~~
interpret.d:4750:41: error: no member 'setBCLoc' for type 'Parameter[]'
					x.setBCLoc(coff, slen);
                                        ^~~~~~~~~~
interpret.d:4757:73: error: cannot implicitly convert parameter 'x' of type 'Parameter[]' to 'Node'
						bld.emitUnsafe(I.popcn, x);
                                                                        ^
interpret.d:1081:43: note: while matching function parameter 'info'
	void emitUnsafe(Instruction inst, ErrorInfo info)in{assert(isUnsafe(inst));}body{
                                          ^~~~~~~~~~~~~~
interpret.d:4801:46: error: no member 'sizeof' for type 'ulong'
		assert(ctsize<=(stack.stp+1)*ulong.sizeof);
                                             ^~~~~~~~~~~~
interpret.d:4771:51: error: undefined identifier 'writeln'
				import std.stdio; writeln("byteCode for ",name," ",scope_.getDeclaration()?scope_.getDeclaration().name.name:"",":\n",_byteCode.toString());
                                                  ^~~~~~~
interpret.d:4771:84: error: cannot cast expression 'scope_.getDeclaration()' of type 'Declaration' to 'bool'
				import std.stdio; writeln("byteCode for ",name," ",scope_.getDeclaration()?scope_.getDeclaration().name.name:"",":\n",_byteCode.toString());
                                                                                   ^~~~~~~~~~~~~~~~~~~~~~~
interpret.d:4771:151: error: no member 'toString' for type 'immutable(ulong)[]'
				import std.stdio; writeln("byteCode for ",name," ",scope_.getDeclaration()?scope_.getDeclaration().name.name:"",":\n",_byteCode.toString());
                                                                                                                                                      ^~~~~~~~~~~~~~~~~~
